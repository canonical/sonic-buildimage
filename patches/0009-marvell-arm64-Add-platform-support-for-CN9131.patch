From f2a47ceb3185971f6743e388e3294d91713c43cf Mon Sep 17 00:00:00 2001
From: Pavan Naregundi <pnaregundi@marvell.com>
Date: Wed, 2 Aug 2023 11:54:03 +0000
Subject: marvell-arm64: Add platform support for CN9131

Signed-off-by: Pavan Naregundi <pnaregundi@marvell.com>
---
 platform/marvell-arm64/one-image.mk           |   1 +
 .../platform-rd98dx35xx-cn9131.mk             |  10 +
 platform/marvell-arm64/platform.conf          |  20 +-
 platform/marvell-arm64/rules.mk               |   1 +
 .../debian/changelog                          |   5 +
 .../debian/compat                             |   1 +
 .../debian/control                            |  13 +
 .../debian/install                            |   4 +
 .../debian/postinst                           |  12 +
 .../debian/rules                              |  78 ++++++
 .../scripts/rd98dx35xx-cn9131-init.sh         |  15 +
 .../service/rd98dx35xx-cn9131-init.service    |  11 +
 .../rd98dx35xx_cn9131/setup.py                |  15 +
 .../sonic_platform/__init__.py                |   3 +
 .../sonic_platform/chassis.py                 | 265 ++++++++++++++++++
 .../sonic_platform/component.py               |  94 +++++++
 .../sonic_platform/eeprom.py                  | 164 +++++++++++
 .../sonic_platform/platform.py                |  22 ++
 .../rd98dx35xx_cn9131/sonic_platform/sfp.py   | 214 ++++++++++++++
 .../sonic_platform/sfp_event.py               | 112 ++++++++
 .../sonic_platform/watchdog.py                | 184 ++++++++++++
 .../rd98dx35xx_cn9131/utils/get-base-mac.py   |  20 ++
 platform/marvell-arm64/sonic_fit.its          |  29 +-
 23 files changed, 1286 insertions(+), 7 deletions(-)
 create mode 100644 platform/marvell-arm64/platform-rd98dx35xx-cn9131.mk
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/changelog
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/compat
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/control
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/install
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/postinst
 create mode 100755 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/rules
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/scripts/rd98dx35xx-cn9131-init.sh
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/service/rd98dx35xx-cn9131-init.service
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/setup.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/__init__.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/chassis.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/component.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/eeprom.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/platform.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp_event.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/watchdog.py
 create mode 100644 platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/utils/get-base-mac.py

diff --git a/platform/marvell-arm64/one-image.mk b/platform/marvell-arm64/one-image.mk
index f5eb36504..f5955ceef 100644
--- a/platform/marvell-arm64/one-image.mk
+++ b/platform/marvell-arm64/one-image.mk
@@ -10,6 +10,7 @@ $(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(AC5X_RD98DX35xx_PLATFORM)
 $(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8540_16CD_PLATFORM)
 $(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(FALCON_DB98CX8580_32CD_PLATFORM)
 $(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(AC5X_RD98DX35xxEXT_PLATFORM)
+$(SONIC_ONE_IMAGE)_LAZY_INSTALLS += $(AC5X_RD98DX35xxCN9131_PLATFORM)
 ifeq ($(INSTALL_DEBUG_TOOLS),y)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(SONIC_INSTALL_DOCKER_DBG_IMAGES)
 $(SONIC_ONE_IMAGE)_DOCKERS += $(filter-out $(patsubst %-$(DBG_IMAGE_MARK).gz,%.gz, $(SONIC_INSTALL_DOCKER_DBG_IMAGES)), $(SONIC_INSTALL_DOCKER_IMAGES))
diff --git a/platform/marvell-arm64/platform-rd98dx35xx-cn9131.mk b/platform/marvell-arm64/platform-rd98dx35xx-cn9131.mk
new file mode 100644
index 000000000..a0fe7171f
--- /dev/null
+++ b/platform/marvell-arm64/platform-rd98dx35xx-cn9131.mk
@@ -0,0 +1,10 @@
+# AC5X External CN9131 CPU Platform
+
+include $(PLATFORM_PATH)/prestera.mk
+AC5X_VERSION=1.0
+AC5X_RD98DX35xxCN9131_PLATFORM = sonic-platform-rd98dx35xx-cn9131_$(AC5X_VERSION)_$(CONFIGURED_ARCH).deb
+$(AC5X_RD98DX35xxCN9131_PLATFORM)_SRC_PATH = $(PLATFORM_PATH)/sonic-platform-rd98dx35xx-cn9131
+$(AC5X_RD98DX35xxCN9131_PLATFORM)_DEPENDS += $(LINUX_HEADERS) $(LINUX_HEADERS_COMMON)
+$(AC5X_RD98DX35xxCN9131_PLATFORM)_PLATFORM = arm64-marvell_rd98DX35xx_cn9131-r0
+SONIC_DPKG_DEBS += $(AC5X_RD98DX35xxCN9131_PLATFORM)
+
diff --git a/platform/marvell-arm64/platform.conf b/platform/marvell-arm64/platform.conf
index 325ebf6f6..9d0909e60 100644
--- a/platform/marvell-arm64/platform.conf
+++ b/platform/marvell-arm64/platform.conf
@@ -28,15 +28,19 @@ PLATFORM=`sed -n 's/^onie_platform=\(.*\)/\1/p' $MACH_FILE`
 echo "Intalling SONiC from $install_env on Platform $PLATFORM"
 
 PLATFORM_AC5X=0
+PLATFORM_CN9131=0
+
+plt_cmdline_linux="default_hugepagesz=32M hugepages=4"
 
 case $PLATFORM in
     arm64-nokia_ixs7215_52xb-r0 | \
-    arm64-marvell_rd98DX35xx-r0) PLATFORM_AC5X=1
-				 plt_cmdline_linux="hugepages=4";;
+    arm64-marvell_rd98DX35xx-r0) PLATFORM_AC5X=1;;
 
     arm64-marvell_rd98DX35xx_ext-r0 | \
     arm64-marvell_db98cx8540_16cd-r0 | \
-    arm64-marvell_db98cx8580_32cd-r0) plt_cmdline_linux="hugepages=4";;
+    arm64-marvell_db98cx8580_32cd-r0) ;;
+
+    arm64-marvell_rd98DX35xx_cn9131-r0) PLATFORM_CN9131=1;;
 esac
 
 if [ $PLATFORM_AC5X -eq 1 ]; then
@@ -50,6 +54,15 @@ if [ $PLATFORM_AC5X -eq 1 ]; then
     demo_part=2
     fit_conf_name="#conf_ac5x"
     mmc_bus="mmc0:0001"
+elif [ $PLATFORM_CN9131 -eq 1 ]; then
+    fdt_addr=0x1000000
+    fit_addr=0x8000000
+    initrd_addr=0x2000000
+    fdt_fname="/usr/lib/linux-image-$kernel_version/marvell/cn9131-db-comexpress.dtb"
+    demo_part=2
+    FW_ENV_DEFAULT='/dev/mtd1 0x1F0000 0x10000 0x10000'
+    mmc_bus="mmc0:0001"
+    fit_conf_name="#conf_cn9131"
 else
     fdt_addr=0x1000000
     fit_addr=0x8000000
@@ -213,6 +226,7 @@ prepare_boot_menu() {
     fw_setenv ${FW_ARG} fdt_addr $fdt_addr > /dev/null
     fw_setenv ${FW_ARG} fit_addr $fit_addr > /dev/null
     fw_setenv ${FW_ARG} initrd_addr $initrd_addr > /dev/null
+    fw_setenv ${FW_ARG} fit_conf_name $fit_conf_name > /dev/null
     MMC_LOAD='ext4load mmc 0:'$demo_part' $fit_addr $fit_name'
     fw_setenv ${FW_ARG} sonic_boot_load "$MMC_LOAD" > /dev/null
     SONIC_BOOT_CMD='run sonic_bootargs; run sonic_boot_load; bootm $fit_addr${fit_conf_name}'
diff --git a/platform/marvell-arm64/rules.mk b/platform/marvell-arm64/rules.mk
index 78f3839d5..73b62948e 100644
--- a/platform/marvell-arm64/rules.mk
+++ b/platform/marvell-arm64/rules.mk
@@ -10,6 +10,7 @@ include $(PLATFORM_PATH)/platform-rd98dx35xx.mk
 include $(PLATFORM_PATH)/platform-db98cx8540-16cd.mk
 include $(PLATFORM_PATH)/platform-db98cx8580-32cd.mk
 include $(PLATFORM_PATH)/platform-rd98dx35xx-ext.mk
+include $(PLATFORM_PATH)/platform-rd98dx35xx-cn9131.mk
 
 SONIC_ALL += $(SONIC_ONE_IMAGE) \
              $(DOCKER_FPM) 	\
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/changelog b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/changelog
new file mode 100644
index 000000000..f71117b47
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/changelog
@@ -0,0 +1,5 @@
+sonic-platform-rd98dx35xx-cn9131 (1.0) unstable; urgency=low
+
+  * Add support for rd98dx35xx-cn9131.
+
+ -- Marvell <pnaregundi@marvell.com>  Mon, 30 Nov 2021 09:35:58 +0800
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/compat b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/compat
new file mode 100644
index 000000000..ec635144f
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/compat
@@ -0,0 +1 @@
+9
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/control b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/control
new file mode 100644
index 000000000..acf6fb51c
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/control
@@ -0,0 +1,13 @@
+Source: sonic-platform-rd98dx35xx-cn9131
+Section: unknown
+Priority: optional
+Maintainer: Marvell
+Build-Depends: debhelper (>=9)
+Standards-Version: 3.9.6
+Homepage: <insert the upstream URL, if relevant>
+
+Package: sonic-platform-rd98dx35xx-cn9131
+Architecture: arm64
+Depends: ${misc:Depends}
+Description: <insert up to 60 chars description>
+ <insert long description, indented with spaces>
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/install b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/install
new file mode 100644
index 000000000..1359b9261
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/install
@@ -0,0 +1,4 @@
+rd98dx35xx_cn9131/scripts/rd98dx35xx-cn9131-init.sh  usr/local/bin
+rd98dx35xx_cn9131/service/rd98dx35xx-cn9131-init.service etc/systemd/system
+rd98dx35xx_cn9131/sonic_platform-1.0-py3-none-any.whl usr/share/sonic/device/arm64-marvell_rd98DX35xx_cn9131-r0
+rd98dx35xx_cn9131/mrvl-prestera/platform/arm64/913x/* /
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/postinst b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/postinst
new file mode 100644
index 000000000..30ff9094c
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/postinst
@@ -0,0 +1,12 @@
+#!/bin/sh
+# postinst script for sonic-platform-rd98dx35xx-cn9131
+#
+# see: dh_installdeb(1)
+
+chmod a+x /usr/local/bin/rd98dx35xx-cn9131-init.sh
+depmod -a
+systemctl restart kmod
+systemctl enable rd98dx35xx-cn9131-init.service
+systemctl start rd98dx35xx-cn9131-init.service
+exit 0
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/rules b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/rules
new file mode 100755
index 000000000..ceabfbc82
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/debian/rules
@@ -0,0 +1,78 @@
+#!/usr/bin/make -f
+# See debhelper(7) (uncomment to enable)
+# output every command that modifies files on the build system.
+#export DH_VERBOSE = 1
+
+include /usr/share/dpkg/pkg-info.mk
+#--------------------------------------------------------
+
+PACKAGE_PRE_NAME := sonic-platform-rd98dx35xx-cn9131
+ifneq ($(CROSS_BUILD_ENVIRON), y)
+KVERSION   ?= $(shell uname -r)
+endif
+KERNEL_SRC :=  /lib/modules/$(KVERSION)
+INSTALL_MOD_DIR := kernel/extra/
+MOD_SRC_DIR:= $(shell pwd)
+MODULE_DIRS:= rd98dx35xx_cn9131
+UTILS_DIR := utils
+SERVICE_DIR := service
+PRESTERA_MODULE_DIR := mrvl-prestera/drivers/generic/cpssEnabler/linuxNoKernelModule/drivers
+
+%:
+	dh $@ --with systemd,python3 --buildsystem=pybuild
+
+clean:
+	dh_testdir
+	dh_testroot
+	dh_clean
+
+build:
+	(for mod in $(MODULE_DIRS); do \
+		cd $(MOD_SRC_DIR)/$${mod}/; \
+		rm -rf mrvl-prestera || true; \
+		git clone ${MRVL_PRESTERA_SRC_URL}; \
+		cd mrvl-prestera && git checkout ${MRVL_PRESTERA_SRC_TAG} && cd ..; \
+		cd $(MOD_SRC_DIR); \
+		make modules -C $(KERNEL_SRC)/build M=$(MOD_SRC_DIR)/$${mod}/$(PRESTERA_MODULE_DIR)/ CONFIG_KM_MVPCI=y CONFIG_KM_MVINT=y || exit 1; \
+		python3 $${mod}/setup.py bdist_wheel -d $(MOD_SRC_DIR)/$${mod}; \
+	done)
+
+binary: binary-arch binary-indep
+	# Nothing to do
+
+binary-arch:
+	# Nothing to do
+
+binary-indep:
+	dh_testdir
+	dh_installdirs
+
+	# Custom package commands
+	(for mod in $(MODULE_DIRS); do \
+		dh_installdirs -p$(PACKAGE_PRE_NAME) /$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
+		dh_installdirs -p$(PACKAGE_PRE_NAME) /usr/local/bin; \
+		dh_installdirs -p$(PACKAGE_PRE_NAME) /lib/systemd/system; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(SERVICE_DIR)/*.service debian/$(PACKAGE_PRE_NAME)/lib/systemd/system/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(UTILS_DIR)/* debian/$(PACKAGE_PRE_NAME)/usr/local/bin/; \
+		cp $(MOD_SRC_DIR)/$${mod}/$(PRESTERA_MODULE_DIR)/mvcpss.ko debian/$(PACKAGE_PRE_NAME)/$(KERNEL_SRC)/$(INSTALL_MOD_DIR); \
+		python3 $${mod}/setup.py install --root=$(MOD_SRC_DIR)/debian/$(PACKAGE_PRE_NAME) --install-layout=deb; \
+	done)
+
+	# Resuming debhelper scripts
+	dh_testroot
+	dh_install
+	dh_installchangelogs
+	dh_installdocs
+	dh_systemd_enable
+	dh_installinit
+	dh_systemd_start
+	dh_link
+	dh_fixperms
+	dh_compress
+	dh_strip
+	dh_installdeb
+	dh_gencontrol
+	dh_md5sums
+	dh_builddeb
+
+.PHONY: build binary binary-arch binary-indep clean
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/scripts/rd98dx35xx-cn9131-init.sh b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/scripts/rd98dx35xx-cn9131-init.sh
new file mode 100644
index 000000000..69e0dd0b7
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/scripts/rd98dx35xx-cn9131-init.sh
@@ -0,0 +1,15 @@
+#!/bin/bash
+
+# Platform init script for rd98dx35xx-cn9131
+
+rd98dx35xx-cn9131_profile()
+{
+    MAC_ADDR=$(fw_printenv -n ethaddr)
+    find /usr/share/sonic/device/*rd98DX35xx_cn9131* -name profile.ini | xargs sed -i "s/switchMacAddress=.*/switchMacAddress=$MAC_ADDR/g"
+    echo "rd98dx35xx_cn9131: Updating switch mac address ${MAC_ADDR}"
+}
+
+# - Main entry
+rd98dx35xx-cn9131_profile
+
+exit 0
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/service/rd98dx35xx-cn9131-init.service b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/service/rd98dx35xx-cn9131-init.service
new file mode 100644
index 000000000..5693ce887
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/service/rd98dx35xx-cn9131-init.service
@@ -0,0 +1,11 @@
+[Unit]
+Description=Platform rd98dx35xx-cn9131 Service
+After=sysinit.target
+Before=pmon.target
+
+[Service]
+ExecStart=/usr/local/bin/rd98dx35xx-cn9131-init.sh
+StandardOutput=tty
+
+[Install]
+WantedBy=multi-user.target
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/setup.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/setup.py
new file mode 100644
index 000000000..101f32216
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/setup.py
@@ -0,0 +1,15 @@
+#!/usr/bin/env python
+
+import os
+from setuptools import setup
+os.listdir
+
+setup(
+   name='sonic_platform',
+   version='1.0',
+   description='Module to initialize platforms',
+
+   packages=['sonic_platform'],
+   package_dir={'sonic_platform': 'rd98dx35xx_cn9131/sonic_platform'},
+)
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/__init__.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/__init__.py
new file mode 100644
index 000000000..4bfefa0fb
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/__init__.py
@@ -0,0 +1,3 @@
+__all__ = ["platform", "chassis"]
+from sonic_platform import *
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/chassis.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/chassis.py
new file mode 100644
index 000000000..eb6dcb95a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/chassis.py
@@ -0,0 +1,265 @@
+#!/usr/bin/env python
+##################################################################
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+##################################################################
+
+try:
+    import os
+    import sys
+    from sonic_platform_base.chassis_base import ChassisBase
+    from sonic_platform.sfp import Sfp
+    from sonic_platform.eeprom import Eeprom
+    from sonic_py_common import logger
+    from sonic_platform.component import Component
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+MAX_SELECT_DELAY = 3600
+COPPER_PORT_START = 1
+COPPER_PORT_END = 48
+SFP_PORT_START =49 
+SFP_PORT_END = 54 
+PORT_END = 54
+MAX_COMPONENT=2
+
+
+SYSLOG_IDENTIFIER = "chassis"
+sonic_logger=logger.Logger(SYSLOG_IDENTIFIER)
+class Chassis(ChassisBase):
+    """
+    Platform-specific Chassis class
+    derived from Dell S6000 platform.
+    customized for the platform.
+    """
+    reset_reason_dict = {}
+    reset_reason_dict[0x02] = ChassisBase.REBOOT_CAUSE_POWER_LOSS
+    reset_reason_dict[0x20] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_ASIC
+
+    reset_reason_dict[0x08] = ChassisBase.REBOOT_CAUSE_THERMAL_OVERLOAD_CPU
+    reset_reason_dict[0x10] = ChassisBase.REBOOT_CAUSE_WATCHDOG
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+    PLATFORM = "arm64-marvell_rd98DX35xx_cn9131-r0"
+    HWSKU = "rd98DX35xx_cn9131"
+
+
+    def __init__(self):
+        ChassisBase.__init__(self)
+        # Port numbers for Initialize SFP list
+        self.COPPER_PORT_START = COPPER_PORT_START
+        self.COPPER_PORT_END = COPPER_PORT_END
+        self.SFP_PORT_START = SFP_PORT_START
+        self.SFP_PORT_END = SFP_PORT_END
+        self.PORT_END = PORT_END
+
+        eeprom_path = '/sys/bus/i2c/devices/0-0050/eeprom'
+
+        # for non-sfp ports create dummy objects for copper / non-sfp ports
+        for index in range(self.COPPER_PORT_START, self.COPPER_PORT_END+1):
+            port=index-1
+            sfp_node = Sfp(index, 'COPPER', 'N/A', 'N/A')
+            self._sfp_list.append(sfp_node)
+
+        for index in range(self.SFP_PORT_START, self.SFP_PORT_END+1):
+            i2cdev = 0
+            port=index-1
+            port_eeprom_path = eeprom_path
+            if not os.path.exists(port_eeprom_path):
+                sonic_logger.log_info(" DEBUG - path %s -- did not exist " % port_eeprom_path )
+            sfp_node = Sfp(index, 'SFP', port_eeprom_path, i2cdev )
+            self._sfp_list.append(sfp_node)
+        self.sfp_event_initialized = False
+
+        # Instantiate ONIE system eeprom object
+        self._eeprom = Eeprom()
+
+        for i in range(MAX_COMPONENT):
+             component = Component(i)
+             self._component_list.append(component)
+
+
+    def __is_host(self):
+        return os.system(self.HOST_CHK_CMD) == 0
+
+    def get_sfp(self, index):
+        """
+        Retrieves sfp represented by (1-based) index <index>
+        Args:
+            index: An integer, the index (1-based) of the sfp to retrieve.
+            The index should be the sequence of physical SFP ports in a chassis,
+            starting from 1.
+            For example, 1 for first SFP port in the chassis and so on.
+        Returns:
+            An object dervied from SfpBase representing the specified sfp
+        """
+        sfp = None
+        try:
+            # The index will start from 1
+            sfp = self._sfp_list[index-1]
+        except IndexError:
+            sys.stderr.write("SFP index {} out of range (1-{})\n".format(
+                             index, len(self._sfp_list)))
+        return sfp
+
+    def get_name(self):
+        """
+        Retrieves the name of the chassis
+        Returns:
+            string: The name of the chassis
+        """
+        return self._eeprom.modelstr()
+
+    def get_presence(self):
+        """
+        Retrieves the presence of the chassis
+        Returns:
+            bool: True if chassis is present, False if not
+        """
+        return True
+
+    def get_model(self):
+        """
+        Retrieves the model number (or part number) of the chassis
+        Returns:
+            string: Model/part number of chassis
+        """
+        return self._eeprom.part_number_str()
+
+    def get_serial(self):
+        """
+        Retrieves the serial number of the chassis (Service tag)
+        Returns:
+            string: Serial number of chassis
+        """
+        return self._eeprom.serial_str()
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the chassis
+        Returns:
+            bool: A boolean value, True if chassis is operating properly
+            False if not
+        """
+        return True
+
+    def get_base_mac(self):
+        """
+        Retrieves the base MAC address for the chassis
+
+        Returns:
+            A string containing the MAC address in the format
+            'XX:XX:XX:XX:XX:XX'
+        """
+        return self._eeprom.base_mac_addr()
+
+    def get_serial_number(self):
+        """
+        Retrieves the hardware serial number for the chassis
+
+        Returns:
+            A string containing the hardware serial number for this
+            chassis.
+        """
+        return self._eeprom.serial_number_str()
+
+    def get_system_eeprom_info(self):
+        """
+        Retrieves the full content of system EEPROM information for the
+        chassis
+
+        Returns:
+            A dictionary where keys are the type code defined in
+            OCP ONIE TlvInfo EEPROM format and values are their
+            corresponding values.
+        """
+        return self._eeprom.system_eeprom_info()
+
+    def get_reboot_cause(self):
+        """
+        Retrieves the cause of the previous reboot
+        Returns:
+            A tuple (string, string) where the first element is a string
+            containing the cause of the previous reboot. This string must be
+            one of the predefined strings in this class. If the first string
+            is "REBOOT_CAUSE_HARDWARE_OTHER", the second string can be used
+            to pass a description of the reboot cause.
+        """
+        #lrr = self._get_cpld_register('mb_reboot_cause')
+        #if (lrr != 'ERR'):
+        #    reset_reason = lrr
+        #    if (reset_reason in self.reset_reason_dict):
+        #        return (self.reset_reason_dict[reset_reason], None)
+        #
+        return (ChassisBase.REBOOT_CAUSE_NON_HARDWARE, None)
+
+    def get_watchdog(self):
+        """
+        Retrieves hardware watchdog device on this chassis
+
+        Returns:
+            An object derived from WatchdogBase representing the hardware
+            watchdog device
+        """
+        try:
+            if self._watchdog is None:
+                from sonic_platform.watchdog import WatchdogImplBase
+                watchdog_device_path = "/dev/watchdog0"
+                self._watchdog = WatchdogImplBase(watchdog_device_path)
+        except Exception as e:
+            sonic_logger.log_warning(" Fail to load watchdog {}".format(repr(e)))
+
+        return self._watchdog
+
+    def get_change_event(self, timeout=0):
+        """
+        Returns a nested dictionary containing all devices which have
+        experienced a change at chassis level
+        Args:
+            timeout: Timeout in milliseconds (optional). If timeout == 0,
+                this method will block until a change is detected.
+        Returns:
+            (bool, dict):
+                - True if call successful, False if not;
+                - A nested dictionary where key is a device type,
+                  value is a dictionary with key:value pairs in the format of
+                  {'device_id':'device_event'},
+                  where device_id is the device ID for this device and
+                        device_event,
+                             status='1' represents device inserted,
+                             status='0' represents device removed.
+                  Ex. {'fan':{'0':'0', '2':'1'}, 'sfp':{'11':'0'}}
+                      indicates that fan 0 has been removed, fan 2
+                      has been inserted and sfp 11 has been removed.
+        """
+        # Initialize SFP event first
+        if not self.sfp_event_initialized:
+            from sonic_platform.sfp_event import sfp_event
+            self.sfp_event = sfp_event()
+            self.sfp_event.initialize()
+            self.MAX_SELECT_EVENT_RETURNED = self.PORT_END
+            self.sfp_event_initialized = True
+
+        wait_for_ever = (timeout == 0)
+        port_dict = {}
+        if wait_for_ever:
+            # xrcvd will call this monitor loop in the "SYSTEM_READY" state
+            # logger.log_info(" wait_for_ever get_change_event %d" % timeout)
+            timeout = MAX_SELECT_DELAY
+            while True:
+                status = self.sfp_event.check_sfp_status( port_dict, timeout)
+                if not port_dict == {}:
+                    break
+        else:
+            # At boot up and in "INIT" state call from xrcvd will have a timeout value
+            # return true without change after timeout and will transition to "SYSTEM_READY"
+            # logger.log_info(" initial get_change_event %d" % timeout )
+            status = self.sfp_event.check_sfp_status( port_dict, timeout)
+
+        if status:
+            return True, {'sfp':port_dict}
+        else:
+            return True, {'sfp':{}}
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/component.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/component.py
new file mode 100644
index 000000000..16e01486d
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/component.py
@@ -0,0 +1,94 @@
+########################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the Components' (e.g., BIOS, CPLD, FPGA, etc.) available in
+# the platform
+#
+########################################################################
+
+try:
+    import sys
+    import subprocess
+    from sonic_platform_base.component_base import ComponentBase
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+if sys.version_info[0] < 3:
+    import commands as cmd
+else:
+    import subprocess as cmd
+
+
+class Component(ComponentBase):
+    """platform-specific Component class"""
+
+    CHASSIS_COMPONENTS = [
+        ["U-Boot", "Performs initialization during booting"],
+        ["ONIE-VERSION", "ONIE - Open Network Install Environment"],
+    ]
+
+    def __init__(self, component_index):
+        self.index = component_index
+        self.name = self.CHASSIS_COMPONENTS[self.index][0]
+        self.description = self.CHASSIS_COMPONENTS[self.index][1]
+
+    def _get_command_result(self, cmdline):
+        try:
+            proc = subprocess.Popen(cmdline.split(), stdout=subprocess.PIPE,
+                                    stderr=subprocess.STDOUT)
+            stdout = proc.communicate()[0]
+            proc.wait()
+            result = stdout.rstrip('\n')
+        except OSError:
+            result = None
+
+        return result
+
+
+    def get_name(self):
+        """
+        Retrieves the name of the component
+
+        Returns:
+            A string containing the name of the component
+        """
+        return self.name
+
+    def get_description(self):
+        """
+        Retrieves the description of the component
+
+        Returns:
+            A string containing the description of the component
+        """
+        return self.description
+
+    def get_firmware_version(self):
+        """
+        Retrieves the firmware version of the component
+
+        Returns:
+            A string containing the firmware version of the component
+        """
+
+        if self.index == 0:
+            cmdstatus, uboot_version = cmd.getstatusoutput('grep --null-data ^U-Boot /dev/mtd0ro | cut -d" " -f2')
+            return uboot_version
+
+        if self.index == 1:
+            cmdstatus, onie_version = cmd.getstatusoutput('grep ^onie_version /host/machine.conf | cut -f2 -d"="')
+            return onie_version
+
+    def install_firmware(self, image_path):
+        """
+        Installs firmware to the component
+
+        Args:
+            image_path: A string, path to firmware image
+
+        Returns:
+            A boolean, True if install was successful, False if not
+        """
+        return False
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/eeprom.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/eeprom.py
new file mode 100644
index 000000000..109672080
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/eeprom.py
@@ -0,0 +1,164 @@
+#!/usr/bin/env python
+
+########################################################################
+#
+# Module contains platform specific implementation of SONiC Platform
+# Base API and provides the EEPROMs' information.
+#
+# The different EEPROMs available are as follows:
+# - System EEPROM : Contains Serial number, Service tag, Base MA
+#                   address, etc. in ONIE TlvInfo EEPROM format.
+########################################################################
+
+
+try:
+    from sonic_platform_base.sonic_eeprom.eeprom_base import EepromDecoder
+    from sonic_platform_base.sonic_eeprom.eeprom_tlvinfo import TlvInfoDecoder
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Eeprom(TlvInfoDecoder):
+
+    I2C_DIR = "/sys/class/i2c-adapter/"
+
+    def __init__(self, is_psu=False, psu_index=0, is_fan=False, fan_index=0):
+        self.is_psu_eeprom = is_psu
+        self.is_fan_eeprom = is_fan
+        self.is_sys_eeprom = not (is_psu | is_fan)
+
+        if self.is_sys_eeprom:
+            self.start_offset = 0
+            self.eeprom_path = self.I2C_DIR + "i2c-0/0-0050/eeprom"
+            # System EEPROM is in ONIE TlvInfo EEPROM format
+            super(Eeprom, self).__init__(self.eeprom_path,
+                                         self.start_offset, '', True)
+            self._load_system_eeprom()
+        else:
+            print ("No other eeprom")
+
+    def _load_system_eeprom(self):
+        """
+        Reads the system EEPROM and retrieves the values corresponding
+        to the codes defined as per ONIE TlvInfo EEPROM format and fills
+        them in a dictionary.
+        """
+        try:
+            # Read System EEPROM as per ONIE TlvInfo EEPROM format.
+            self.eeprom_data = self.read_eeprom()
+        except Exception as e:
+            self.base_mac = 'NA'
+            self.serial_number = 'NA'
+            self.part_number = 'NA'
+            self.model_str = 'NA'
+            self.serial = 'NA'
+            self.eeprom_tlv_dict = dict()
+        else:
+            eeprom = self.eeprom_data
+            self.eeprom_tlv_dict = dict()
+
+            if not self.is_valid_tlvinfo_header(eeprom):
+                self.base_mac = 'NA'
+                self.serial_number = 'NA'
+                self.part_number = 'NA'
+                self.model_str = 'NA'
+                self.serial = 'NA'
+                return
+
+            total_length = (eeprom[9] << 8) | eeprom[10]
+            tlv_index = self._TLV_INFO_HDR_LEN
+            tlv_end = self._TLV_INFO_HDR_LEN + total_length
+
+            while (tlv_index + 2) < len(eeprom) and tlv_index < tlv_end:
+                if not self.is_valid_tlv(eeprom[tlv_index:]):
+                    break
+
+                tlv = eeprom[tlv_index:tlv_index + 2
+                             + eeprom[tlv_index + 1]]
+                code = "0x%02X" % (tlv[0])
+
+                if tlv[0] == self._TLV_CODE_VENDOR_EXT:
+                    value = str((tlv[2] << 24) | (tlv[3] << 16) |
+                                (tlv[4]<< 8) | tlv[5])
+                    value += str(tlv[6:6 + tlv[1]])
+                else:
+                    name, value = self.decoder(None, tlv)
+
+                self.eeprom_tlv_dict[code] = value
+                if eeprom[tlv_index] == self._TLV_CODE_CRC_32:
+                    break
+
+                tlv_index += eeprom[tlv_index+1] + 2
+
+            self.base_mac = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_MAC_BASE), 'NA')
+            self.serial_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERIAL_NUMBER), 'NA')
+            self.part_number = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PART_NUMBER), 'NA')
+            self.model_str = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_PRODUCT_NAME), 'NA')
+            self.serial = self.eeprom_tlv_dict.get(
+                                "0x%X" % (self._TLV_CODE_SERVICE_TAG), 'NA')
+
+    def _get_eeprom_field(self, field_name):
+        """
+        For a field name specified in the EEPROM format, returns the
+        presence of the field and the value for the same.
+        """
+        field_start = 0
+        for field in self.format:
+            field_end = field_start + field[2]
+            if field[0] == field_name:
+                return (True, self.eeprom_data[field_start:field_end])
+            field_start = field_end
+
+        return (False, None)
+
+    def serial_number_str(self):
+        """
+        Returns the serial number.
+        """
+        return self.serial_number
+
+    def part_number_str(self):
+        """
+        Returns the part number.
+        """
+        return self.part_number
+
+    def airflow_fan_type(self):
+        """
+        Returns the airflow fan type.
+        """
+        if self.is_psu_eeprom:
+            return int(self.psu_type.encode('hex'), 16)
+        if self.is_fan_eeprom:
+            return int(self.fan_type.encode('hex'), 16)
+
+    # System EEPROM specific methods
+    def base_mac_addr(self):
+        """
+        Returns the base MAC address found in the system EEPROM.
+        """
+        return self.base_mac
+
+    def modelstr(self):
+        """
+        Returns the Model name.
+        """
+        return self.model_str
+
+    def serial_str(self):
+        """
+        Returns the servicetag number.
+        """
+        return self.serial
+
+    def system_eeprom_info(self):
+        """
+        Returns a dictionary, where keys are the type code defined in
+        ONIE EEPROM format and values are their corresponding values
+        found in the system EEPROM.
+        """
+        return self.eeprom_tlv_dict
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/platform.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/platform.py
new file mode 100644
index 000000000..0b67a68b8
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/platform.py
@@ -0,0 +1,22 @@
+#!/usr/bin/env python
+
+#############################################################################
+#
+# Module contains an implementation of SONiC Platform Base API and
+# provides the platform information
+#
+#############################################################################
+
+try:
+    from sonic_platform_base.platform_base import PlatformBase
+    from sonic_platform.chassis import Chassis
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+
+class Platform(PlatformBase):
+
+    def __init__(self):
+        PlatformBase.__init__(self)
+        self._chassis = Chassis()
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp.py
new file mode 100644
index 000000000..91ff38a6a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp.py
@@ -0,0 +1,214 @@
+# Name: sfp.py, version: 1.0
+#
+# Description: Module contains the definitions of SFP related APIs
+#
+#
+
+try:
+    from sonic_platform_base.sonic_xcvr.sfp_optoe_base import SfpOptoeBase
+    from sonic_py_common.logger import Logger
+    from sonic_py_common import device_info
+    from sonic_py_common.general import getstatusoutput_noshell
+
+except ImportError as e:
+    raise ImportError(str(e) + "- required module not found")
+
+import subprocess as cmd
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+COPPER_TYPE = "COPPER"
+SFP_TYPE = "SFP"
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 54
+
+logger = Logger()
+
+class Sfp(SfpOptoeBase):
+    """
+    Platform-specific Sfp refactor class
+    """
+    instances = []
+
+    # Paths
+    PLATFORM_ROOT_PATH = "/usr/share/sonic/device"
+    PMON_HWSKU_PATH = "/usr/share/sonic/hwsku"
+    HOST_CHK_CMD = "docker > /dev/null 2>&1"
+
+    PLATFORM = "arm64-marvell_rd98DX35xx_cn9131-r0"
+    HWSKU = "rd98DX35xx_cn9131"
+
+    port_to_i2c_mapping = 0
+
+    # def __init__(self, index, sfp_type, stub):
+    def __init__(self, index, sfp_type, eeprom_path, port_i2c_map):
+        SfpOptoeBase.__init__(self)
+
+        self.index = index
+        self.port_num = index
+        self.sfp_type = sfp_type
+        self.eeprom_path = eeprom_path
+        self.port_to_i2c_mapping = port_i2c_map
+        self.name = sfp_type + str(index-1)
+        self.port_name = sfp_type + str(index)
+        self.port_to_eeprom_mapping = {}
+
+        self.port_to_eeprom_mapping[index] = eeprom_path
+
+        self._version_info = device_info.get_sonic_version_info()
+        self.lastPresence = False
+
+        logger.log_debug("Sfp __init__ index {} setting name to {} and eeprom_path to {}".format(index, self.name, self.eeprom_path))
+
+        Sfp.instances.append(self)
+        
+    def get_eeprom_path(self):
+        return self.eeprom_path
+
+    def get_presence(self):
+        """
+        Retrieves the presence
+        Returns:
+            bool: True if is present, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+
+        if smbus_present == 0:  # if called from sfputil outside of pmon
+            cmdstatus, sfpstatus = getstatusoutput_noshell(['sudo', 'i2cget', '-y', '0', '0x41', '0x3'])            
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x41
+            DEVICE_REG = 0x3
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+        pos = [1, 2, 4, 8]
+        bit_pos = pos[self.index-SFP_PORT_START]
+        sfpstatus = sfpstatus & (bit_pos)
+
+        if sfpstatus == 0:
+            return True
+
+        return False
+
+    def get_name(self):
+        """
+        Retrieves the name of the device
+            Returns:
+            string: The name of the device
+        """
+        return self.name
+
+    def get_position_in_parent(self):
+        """
+        Retrieves 1-based relative physical position in parent device.
+        Returns:
+            integer: The 1-based relative physical position in parent device or
+                     -1 if cannot determine the position
+        """
+        return -1
+
+    def is_replaceable(self):
+        """
+        Indicate whether this device is replaceable.
+        Returns:
+            bool: True if it is replaceable.
+        """
+
+        if self.sfp_type == "SFP":
+            return True
+        else:
+            return False
+
+    def _get_error_code(self):
+        """
+        Get error code of the SFP module
+
+        Returns:
+            The error code
+        """
+        return NotImplementedError
+
+    def get_error_description(self):
+        """
+        Get error description
+
+        Args:
+            error_code: The error code returned by _get_error_code
+
+        Returns:
+            The error description
+        """
+        if not self.get_presence():
+            error_description = self.SFP_STATUS_UNPLUGGED
+        else:
+            error_description = self.SFP_STATUS_OK
+
+        return error_description
+        # return NotImplementedError
+
+    def get_reset_status(self):
+        """
+        Retrieves the reset status of SFP
+        Returns:
+            A Boolean, True if reset enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_status(self):
+        """
+        Retrieves the operational status of the device
+        """
+        reset = self.get_reset_status()
+
+        if reset is True:
+            status = False
+        else:
+            status = True
+
+        return status
+
+    def reset(self):
+        """
+        Reset SFP.
+        Returns:
+            A boolean, True if successful, False if not
+        """
+        # RJ45 and SFP ports not resettable
+        return False
+
+    def set_lpmode(self, lpmode):
+        """
+        Sets the lpmode (low power mode) of SFP
+        Args:
+            lpmode: A Boolean, True to enable lpmode, False to disable it
+            Note  : lpmode can be overridden by set_power_override
+        Returns:
+            A boolean, True if lpmode is set successfully, False if not
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
+
+    def get_lpmode(self):
+        """
+        Retrieves the lpmode (low power mode) status of this SFP
+        Returns:
+            A Boolean, True if lpmode is enabled, False if disabled
+        """
+        if self.sfp_type == COPPER_TYPE:
+            return False
+        if self.sfp_type == SFP_TYPE:
+            return False
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp_event.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp_event.py
new file mode 100644
index 000000000..7f3d6c97b
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/sfp_event.py
@@ -0,0 +1,112 @@
+'''
+listen for the SFP change event and return to chassis.
+'''
+import time
+from sonic_py_common import logger
+from sonic_py_common.general import getstatusoutput_noshell
+
+smbus_present = 1
+
+try:
+    import smbus
+except ImportError as e:
+    smbus_present = 0
+
+# system level event/error
+EVENT_ON_ALL_SFP = '-1'
+SYSTEM_NOT_READY = 'system_not_ready'
+SYSTEM_READY = 'system_become_ready'
+SYSTEM_FAIL = 'system_fail'
+
+# SFP PORT numbers
+SFP_PORT_START = 49
+SFP_PORT_END = 54
+
+SYSLOG_IDENTIFIER = "sfp_event"
+sonic_logger = logger.Logger(SYSLOG_IDENTIFIER)
+
+
+class sfp_event:
+    ''' Listen to plugin/plugout cable events '''
+
+    def __init__(self):
+        self.handle = None
+
+    def initialize(self):
+        self.modprs_register = 0
+        # Get Transceiver status
+        time.sleep(5)
+        self.modprs_register = self._get_transceiver_status()
+        sonic_logger.log_info("Initial SFP presence=%d" % self.modprs_register)
+
+    def deinitialize(self):
+        if self.handle is None:
+            return
+
+    def _get_transceiver_status(self):
+        if smbus_present == 0:
+            sonic_logger.log_info("  PMON - smbus ERROR - DEBUG sfp_event   ")
+            cmdstatus, sfpstatus = getstatusoutput_noshell('sudo i2cget -y 0 0x76 0xa')
+            sfpstatus = int(sfpstatus, 16)
+        else:
+            bus = smbus.SMBus(0)
+            DEVICE_ADDRESS = 0x76
+            DEVICE_REG = 0xa
+            sfpstatus = bus.read_byte_data(DEVICE_ADDRESS, DEVICE_REG)
+
+            sfpstatus = ~sfpstatus
+            sfpstatus = sfpstatus & 0xF
+
+        return sfpstatus
+
+    def check_sfp_status(self, port_change, timeout):
+        """
+        check_sfp_status called from get_change_event, this will return correct
+            status of all 4 SFP ports if there is a change in any of them
+        """
+        start_time = time.time()
+        port = SFP_PORT_START
+        forever = False
+
+        if timeout == 0:
+            forever = True
+        elif timeout > 0:
+            timeout = timeout / float(1000)  # Convert to secs
+        else:
+            return False, {}
+        end_time = start_time + timeout
+
+        if (start_time > end_time):
+            return False, {}  # Time wrap or possibly incorrect timeout
+
+        while (timeout >= 0):
+            # Check for OIR events and return updated port_change
+            reg_value = self._get_transceiver_status()
+            if (reg_value != self.modprs_register):
+                changed_ports = (self.modprs_register ^ reg_value)
+                while (port >= SFP_PORT_START and port <= SFP_PORT_END):
+                    # Mask off the bit corresponding to our port
+                    mask = (1 << port-SFP_PORT_START)
+                    if (changed_ports & mask):
+                        # ModPrsL is active high
+                        if reg_value & mask == 0:
+                            port_change[port] = '0'
+                        else:
+                            port_change[port] = '1'
+                    port += 1
+
+                # Update reg value
+                self.modprs_register = reg_value
+                return True, port_change
+
+            if forever:
+                time.sleep(1)
+            else:
+                timeout = end_time - time.time()
+                if timeout >= 1:
+                    time.sleep(1)  # We poll at 1 second granularity
+                else:
+                    if timeout > 0:
+                        time.sleep(timeout)
+                    return True, {}
+        return False, {}
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/watchdog.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/watchdog.py
new file mode 100644
index 000000000..2726d19d4
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/sonic_platform/watchdog.py
@@ -0,0 +1,184 @@
+"""
+Module contains an implementation of SONiC Platform Base API and
+provides access to hardware watchdog
+"""
+
+import os
+import fcntl
+import array
+
+from sonic_platform_base.watchdog_base import WatchdogBase
+from sonic_py_common import logger
+
+""" ioctl constants """
+IO_READ = 0x80000000
+IO_SIZE_INT = 0x00040000
+IO_READ_WRITE = 0xC0000000
+IO_TYPE_WATCHDOG = ord('W') << 8
+
+WDR_INT = IO_READ | IO_SIZE_INT | IO_TYPE_WATCHDOG
+WDWR_INT = IO_READ_WRITE | IO_SIZE_INT | IO_TYPE_WATCHDOG
+
+""" Watchdog ioctl commands """
+WDIOC_SETOPTIONS = 4 | WDR_INT
+WDIOC_KEEPALIVE = 5 | WDR_INT
+WDIOC_SETTIMEOUT = 6 | WDWR_INT
+WDIOC_GETTIMEOUT = 7 | WDR_INT
+WDIOC_GETTIMELEFT = 10 | WDR_INT
+
+""" Watchdog status constants """
+WDIOS_DISABLECARD = 0x0001
+WDIOS_ENABLECARD = 0x0002
+
+""" watchdog sysfs """
+WD_SYSFS_PATH = "/sys/class/watchdog/"
+
+WD_COMMON_ERROR = -1
+
+sonic_logger = logger.Logger()
+
+
+class WatchdogImplBase(WatchdogBase):
+    """
+    Base class that implements common logic for interacting
+    with watchdog using ioctl commands
+    """
+
+    def __init__(self, wd_device_path):
+        """
+        Open a watchdog handle
+        @param wd_device_path Path to watchdog device
+        """
+
+        self.watchdog_path = wd_device_path
+        self.watchdog = os.open(self.watchdog_path, os.O_WRONLY)
+
+        # Opening a watchdog descriptor starts
+        # watchdog timer; by default it should be stopped
+        self._disablewatchdog()
+        self.armed = False
+        self.timeout = self._gettimeout()
+
+    def disarm(self):
+        """
+        Disarm the hardware watchdog
+
+        Returns:
+            A boolean, True if watchdog is disarmed successfully, False
+            if not
+        """
+        sonic_logger.log_info(" Debug disarm watchdog ")
+
+        try:
+            self._disablewatchdog()
+            self.armed = False
+            self.timeout = 0
+        except IOError:
+            return False
+
+        return True
+
+    def _disablewatchdog(self):
+        """
+        Turn off the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_DISABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _settimeout(self, seconds):
+        """
+        Set watchdog timer timeout
+        @param seconds - timeout in seconds
+        @return is the actual set timeout
+        """
+
+        req = array.array('I', [seconds])
+        fcntl.ioctl(self.watchdog, WDIOC_SETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeout(self):
+        """
+        Get watchdog timeout
+        @return watchdog timeout
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMEOUT, req, True)
+
+        return int(req[0])
+
+    def _gettimeleft(self):
+        """
+        Get time left before watchdog timer expires
+        @return time left in seconds
+        """
+
+        req = array.array('I', [0])
+        fcntl.ioctl(self.watchdog, WDIOC_GETTIMELEFT, req, True)
+
+        return int(req[0])
+
+
+    def arm(self, seconds):
+        """
+        Implements arm WatchdogBase API
+        """
+        sonic_logger.log_info(" Debug arm watchdog4 ")
+        ret = WD_COMMON_ERROR
+        if seconds < 0:
+            return ret
+
+        try:
+            if self.timeout != seconds:
+                self.timeout = self._settimeout(seconds)
+            if self.armed:
+                self._keepalive()
+            else:
+                sonic_logger.log_info(" Debug arm watchdog5 ")
+                self._enablewatchdog()
+                self.armed = True
+            ret = self.timeout
+        except IOError:
+            pass
+
+        return ret
+
+    def _enablewatchdog(self):
+        """
+        Turn on the watchdog timer
+        """
+
+        req = array.array('h', [WDIOS_ENABLECARD])
+        fcntl.ioctl(self.watchdog, WDIOC_SETOPTIONS, req, False)
+
+    def _keepalive(self):
+        """
+        Keep alive watchdog timer
+        """
+
+        fcntl.ioctl(self.watchdog, WDIOC_KEEPALIVE)
+
+    def is_armed(self):
+        """
+        Implements is_armed WatchdogBase API
+        """
+
+        return self.armed
+
+    def get_remaining_time(self):
+        """
+        Implements get_remaining_time WatchdogBase API
+        """
+
+        timeleft = WD_COMMON_ERROR
+
+        if self.armed:
+            try:
+                timeleft = self._gettimeleft()
+            except IOError:
+                pass
+
+        return timeleft
+
diff --git a/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/utils/get-base-mac.py b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/utils/get-base-mac.py
new file mode 100644
index 000000000..fe271d04a
--- /dev/null
+++ b/platform/marvell-arm64/sonic-platform-rd98dx35xx-cn9131/rd98dx35xx_cn9131/utils/get-base-mac.py
@@ -0,0 +1,20 @@
+#!/usr/bin/env python
+
+def main():
+    try:
+        import sonic_platform.platform
+        import sonic_platform.chassis
+    except ImportError, e:
+        raise ImportError (str(e) + "- required module not found")
+
+    chassis = sonic_platform.platform.Platform().get_chassis()
+    if chassis is None:
+        print "DEBUG chassis was None  "
+             
+    base_mac = chassis.get_base_mac()
+    print base_mac
+
+    return
+
+if __name__ == '__main__':
+    main()
diff --git a/platform/marvell-arm64/sonic_fit.its b/platform/marvell-arm64/sonic_fit.its
index 55adef8d9..b6eeea835 100644
--- a/platform/marvell-arm64/sonic_fit.its
+++ b/platform/marvell-arm64/sonic_fit.its
@@ -42,7 +42,7 @@
                 algo = "sha1";
             };
         };
-        kernel_7020 {
+        kernel_1 {
             description = "Linux Kernel";
             data = /incbin/("/boot/vmlinuz-5.10.0-18-2-arm64");
             type = "kernel";
@@ -67,7 +67,7 @@
                 algo = "sha1";
             };
         };
-        ramdisk_7020 {
+        ramdisk_1 {
             description = "ramdisk";
             data = /incbin/("/boot/initrd.img-5.10.0-18-2-arm64");
             type = "ramdisk";
@@ -80,6 +80,18 @@
                 algo = "sha1";
             };
         };
+        fdt_cn9131 {
+            description = "Flattened Device Tree blob";
+            data = /incbin/("/usr/lib/linux-image-5.10.0-18-2-arm64/marvell/cn9131-db-comexpress.dtb");
+            type = "flat_dt";
+            arch = "arm64";
+            compression = "none";
+            load = <0x1000000>;
+            entry = <0x1000000>;
+            hash@1 {
+                algo = "sha1";
+            };
+        };
     };
     configurations {
         default = "conf_ac5x";
@@ -94,9 +106,18 @@
         };
         conf@1 {
             description = "Boot Linux kernel with FDT blob + ramdisk for Armada7020";
-            kernel = "kernel_7020";
+            kernel = "kernel_1";
             fdt = "fdt_7020";
-            ramdisk = "ramdisk_7020";
+            ramdisk = "ramdisk_1";
+            hash@1 {
+                algo = "sha1";
+            };
+        };
+        conf_cn9131 {
+            description = "Boot Linux kernel with FDT blob + ramdisk for CN9131";
+            kernel = "kernel_1";
+            fdt = "fdt_cn9131";
+            ramdisk = "ramdisk_1";
             hash@1 {
                 algo = "sha1";
             };
-- 
2.25.1

