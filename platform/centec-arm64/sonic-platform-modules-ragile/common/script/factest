#!/usr/bin/python
# -*- coding: UTF-8 -*-
import os
import sys
import signal
import time
import threading
import xml.etree.ElementTree as ET
import hashlib
import re
import datetime
import syslog
import fcntl
import logging
import subprocess
import json
import unicodedata
import tty
import glob
import mmap
from tabulate import tabulate
import traceback
from faclib.all import *

MAILBOX_DIR = "/sys/bus/i2c/devices/"  # sysfs Top-level directory
PORTS_DIR = "/sys/class/net/"
from scapy.all import sendp, Ether, ARP
# from monitor import status
import ConfigParser

GRTD_BROADCAST_RETRY_SLEEP_TIME  = 3
'''
from ragileutil import *
import grtd_test as gt
from tabulate import tabulate
from faclib.rest import HttpRest

fan_check           = gt.fan_check
get_sysfs_value     = gt.get_sysfs_value
test_port           = gt.test_port
test_port_prbs      = gt.test_port_prbs
test_port_portframe = gt.test_port_portframe
stopFanctrol        = gt.stopFanctrol
startFanctrol       = gt.startFanctrol
test_ports_prbs_new = gt.test_ports_prbs_new
'''
def upper_input(tips):
    sys.stdout.write(tips)
    sys.stdout.flush()
    passwd = []
    while True:
        ch = getrawch().upper()
        if ch == "\r" or ch == "\n":
          print
          tmp =  "".join(passwd)
          ret_t = tmp.strip().strip(b'\x00'.decode())
          return str(ret_t)
        elif ch == '\b' or ord(ch) == 127:
            if passwd:
                del passwd[-1]
                sys.stdout.write('\b \b')
        else:
          sys.stdout.write(ch)
          passwd.append(ch)

def getrawch():
  fd = sys.stdin.fileno()
  old_settings = termios.tcgetattr(fd)
  try:
    tty.setraw(sys.stdin.fileno())
    ch = sys.stdin.read(1)
  finally:
    termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)
  return ch

TLV_INFO_ID_STRING = "TlvInfo\x00"
TLV_INFO_VERSION = 0x01
TLV_INFO_LENGTH = 0x00
TLV_INFO_LENGTH_VALUE = 0xba


def getTLV_BODY(type, productname):
    x = []
    temp_t = ""
    if type == TLV_CODE_MAC_BASE:
        arr = productname.split(':')
        for tt in arr:
            temp_t += chr(int(tt, 16))
    elif type == TLV_CODE_DEVICE_VERSION:
        temp_t = chr(productname)
    elif type == TLV_CODE_MAC_SIZE:
        temp_t = chr(productname >> 8) + chr(productname & 0x00ff)
    else:
        temp_t = productname
    x.append(chr(type))
    x.append(chr(len(temp_t)))
    for i in temp_t:
        x.append(i)
    return x

def _crc32(v):
    return '0x%08x' % (binascii.crc32(v) & 0xffffffff)  # Take the octet data %x of CRC32 to return hexadecimal


def util_setmac(eth, mac):
    rulefile = "/etc/udev/rules.d/70-persistent-net.rules"
    if isValidMac(mac) == False:
        return False, "MAC非法"
    cmd = "ethtool -e %s | grep 0x0010 | awk '{print \"0x\"$13$12$15$14}'" % eth
    ret, log = rj_os_system(cmd)
    log_debug(log)
    magic = ""
    if ret == 0 and len(log):
        magic = log
    macs = mac.upper().split(":")

    # Temporarily change the local ETH0 to the value after setMAC
    ifconfigcmd = "ifconfig %s hw ether %s" % (eth,mac)
    log_debug(ifconfigcmd)
    ret, status = rj_os_system(ifconfigcmd)
    if ret:
        raise SETMACException("软件设置网卡MAC出错")
    if ret:
        return False
    index = 0
    for item in macs:
        cmd = "ethtool -E %s magic %s offset %d value 0x%s" % (
            eth, magic, index, item)
        log_debug(cmd)
        index += 1
        ret, log = rj_os_system(cmd)
        if ret != 0:
            raise SETMACException("设置硬件网卡MAC出错")
            return False
    # Gets the return value of the setting
    cmd_t = "ethtool -e %s offset 0 length 6" % eth
    ret, log = rj_os_system(cmd_t)
    m = re.split(':', log)[-1].strip().upper()
    mac_result = m.upper().split(" ")

    for ind, s in enumerate(macs):
        if s != mac_result[ind]:
            RJPRINTERR("MAC比较出错")
    if os.path.exists(rulefile):
        os.remove(rulefile)  # Delete the file
    print ("MGMT MAC【%s】" % mac)
    return True

def test_bmc_i2c_open():
    switch_ctrol = TESTCASE.get("switchcontrol",None)
    if switch_ctrol is None:
        return True, ""
    if switch_ctrol.get('needopen') != 0:
        test_stop_fanctrol()
        time.sleep(1)
        for item in switch_ctrol.get('switchctrl',[]):
            if item.get('gettype') == 'io':
                addr = item.get('io_addr')
                val = item.get('switchbmc')
                io_wr(addr, val)
            else:
            # maybe i2c
                pass
    return True,""

def test_bmc_i2c_close():
    switch_ctrol = TESTCASE.get("switchcontrol",None)
    if switch_ctrol is None:
        return True, ""
    if switch_ctrol.get('needopen') != 0:
        for item in switch_ctrol.get('switchctrl',[]):
            if item.get('gettype') == 'io':
                addr = item.get('io_addr')
                val = item.get('switchcpu')
                io_wr(addr, val)
            else:
                # maybe i2c
                pass
    test_start_fanctrol()
    return True,""

def writeToBMCEEprom(rst_arr, loc, ep_param):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    params = {}
    try:
        params["value"] = []
        params["loc"] = loc
        params.update(ep_param)
        for item in rst_arr: # Item is a character, converted to ASCII
            params["value"].append(ord(item))
        func = "test_bmc_write_eeprom"
        RET = test_bmc_func(func,params)
        if RET[RETURN_KEY1] < 0:
            return RET
    except Exception as e:
        RET[RETURN_KEY2] = str(e)
        RET[RETURN_KEY1] = -1
    return RET

def sync_bmc_tlv_e2(rst_arr):
    tmp = TESTCASE.get('bmctlve2sync')
    if tmp.__contains__("BMC_access") and tmp.get("BMC_access") == 1: # If BMC_access is 1, the E2 synchronization is performed on the BMC
        loc = tmp.get('BMC_E2_LOC')
        ep_param = tmp.get('BMC_E2_PROTECT')
        writeToBMCEEprom(rst_arr, loc, ep_param)
        return
    e2_protect = tmp.get('BMC_E2_PROTECT',None)
    if e2_protect is not None:
        dealtype = e2_protect.get('gettype', None)
        if dealtype is None:
            rji2cset(e2_protect["bus"], e2_protect["devno"],
                     e2_protect["addr"], e2_protect["open"])
        elif dealtype == "io":
            io_wr(e2_protect["io_addr"], e2_protect["open"])
    index = 0
    e2_loc = tmp.get('BMC_E2_LOC',None)
    for item in rst_arr:
        rji2cset(e2_loc["bus"], e2_loc["devno"], index, ord(item))
        index += 1

    if e2_protect is not None:
        if dealtype is None:
            rji2cset(e2_protect["bus"], e2_protect["devno"],
                     e2_protect["addr"], e2_protect["close"])
        elif dealtype == "io":
            io_wr(e2_protect["io_addr"], e2_protect["close"])

def writeToEEprom(rst_arr):
    dealtype = E2_PROTECT.get('gettype',None)
    if dealtype is None:
        rji2cset(E2_PROTECT["bus"], E2_PROTECT["devno"],
                 E2_PROTECT["addr"], E2_PROTECT["open"])
    elif dealtype == "io":
        io_wr(E2_PROTECT["io_addr"], E2_PROTECT["open"])
    index = 0
    for item in rst_arr:
        rji2cset(E2_LOC["bus"], E2_LOC["devno"], index, ord(item))
        index += 1
    if TESTCASE.__contains__('bmctlve2sync'):
        sync_bmc_tlv_e2(rst_arr)
        func = 'bmc_log_os_system'
        cmd = "systemctl restart read-uboot-mac.service"  # Modify the BMC eth0 MAC
        ret = test_bmc_func(func, cmd)
        if ret[RETURN_KEY1] != 0:
            RJPRINT("set BMC eth0 fail")
    if dealtype is None:
        rji2cset(E2_PROTECT["bus"], E2_PROTECT["devno"],
                 E2_PROTECT["addr"], E2_PROTECT["close"])
    elif dealtype == "io":
        io_wr(E2_PROTECT["io_addr"], E2_PROTECT["close"])
    # Finally, the system driver is dealt with
    os.system("rmmod at24 ")
    os.system("modprobe at24 ")
    os.system("rm -f /var/cache/sonic/decode-syseeprom/syseeprom_cache")


def changeTypeValue(_value, type1, tips, example):
    if type1 == TLV_CODE_PRODUCT_NAME:
        while True:
            print ("请确认 (1)前后进风/(2)后前进风:",)
            option = raw_input()
            if option == "1":
                _value[type1] = example + "-F-RJ"
                print ("确认该产品为前后进风设备,产品名称:%s"%_value[type1])
                break
            elif option == "2":
                _value[type1] = example + "-R-RJ"
                print ("确认该产品为后前进风设备,产品名称:%s"%_value[type1])
                break
            else:
                print ("输入错误,请认真核对")
        return True
    print ("请输入【%s】如(%s):" % (tips, example),)
    name = upper_input("")
    if type1 == TLV_CODE_MAC_BASE:
        if len(name) != 12:
            raise SETMACException("MAC地址长度不对(12位),请认真核对")
            return False
        release_mac = ""
        for i in range(len(name) / 2):
            if i == 0:
                release_mac += name[i * 2:i * 2 + 2]
            else:
                release_mac += ":" + name[i * 2:i * 2 + 2]
        if isValidMac(release_mac) == True:
            _value[type1] = release_mac
        else:
            raise SETMACException("MAC地址非法,请认真核对")
            return False
    elif type1 == TLV_CODE_DEVICE_VERSION:
        if not name.isdigit():
            raise SETMACException("版本号非数字,请认真核对")
        elif int(name) > 255:
            raise SETMACException("版本号超出范围(0-255),请认真核对")
        else:
            _value[type1] = int(name)
    elif type1 == TLV_CODE_MAC_SIZE:
        if name.isdigit():
            _value[type1] = int(name, 16)
        else:
            raise SETMACException("版本号非数字,请认真核对")
    elif type1 == TLV_CODE_SERIAL_NUMBER:
        if name.isalnum() == False:
            raise SETMACException("序列号非法字符串,请认真核对")
        elif len(name) != 13:
            raise SETMACException("序列号长度不对(13位),请认真核对")
        else:
            _value[type1] = name
    elif type1 == TLV_CODE_VENDOR_EXT:
        _value[type1] = name
    else:
        _value[type1] = name
    return True



class SETMACException(Exception):
    def __init__(self, param='错误', errno="-1"):
        err = "setmac出错[%s]: %s" % (errno, param)
        Exception.__init__(self, err)
        self.param = param
        self.errno = errno
def getPid(name):
    ret = []
    for dirname in os.listdir('/proc'):
        if dirname == 'curproc':
            continue
        try:
            with open('/proc/{}/cmdline'.format(dirname), mode='rb') as fd:
                content = fd.read()
        except Exception:
            continue
        if name in content:
            ret.append(dirname)
    return ret

def getsysmeminfo_detail():
    ret, log = rj_os_system("which dmidecode ")
    if ret != 0 or len(log) <= 0:
        error = "cmd find dmidecode"
        return False, error
    cmd = log + " -t 17 | grep  -A21 \"Memory Device\""  # 17
    # 先获取总数
    ret1, log1 = rj_os_system(cmd)
    if ret != 0 or len(log1) <= 0:
        return False, "命令执行出错[%s]" % cmd
    result_t = log1.split("--")
    mem_rets = []
    for item in result_t:
        its = item.replace("\t", "").strip().split("\n")
        ret = {}
        for it in its:
            if ":" in it:
                key = it.split(":")[0].lstrip()
                value = it.split(":")[1].lstrip()
                ret[key] = value
        mem_rets.append(ret)
    return True, mem_rets

def getsysbios():
    return getDmiSysByType(0)

def getDmiSysByType(type_t):
    ret, log = rj_os_system("which dmidecode ")
    if ret != 0 or len(log) <= 0:
        error = "cmd find dmidecode"
        return False, error
    cmd = log + " -t %s" % type_t
    # Get the total first
    ret1, log1 = rj_os_system(cmd)
    if ret != 0 or len(log1) <= 0:
        return False, "命令执行出错[%s]" % cmd
    its = log1.replace("\t", "").strip().split("\n")
    ret = {}
    for it in its:
        if ":" in it:
            key = it.split(":")[0].strip()
            value = it.split(":")[1].strip()
            ret[key] = value
    return True, ret



def gethwsys():
    return getDmiSysByType(1)

TLV_CODE_PRODUCT_NAME = 0x21
TLV_CODE_PART_NUMBER = 0x22
TLV_CODE_SERIAL_NUMBER = 0x23
TLV_CODE_MAC_BASE = 0x24
TLV_CODE_MANUF_DATE = 0x25
TLV_CODE_DEVICE_VERSION = 0x26
TLV_CODE_LABEL_REVISION = 0x27
TLV_CODE_PLATFORM_NAME = 0x28
TLV_CODE_ONIE_VERSION = 0x29
TLV_CODE_MAC_SIZE = 0x2A
TLV_CODE_MANUF_NAME = 0x2B
TLV_CODE_MANUF_COUNTRY = 0x2C
TLV_CODE_VENDOR_NAME = 0x2D
TLV_CODE_DIAG_VERSION = 0x2E
TLV_CODE_SERVICE_TAG = 0x2F
TLV_CODE_VENDOR_EXT = 0xFD
TLV_CODE_CRC_32 = 0xFE
_TLV_DISPLAY_VENDOR_EXT = 1
TLV_CODE_RJ_CARID = 0x01
_TLV_INFO_HDR_LEN = 11



def decoder(s, t):
    if ord(t[0]) == TLV_CODE_PRODUCT_NAME:
        name = "Product Name"
        value = str(t[2:2 + ord(t[1])])
    elif ord(t[0]) == TLV_CODE_PART_NUMBER:
        name = "Part Number"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_SERIAL_NUMBER:
        name = "Serial Number"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_MAC_BASE:
        name = "Base MAC Address"
        value = ":".join([binascii.b2a_hex(T) for T in t[2:8]]).upper()
    elif ord(t[0]) == TLV_CODE_MANUF_DATE:
        name = "Manufacture Date"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_DEVICE_VERSION:
        name = "Device Version"
        value = str(ord(t[2]))
    elif ord(t[0]) == TLV_CODE_LABEL_REVISION:
        name = "Label Revision"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_PLATFORM_NAME:
        name = "Platform Name"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_ONIE_VERSION:
        name = "ONIE Version"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_MAC_SIZE:
        name = "MAC Addresses"
        value = str((ord(t[2]) << 8) | ord(t[3]))
    elif ord(t[0]) == TLV_CODE_MANUF_NAME:
        name = "Manufacturer"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_MANUF_COUNTRY:
        name = "Manufacture Country"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_VENDOR_NAME:
        name = "Vendor Name"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_DIAG_VERSION:
        name = "Diag Version"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_SERVICE_TAG:
        name = "Service Tag"
        value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_VENDOR_EXT:
        name = "Vendor Extension"
        value = ""
        if _TLV_DISPLAY_VENDOR_EXT:
            value = t[2:2 + ord(t[1])]
    elif ord(t[0]) == TLV_CODE_CRC_32 and len(t) == 6:
        name = "CRC-32"
        value = "0x%08X" % (((ord(t[2]) << 24) | (
            ord(t[3]) << 16) | (ord(t[4]) << 8) | ord(t[5])),)
    elif ord(t[0]) == TLV_CODE_RJ_CARID:
        name = "rj_cardid"
        value = ""
        for c in t[2:2 + ord(t[1])]:
            value += "%02X" % (ord(c),)
    else:
        name = "Unknown"
        value = ""
        for c in t[2:2 + ord(t[1])]:
            value += "0x%02X " % (ord(c),)
    return {"name": name, "code": ord(t[0]), "value": value}


def wide_chars(s):
    if isinstance(s, str):
        s = s.decode('utf-8')
    return sum(unicodedata.east_asian_width(x) in ('F', 'W') for x in s)

grtdlog_dir= "/var/grtd"
grtdlog_name = grtdlog_dir +"/grtdtest.log"
kjlogmaxshow = 10


def get_pmc_register(reg_name):
    retval = 'ERR'
    if reg_name[0:4] == "/rif" or reg_name[0:4] == "/ma1" or reg_name[0:4] == "/eth":
        mb_reg_file = PORTS_DIR + reg_name
    else:
        mb_reg_file = MAILBOX_DIR + reg_name
    if (not os.path.isfile(mb_reg_file)):
        print (mb_reg_file,  'not found !')
        return retval
    try:
        if (not os.path.isfile(mb_reg_file)):
            print (mb_reg_file,  'not found !')
            return retval
        with open(mb_reg_file, 'r') as fd:
            retval = fd.read()
    except Exception as error:
        log_error("Unable to open " + mb_reg_file + "file !")
    retval = retval.rstrip('\r\n')
    retval = retval.lstrip(" ")
    # log_debug(retval)
    return retval


def get_sysfs_value(location):
    pos_t = str(location)
    name = get_pmc_register(pos_t)
    return name

def rj_os_system(cmd):
    status, output = subprocess.getstatusoutput(cmd)
    return status, output


def get_cpu_info():
    cmd = "cat /proc/cpuinfo |grep processor -A18"  # 17

    ret, log1 = rj_os_system(cmd)
    if ret != 0 or len(log1) <= 0:
        return False, "命令执行出错[%s]" % cmd
    result_t = log1.split("--")
    mem_rets = []
    for item in result_t:
        its = item.replace("\t", "").strip().split("\n")
        ret = {}
        for it in its:
            if ":" in it:
                key = it.split(":")[0].lstrip()
                value = it.split(":")[1].lstrip()
                ret[key] = value
        mem_rets.append(ret)
    return True, mem_rets


def getch(msg):
    ret = ""
    fd = sys.stdin.fileno()
    old_ttyinfo = termios.tcgetattr(fd)
    new_ttyinfo = old_ttyinfo[:]
    new_ttyinfo[3] &= ~termios.ICANON
    new_ttyinfo[3] &= ~termios.ECHO
    sys.stdout.write(msg)
    sys.stdout.flush()
    try:
        termios.tcsetattr(fd, termios.TCSANOW, new_ttyinfo)
        ret = os.read(fd, 1)
    finally:
        # print "try to setting"
        termios.tcsetattr(fd, termios.TCSANOW, old_ttyinfo)
    return ret

def root_check():
    if os.geteuid() != 0:
        click.echo("请在Root权限下执行！")
        sys.exit(1)

if not os.path.exists(grtdlog_dir):
    os.makedirs(grtdlog_dir)

SYSLOG_IDENTIFIER = "FACTEST"

g_info_tmp = ""
def print_temp(str,cache = True):
    if cache:
        global g_info_tmp
        g_info_tmp += str+"\n"
    else:
        print (str)

def print_temp_flush():
    global g_info_tmp
    if g_info_tmp != "":
       print (g_info_tmp)
    g_info_tmp = ""

def print_clean():
    global g_info_tmp
    g_info_tmp = ""


def log_info(msg, also_print_to_console=False):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_INFO, msg)
    syslog.closelog()
    if also_print_to_console:
        click.echo(msg)


def log_debug(msg, also_print_to_console=False):
    try:
        syslog.openlog(SYSLOG_IDENTIFIER)
        syslog.syslog(syslog.LOG_DEBUG, msg)
        syslog.closelog()

        if also_print_to_console:
            click.echo(msg)
    except Exception as e:
        pass


def log_warning(msg, also_print_to_console=False):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_WARNING, msg)
    syslog.closelog()

    if also_print_to_console:
        click.echo(msg)


def log_error(msg, also_print_to_console=False):
    syslog.openlog(SYSLOG_IDENTIFIER)
    syslog.syslog(syslog.LOG_ERR, msg)
    syslog.closelog()

    if also_print_to_console:
        click.echo(msg)

LOGERROR = False
DEBUG = False
KAOJILOGPATH = "/var/grtd/"
KAOJILOGFILE = KAOJILOGPATH + "kjlog.log"
KAOJISTATUS = 1
ISKAOJI = 0
# CONFIG_NAME = "apptest.xml"
RTC_WAIT_TIME                   = 3
RTC_THRESHOLD_LOWER             = 3
RTC_THRESHOLD_UPPER             = 4
SUCCESS_TIPS                    = "PASS"

RETURN_KEY1       = "code"
RETURN_KEY2       = "msg"
ERROR_RETURN      = {RETURN_KEY1 : -1, RETURN_KEY2 : "init error"}
SUCCESS_RETURN    = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
ERROR_RETURN_DETAIL  = {RETURN_KEY1 : -1, RETURN_KEY2 : []}

kj_result =[]
MENUID     = "menuid"
MENUPARENT = "parentid"
MENUVALUE  =  "value"
CHILDID    = "childid"
MENUITEMNAME = "name"
MENUITEMDEAL = "deal"
GOBACK  = "goBack"
GOQUIT  = "quit"
ITEMBEFORE = 'before'
ITEMAFTER = 'after'

listindex=['1','2','3','4','5','6','7','8','9','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
formatStringLevel1 = "%s.%s"
SYSINFOTIPS_FORMAT = "%30s : %s"
nosetrtc = 1

DIAGTEST = False
SAVE_STDOUT = None
INSP_RESULT = ""

def keep_message(RET, x, newline = True):
    if newline == True:
        RET[RETURN_KEY2] += (str)(x) + "\n"
    else:
        RET[RETURN_KEY2] += (str)(x)

def RJPRINTLINE(x):
    '''Keep the function and adapt later 3.x'''
    print (x,)

def RJPRINT(x,newline = True):
    '''Keep the function and adapt later 3.x'''
    if newline == True:
        print (x)
    else:
        print (x,)

def force_abort_cpu_stress():
    log_os_system("ps -ef | grep \"stress -c 4\" | grep -v grep | awk '{print $2}' | xargs kill -9 ", 0)

def quit():
    force_abort_cpu_stress()
    force_abort_ddr_stress()
    sys.exit(0)

def test_sys_halt():
    log_os_system("sync", 0)
    log_os_system("halt -f", 0)

def test_sys_reload():
    log_os_system("sync", 0)
    log_os_system("reboot -f", 0)

def getInputValue(title, tips):
    print ("请输入【%s】如(%s):" % (title, tips),)
    name = raw_input()
    return name

# Backport Python 3.4's regular expression "fullmatch()" to Python 2
def fullmatch(regex, string, flags=0):
    """Emulate python-3.4 re.fullmatch()."""
    return re.match("(?:" + regex + r")\Z", string, flags=flags)

def test_set_rtc():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    time = getInputValue("RTC时间","20180816 11:43:22")
    ret = fullmatch("[0-9]{8} [0-9]{2}:[0-9]{2}:[0-9]{2}", time)
    if ret:
        cmd = "date -s '%s' &&hwclock --systohc" % time
        ret, log = rj_os_system(cmd)
    else:
        RET[RETURN_KEY1] = -1
        RJPRINT("输入错误")
        return RET
    if ret != 0:
        RJPRINTERR("\n\n!!!.设置RTC时间失败\n\n")
        return {RETURN_KEY1 : -1, RETURN_KEY2 : []}
    systimecmd = "date -R"
    ret , log = rj_os_system(systimecmd)
    RJPRINT("当前时间: %s" % log)
    return RET

# Menu Prints a menu item with a numeric prompt in front
def printList(_list, id):
    try:
        RJPRINT("****************************************")
        for index in range(len(_list)):
            RJPRINT(formatStringLevel1 %( listindex[index] , _list[index]["name"]))
        if id != STARTMENUID:
            RJPRINT("q.返回上一层")
        else:
            RJPRINT("q.退出")
        RJPRINT("****************************************")
    except Exception as e:
        log_error(str(e))
        sys.exit(-1)

def test_kr():
    RET = {RETURN_KEY1 : -1,  RETURN_KEY2 : ""}
    packetcount = 10000
    RJPRINT("packets %d" % packetcount)

    returnstr = ''
    ind = False

    for i in range(0 , 3):
        returnstr = ''
        try:
            pk = PortKrTest()
            error = 0
            errmsg = ""
            for i in [1,2]:
                eth = "eth%d"%i
                xe_port = pk.get_mgmt_bcmport(eth)
                cmd = "bcmcmd \"port %s en=1\"" % xe_port
                ret, output = rj_os_system(cmd)
                if(ret != 0):
                    log_debug("cmd %s fail, output %s" % (cmd, output))
                pk.clear_port_packets()
                time.sleep(1)
                ret, result = pk.start_send_port_packets(eth, count=packetcount, vlan = 2000)
                time.sleep(4)
                ret, log = pk.check_port_packets(eth, count=packetcount)
                if ret:
                    returnstr += "%s : PASS \n" % eth
                else:
                    error -= 1
                    returnstr += "%s : FAILED  reason[%s] \n" % (eth, str(log))
            for i in [1,2]:
                eth = "eth%d"%i
                xe_port = pk.get_mgmt_bcmport(eth)
                cmd = "bcmcmd \"port %s en=0\"" % xe_port
                ret, output = rj_os_system(cmd)
                if(ret != 0):
                    log_debug("cmd %s fail, output %s" % (cmd, output))
            if error < 0:
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = returnstr
                continue
            else:
                RET[RETURN_KEY1] = 0
                RET[RETURN_KEY2] = returnstr
                break
        except Exception as e:
            RET[RETURN_KEY1] = -999
            RET[RETURN_KEY2] = returnstr
    RJPRINT(RET[RETURN_KEY2])
    return  RET

def test_all_tmp(test_items):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    global INSP_RESULT
    totalerr = 0
    sum_pass_info_tmp = ""
    sum_fail_info_tmp = ""
    sum_fail_cont = 0
    sum_pass_cont = 0
    time1 = time.time();
    timeArraystart  = time.localtime(time1)
    test_start_time = time.strftime("%Y-%m-%d %H:%M:%S", timeArraystart)

    for item in test_items:
        RJPRINT("")
        RJPRINT("=" * 12 + item[MENUITEMNAME] + "=" *12)
        RET = dealchoosefunc(item)
        RJPRINT("\n")
        formatstr = "======%%-%ds ======:%%-10s\n"%((40+wide_chars(item["name"])))
        if RET[RETURN_KEY1] == 0:
            RJPRINT("[%s]测试结果:" % item[MENUITEMNAME] + 'Pass')
            log_debug("[%s]测试结果:" % item[MENUITEMNAME] + SUCCESS_TIPS)
            sum_pass_cont += 1
            sum_pass_info_tmp += formatstr%(item["name"], "PASS")
        elif RET[RETURN_KEY1] == 1:
            pass
        else:
            totalerr -= 1
            RJPRINT("[%s]测试结果:" % item[MENUITEMNAME] + 'Fail')
            log_debug("[%s]测试结果:" % item[MENUITEMNAME] + 'error')
            sum_fail_cont += 1
            sum_fail_info_tmp += formatstr%(item["name"], "FAIL")

    time2 = time.time();
    timeArraystart  = time.localtime(time2)
    test_end_time = time.strftime("%Y-%m-%d %H:%M:%S", timeArraystart)

    RJPRINT("\n汇总：")
    RJPRINT(sum_pass_info_tmp)
    RJPRINT(sum_fail_info_tmp)
    RJPRINT("测试开始时间：%s"% test_start_time)
    RJPRINT("测试结束时间：%s"% test_end_time)
    RJPRINT("总共测试项数：%d"%(sum_pass_cont+sum_fail_cont))
    RJPRINT("PASS测试项数：%d"%sum_pass_cont)
    RJPRINT("FAIL测试项数：%d"%sum_fail_cont)
    sn = getsyseeprombyId(TLV_CODE_SERIAL_NUMBER).get('value')
    RJPRINTLINE(" 产品序列号 : %s," % sn)
    if (sum_fail_cont > 0):
        RJPRINT("Test Result: Fail")
        INSP_RESULT = "FAIL"
    else:
        RJPRINT("Test Result: Pass")
        INSP_RESULT = "PASS"
    return {RETURN_KEY1 : 1,  RETURN_KEY2 : ""}


def test_all():
    return test_all_tmp(alltest)

def test_diag_all():
    return test_all_tmp(diagtestall)

def test_insp_led_ctl(led_list):
    for item in led_list:
        bus = item["bus"]
        loc = item["loc"]
        reg = item["reg"]
        val = item["val"]
        rji2cset(bus,loc,reg,val)

class Logger(object):
    def __init__(self, fileN="/tmp/out.log"):
        self.terminal = sys.stdout
        self.log = open(fileN, "w")
 
    def write(self, message):
        self.terminal.write(message)
        self.log.write(message)
 
    def flush(self):
        pass

    def close(self):
        self.log.close()



def test_stdout_redirect():
    global SAVE_STDOUT
    SAVE_STDOUT = sys.stdout    # Save the standard output stream
    sys.stdout = Logger()  # Output redirection

def test_stdout_resume():
    global SAVE_STDOUT
    if SAVE_STDOUT is not None:
        sys.stdout.close()
        sys.stdout = SAVE_STDOUT
        SAVE_STDOUT = None
    

def test_save_insp_result(dst,src = '/tmp/out.log'):
    '''Saving inspection Results'''
    global INSP_RESULT
    if not os.path.exists(src):
        return False
    time1 = time.time();
    timeArraystart  = time.localtime(time1)
    test_start_time = time.strftime("%Y-%m-%d-%H-%M-%S", timeArraystart)
    sn = getsyseeprombyId(TLV_CODE_SERIAL_NUMBER).get('value')
    file_name = "%s_%s_%s.log" % (test_start_time,sn,INSP_RESULT)
    if not os.path.exists(dst):
        os.makedirs(dst)
    cmd = "mv %s %s/%s" % (src,dst,file_name)
    status, output = rj_os_system(cmd)
    if status:
        return False
    return True

def test_inspection_pre():
    '''Pre-inspection process'''
    # Test path inspection
    ret, msg = test_bmc_channel()
    if ret == False:
        return ret, msg
    inspection_conf = TESTCASE.get("inspection_config",None)
    if inspection_conf is None:
        return True, ''
    # Mount a USB flash drive Save the inspection result to the USB flash drive
    if inspection_conf.get("mount_usb",0) == 1:
        pass        
    led_init_list = inspection_conf.get("led_init",[])
    test_insp_led_ctl(led_init_list)
    test_stdout_redirect()   # Output is directed to the console and files
    return True, ''

def test_inspection_after():
    '''Inspection after the process'''
    global INSP_RESULT
    inspection_conf = TESTCASE.get("inspection_config",None)
    if inspection_conf is None:
        return True
    # Restore standard output
    test_stdout_resume()
    # Saving inspection Results
    dst_path = inspection_conf.get("log_path")
    test_save_insp_result(dst_path)
    # The USB flash drive needs to be uninstalled
    if inspection_conf.get("mount_usb",0) == 1:
        pass
    # lamps tip
    if INSP_RESULT == "PASS":   # inspection OK
        func = inspection_conf.get("bmc_led_ctl",None)
        if func is not None:    # BMC side light
            url_path = getRealUrl(func)
            cmd = "curl -m 3 %s" % url_path
            rj_os_system(cmd)
        else:
            pass
        if inspection_conf.get('halt_flag',0) == 1:    # To turn it off
            stopFanctrol()
            fac_sensors_kill()
            test_sys_halt()
        return True
    led_alarm = inspection_conf.get("led_alarm",[]) # inspection fails, and an alarm is generated when the indicator is on
    test_insp_led_ctl(led_alarm)
    return True
    

def test_kr_pre():
    return True,""

def test_kr_after():
    return True,""

# Menu: Single test
def test_signal(id):
    startMenu(id)

def dealfunc(func):
    msg = ""
    for i in range(0, 3):
        ret, msg = func()
        if ret == True:
            return True
        else:
           continue
    raise Exception(msg)
    return False


def dealchoosefunc(list):
    '''Real menu processing items'''
    RET = ERROR_RETURN
    funcbefore = None
    functest  = None
    funcafter = None
    param_tt = None
    param_val = None
    funcbeforestr = list.get(ITEMBEFORE, None)
    functeststr = list.get(MENUITEMDEAL, None)
    funcafterstr = list.get(ITEMAFTER, None)
    param_tt = list.get(CHILDID, None)
    param_val = list.get('param', None)

    if funcbeforestr is not None:
        funcbefore = eval(funcbeforestr)
    if functeststr is not None:
        functest = eval(functeststr)
    if funcafterstr is not None:
        funcafter = eval(funcafterstr)
    try:
        if funcbefore is not None:
            log_debug("    测试项前置:%s " % (funcbefore))
            dealfunc(funcbefore)
        if functest is not None:
            log_debug("    测试项    :%s " % (functest))
            if param_tt is not None:
                RET = functest(param_tt)
            else:
                if param_val is not None:
                    RET = functest(param_val)
                else:
                    RET = functest()
        else:
            raise Exception("fun test is none")
    except Exception as e:
        msg = traceback.format_exc()
        log_error(msg)
        RJPRINT(msg)
        RJPRINT("error\n\n")
    finally:
        if funcafter is not None:
            log_debug("    测试项后置:%s " % (funcafter))
            for i in range(0, 3):
                ret, _ = funcafter()
                if ret == True:
                    break
                elif i == 2:
                    log_debug("    测试项后置:%s run fail 3 times" % (funcafter))
    return RET


# Menu to print
# printMenu
# param: list_t  Menu item list
# id      Menu id

def printMenu(list_t, id):
    global nosetrtc
    while True:
        try:
            printList(list_t, id)
            test = "请选择:"
            str= getch(test)
            RJPRINT(" %s" % str)
            log_debug("选择:%s" % str)
            str = str.lstrip().lower()
            if str == "q":
                if id == STARTMENUID:  # Top level directory. There's no way back
                    log_debug("wait subprocess exit")
                    subprocess_case.shutdown_bgtest()
                    quit()
                else:
                    break
            if str not in listindex:
                log_debug("%s 不在菜单项中" % str);
                RJPRINT("\n\n")
                continue
            else:
                RJPRINT("=======================> %s <======================="%list_t[listindex.index(str)][MENUITEMNAME])
                log_debug("选择的测试项为:%s id:%d" % (list_t[listindex.index(str)][MENUITEMNAME], id))

                if list_t[listindex.index(str)].get('lock', False) and (subprocess_case.is_running()
                    or subprocess_case.is_stopping()):# Some test items cannot be entered during background execution
                    RJPRINT("后台测试中 %s 不可执行" % list_t[listindex.index(str)][MENUITEMNAME]);
                    RJPRINT("\n\n")
                    continue
                RET = dealchoosefunc(list_t[listindex.index(str)])
                if RET == None:
                    RJPRINT("\n\n")
                    continue
                RJPRINT(" ")
                if RET[RETURN_KEY1] == 0:
                    RJPRINT("Test Result: Pass")
                    log_debug("菜单测试结果:" + SUCCESS_TIPS)
                elif RET[RETURN_KEY1] == 1:
                    pass
                else:
                    RJPRINT("Test Result: Fail")
                    log_debug("[%s]测试结果:" % list_t[listindex.index(str)][MENUITEMNAME] + 'error')
                RJPRINT("\n\n")
        except IndexError as d:
            RJPRINT("\n\n非法输入\n\n")
        except Exception as e:
            RJPRINT(e)
            RJPRINTERR("\n\n 异常\n\n" )

def getMenuFromList(list, id):
    for key in list:
        if key[MENUID] == id:
            return key[MENUVALUE],True
    return 0, False

def getParentIdMenuFromList(list, id):
    for key in list:
        if key[MENUID] == id:
            return key[MENUPARENT],True
    return -1, False

def getDriverFromGlobal(name):
    for key in testdriver:
        if key["name"] == name:
            return key,True
    return "-1", False

def i2ccheckValue(ret1 , ret2, type):
    if type == 1 and ret1 == ret2:
        return True
    elif type == 2 and ret1 == "SUCCESS":
        return True
    else:
        return False

def test_i2c_scan(scan_list):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    errtotal = 0
    errmsg  = ""
    for i2cdev in scan_list:
        STATE = "FAILED"
        formatstr = "    %%-%ds %%-10s"%((40+wide_chars(i2cdev['name'])))
        ret, log = rji2cget(i2cdev["bus"], i2cdev["addr"], 0)
        if ret == False or "Error" in log:
            STATE = "FAILED"
            errtotal -= 1
            errmsg = "%s %s\n" % (errmsg,formatstr%(i2cdev['name'],log))
        else:
           STATE = "PASS"
        RJPRINT(formatstr%(i2cdev['name'],STATE))
    if errtotal < 0:
      RET[RETURN_KEY1] = errtotal
    RET[RETURN_KEY2] = errmsg
    return RET

def test_i2c_new():
    return test_i2c_scan(TESTCASE["I2CSCAN"])

def test_diag_i2c():
    return test_i2c_scan(TESTCASE["DIAGI2CSCAN"])


# Menu: Test I2C
def test_i2c():
    RET = {RETURN_KEY1 : -1, RETURN_KEY2 : []}
    result_key = 0
    for i2c in TESTCASE["I2C"]:
        testerror ={}
        RJPRINT("测试项[%s] " % i2c["name"])
        log_debug("测试项[%s] " %i2c["name"])
        testerror["name"] = i2c["name"]
        caseerror =[]
        if "cases" not in i2c:
            RJPRINT("没有测试项")
            log_debug("没有测试项")
            continue
        for case in i2c["cases"]:
            # Gets the command invoked
            cmd_t = case["cmd"].lstrip()
            cmd = cmd_t[0 : cmd_t.index(" ")]
            ret_t, log = log_os_system("which " + cmd, 0)
            if len(log):
                cmd = "cmd find "
            else:
                result_key -= 1
                caseerror.append({"name":case["name"] ,"error":"cmd not find"})
                continue
            ret_t, log = log_os_system(case["cmd"], 0)
            if ret_t or ("Error" in log ):
                status = "[FAILED]"
                result_key -= 1
                caseerror.append({"name":case["name"] ,"error":log})
                log_debug("case: %s   [%s]  %s" % (case["name"] , case["cmd"],"fail"))
            else:
                value = " "
                if "value" not in case:
                    value = " "
                else:
                    value = case["value"]
                if i2ccheckValue(log, value, case["deal_type"]):
                    status = "[ok]"
                    log_debug("case: %s   [%s]  %s" % (case["name"] , case["cmd"],"ok"))
                else:
                    status = "[FAILED]"
                    log_debug("case: %s   [%s]  %s" % (case["name"] , case["cmd"],"fail"))
                    result_key -= 1
                    caseerror.append({"name":case["name"] ,"error": log})
            formatstr = "    %%-%ds %%-10s"%((40+wide_chars(case["name"])))
            RJPRINT(formatstr%(case["name"],status))
            testerror['errmsg'] = caseerror
        RET[RETURN_KEY2].append(testerror)
    if result_key <= 0:
        RET[RETURN_KEY1] = result_key
    # log_debug(RET)
    return RET

# Compare strings regardless of size
def astrcmp(str1,str2):
    return str1.lower()==str2.lower()

def makesure(info, default = True ,echo = False):
    while True:
        print (info,)
        if echo:
            str = raw_input()
        else:
            str = get_raw_input()
        if astrcmp(str, ""):
            return default
        if astrcmp(str, "y") or astrcmp(str, "ye") or astrcmp(str, "yes"):
            return True
        elif astrcmp(str, "n") or astrcmp(str, "no"):
            return False
        else:
            RJPRINT("输入无效,请重新输入，")

# led check Input validation
def get_led_inputcheck():
    err = 0;
    str = raw_input("确认状态灯是否正确切换[Yes/no]：")
    if astrcmp(str, "y") or astrcmp(str, "ye") or astrcmp(str, "yes") or astrcmp(str, ""):
        return True
    else:
        return False

def test_mgmtled():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    lb_with_Plug = TESTCASE.get('mgmt').get('100M')
    resetphy  = TESTCASE.get('mgmt').get('clear')
    lenon = TESTCASE.get("mgmt",{}).get("ledon",None)
    ledoff = TESTCASE.get("mgmt",{}).get("ledoff",None)
    ind = 0
    try:
        ret = test_bmc_func(resetphy.get('case'), resetphy.get('param'))
        if ret is None:
            raise Exception('初始phy失败')
        ret = test_bmc_func(lb_with_Plug.get('case'), lb_with_Plug.get('param'))
        if ret is None:
            raise Exception('设置100回环失败')
        time.sleep(0.5)
        key = "(link灯：橙色)"
        if makesure("确认切换到%s（Yes/No):"%key ,echo = 1) == True:
            ret = test_bmc_func(resetphy.get('case'), resetphy.get('param'))
            time.sleep(0.5)
        else:
            ind = -1
        cmd = lenon.get("cmd",None)
        func = lenon.get("bmc_interface",None)
        ret = test_bmc_func(func,cmd)
        key = "(link灯：绿 、act灯：绿)"
        if makesure("确认切换到%s（Yes/No):"%key ,echo = 1) == True:
            ret = test_bmc_func(resetphy.get('case'), resetphy.get('param'))
            time.sleep(0.5)
        else:
            ind = -2
        key = "(link灯：灭 、act灯：灭)"
        cmd = ledoff.get("cmd",None)
        func = ledoff.get("bmc_interface",None)
        ret = test_bmc_func(func,cmd)
        if makesure("确认切换到%s（Yes/No):"%key ,echo = 1) == True:
            ret = test_bmc_func(resetphy.get('case'), resetphy.get('param'))
            time.sleep(0.5)
        else:
            ind = -3
    except Exception as e:
        ind = -999
        RET[RETURN_KEY2] = str(e)
        print (str(e))
    finally:
        ret = test_bmc_func(resetphy.get('case'), resetphy.get('param'))
        time.sleep(0.5)
    RET[RETURN_KEY1] = ind
    return RET


def test_led_new():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    led_param = TESTCASE["LED_NEWS"]
    total_err = 0
    rest_status = 0

    for item_keys in sorted(led_param.keys()):
        item_led = led_param.get(item_keys)
        try:
            ''' New logic to determine whether the front register needs to be closed before port lights '''
            led_control = item_led.get('LED_CONTROL', None)
            if led_control is not None:
                ind = led_control.get("open", 0)
                if ind == 1:
                    regs  = led_control.get("regs", [])
                    for item in regs:
                        rji2cset(item["bus"], item["devno"], item["addr"], item["open"])
                else:
                    pass
            else:
                pass

            attrs = item_led.get('attrs')
            device = item_led.get('device')
            RJPRINT(item_led.get('name'))

            for key, val in attrs.items():
                for item in device:
                    gettype = item.get("gettype",'i2c')
                    if gettype == 'i2c': # i2c
                        rji2cset(item.get('bus'),item.get('addr'),item.get('reg'), val)
                    elif gettype == 'io':
                        io_wr(item.get('io_addr'), val)
                    elif gettype == 'cmd':
                        cmd = item.get('cmd') % val
                        rj_os_system(cmd)
                    elif gettype == 'pcie':
                        pcibus = item.get('pcibus')
                        slot = item.get('slot')
                        bar = item.get('bar')
                        fn = item.get('fn')
                        offset = item.get('offset') 
                        rjpciwr(pcibus, slot, fn, bar, offset, val)
                    elif gettype == 'restful':
                        returncode, msg = test_bmc_channel()
                        if returncode == False:
                            total_err -= 1
                            rest_status = -1
                            RJPRINT(msg)
                            break
                        func = item.get('func')
                        param = item.get('param')
                        param['value'] = val
                        ret = test_bmc_func(func,param)
                if rest_status < 0:
                    rest_status = 0
                    break
                if makesure("确认切换到%s（Yes/No):"%key ,echo = 1) == True:
                    continue
                else:
                    total_err -=1
        except Exception as e:
                total_err = -999
                RET[RETURN_KEY2] = str(e)
        finally:
            ''' Add new logic to determine whether the front register needs to be closed after the port lights '''
            led_control = item_led.get('LED_CONTROL', None)
            if led_control is not None:
                ind = led_control.get("open", 0)
                if ind == 1:
                    regs  = led_control.get("regs", [])
                    for item in regs:
                        rji2cset(item["bus"], item["devno"], item["addr"], item["close"])
                else:
                    pass
            else:
                pass


    RET[RETURN_KEY1] = total_err
    # Take before and after
    return RET

# System light test
def test_led():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    try:
        stopFanctrol()
        for led in TESTCASE["LED"]:
            RJPRINT("测试项: %s" % led["name"])
            if "cases" not in led:
                RJPRINT("没有测试项")
                continue
            for case in led["cases"]:
                RJPRINT(case["name"])
                # Gets the command invoked
                if "cmd" in case.keys():
                    cmd_t = case["cmd"].lstrip()
                    cmd = cmd_t[0 : cmd_t.index(" ")]
                    ret, log = log_os_system("which " + cmd, 0)
                    if len(log):
                        cmd = "cmd find "
                    else:
                        RET[RETURN_KEY2] = "no " + cmd +" found"
                        log_debug(RET[RETURN_KEY2])
                        RJPRINT(RET[RETURN_KEY2])
                        RET[RETURN_KEY1] = -1
                        return RET
                    log_debug(case["cmd"])
                    ret, log = log_os_system(case["cmd"], 0)
                    if ret or ("Error" in log ):
                        RJPRINT("[ERROR]")
                        totalerr -= 1
                    else:
                        if get_led_inputcheck():
                           RJPRINT("[PASS]")
                        else:
                           RJPRINT("[FAIL]")
                           totalerr -= 1
                elif "deal_bmc_led" in case.keys():
                    returncode, msg = test_bmc_channel()
                    if returncode == False:
                        totalerr -= 1
                        RJPRINT(msg)
                        continue
                    func = case["deal_bmc_led"]
                    param = case["param"]
                    ret = test_bmc_func(func,param)
                    if ret[RETURN_KEY1] != 0:
                        RJPRINT("[ERROR]")
                        totalerr -= 1
                    else:
                        if get_led_inputcheck():
                           RJPRINT("[PASS]")
                        else:
                           RJPRINT("[FAIL]")
                           totalerr -= 1
    except Exception as e:
        RJPRINT(e)
        totalerr -= 1
    finally:
        startFanctrol()
    RET[RETURN_KEY1] = totalerr
    return RET


# Setting the Debug Level
def test_setdebug():
    global DEBUG
    DEBUG = not DEBUG
    if DEBUG == False:
        RJPRINT("调试开关关闭")
    else:
        RJPRINT("调试开关打开")
    return SUCCESS_RETURN

# Get the menu by ID
def startMenu(id):
    list,code = getMenuFromList(menuList, id)
    if code == False:
        log_error("错误的文件结构")
        RJPRINT("无此菜单，请确认")
        sys.exit(1)
    log_debug("根据ID获取到相应的菜单列表")
    printMenu(list, id)

def keyboardTest():
    while True:
        log_debug("123")

def startThread():
    thread = threading.Thread(target=keyboardTest)
    thread.setDaemon(True)
    thread.start()

def rji2cset(bus, devno, address, byte):
    command_line = "i2cset -f -y %d 0x%02x 0x%02x 0x%02x" % (
        bus, devno, address, byte)
    retrytime = 6
    ret_t = ""
    for i in range(retrytime):
        ret, ret_t = rj_os_system(command_line)
        if ret == 0:
            return True, ret_t
    return False, ret_t

def rjpcird(pcibus , slot , fn, bar,  offset):
    '''read pci register'''
    if offset % 4 != 0:
        return
    filename = "/sys/bus/pci/devices/0000:%02x:%02x.%x/resource%d" % (int(pcibus), int(slot), int(fn), int(bar))
    size = os.path.getsize(filename)
    with open(filename, "r+") as file:
        data = mmap.mmap(file.fileno(), size)
        result = data[offset: offset + 4]
        s = result[::-1]
        val = 0
        for i in range(0, len(s)):
            val = val << 8  | ord(s[i])
        data.close()
    return "0x%08x" % val

def inttostr(vl,len): # Convert int to string , 0x3030 = 00
    if type(vl) != int:
        raise Exception(" type error")
    index = 0
    ret_t = ""
    while index < len:
        ret = 0xff & (vl >> index * 8)
        ret_t += chr(ret)
        index += 1;
    return ret_t

def rjpciwr(pcibus , slot ,fn, bar, offset, data):
    '''write pci register'''
    ret = inttostr(data, 4)
    filename = "/sys/bus/pci/devices/0000:%02x:%02x.%x/resource%d" % (int(pcibus), int(slot), int(fn), int(bar))
    size = os.path.getsize(filename)
    with open(filename, "r+") as file:
        data = mmap.mmap(file.fileno(), size)
        data[offset: offset + 4] = ret
        data.close()

# start
def start():
    # menuid =  if vars().__contains__('STARTMENUID') else 0
    # print menuid
    # print STARTMENUID
    global STARTMENUID
    if STARTMENUID is None:
        STARTMENUID = 0
    startMenu(STARTMENUID)

def test_cpu_stress_show():
    ret, log = log_os_system("top -bi -n2 -d 0.2 | grep '%Cpu(s)' | tail -n1", 0)
    if ret:
        print ("获取CPU信息失败")
    else:
        value , times = re.subn("[\S\s]*,\s*([\.\d]+)\sid[\S\s]*","\g<1>", log)
        if times != 1:
            print (log)
            print ("获取CPU利用率失败")
        else:
            print ("当前cpu利用率为%.1f%%"%(100 - float(value)))
    return {RETURN_KEY1 : 1, RETURN_KEY2 : ""}

def process_cpu_stress_test(interval):
    # print("The time is {0}".format(time.ctime()))
    # Generate four processes, each of which computes the square root of a random number generated by rand () over and over again
    cmd = "stress -c 4"
    ret, log = log_os_system(cmd, 0)

cpu_stress_test = False
def test_cpu_stress():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : "已启动后台执行"}
    global cpu_stress_test
    if cpu_stress_test :
        RJPRINT(RET[RETURN_KEY2])
        return RET
    ret, log = log_os_system("which stress", 0)
    if len(log):
        p = multiprocessing.Process(target = process_cpu_stress_test, args = (3,))
        p.daemon = True
        p.start()
      # global cpu_stress_test
        cpu_stress_test = True
    else:
        RET[RETURN_KEY2] = "no stress cmd"
    RJPRINT(RET[RETURN_KEY2])
    return RET


# Obtaining Memory Information
def memory_stat():
    mem = {}
    f = open("/proc/meminfo")
    lines = f.readlines()
    f.close()
    for line in lines:
        if len(line) < 2: continue
        name = line.split(':')[0]
        var = line.split(':')[1].split()[0]
        mem[name] = long(var) * 1024.0
    mem['MemUsed'] = mem['MemTotal'] - mem['MemFree'] - mem['Buffers'] - mem['Cached']
    return mem

def get_sdk_version():
    cmdstr = "bcmcmd 'version' < /dev/null | grep Release"
    ret, log = rj_os_system(cmdstr)
    version_temp = re.subn("(      \r\n)|(   \r\n\r\r\ndrivshell>)|(version\r\r)","",log)[0]
    version_clean = re.subn("\n","\n\t",version_temp)[0]

    return version_clean

def get_cpu_message():
    cpu_ret = getDmiSysByType("processor")
    return cpu_ret

def get_phypcie_version():
    cmd = 'bcmcmd -t 1 "pciephy fw version" < /dev/null'
    ret , log = rj_os_system(cmd)
    if ret != 0:
        print ("get version failed: pciephy fw")
        version_clean = ""
        # print log
    else:
        version_temp = re.subn("(      \r\n)|(   \r\n\r\r\ndrivshell>)|(version\r\r)","",log)[0]
        version_clean = re.subn("(pciephy fw \n)|(\r\r\ndrivshell>)","",version_temp)[0]
    # print version_temp
    return version_clean


def get_sonic_version():
    VERSION_TEMPLATE_CONTENTS = "SONiC.{build_version}"
    tmp_t ={}
    try:
        for line in open("/etc/sonic/sonic_version.yml"):
            swploca=line.index(':')
            tmp_t[line[0:swploca].replace("'","")] = line[swploca + 1: len(line)].replace("'","").replace(" ","").strip()
        s = VERSION_TEMPLATE_CONTENTS.format(**tmp_t)
        return s
    except Exception as e:
        ret -= 1
        return ""

def getFormatHead(HEAD):
    len_t = len(HEAD)
    formatstr = "    "
    headtip = formatstr
    septips = formatstr
    for i in range(len_t):
        formatstr += "%-20s "
        headtip += "%%-%ds "%(20+wide_chars(HEAD[i]))
        septips +="%-20s "
        headtip = headtip % HEAD[i]
        septips = septips % ("-"*20)
    print (headtip)
    print (septips)
    return formatstr


def rji2cgetWord(bus, devno, address):
    command_line = "i2cget -f -y %d 0x%02x 0x%02x w" % (bus, devno, address)
    retrytime = 3
    ret_t = ""
    for i in range(retrytime):
        ret, ret_t = rj_os_system(command_line)
        if ret == 0:
            return True, ret_t
    return False, ret_t


def rji2cget(bus, devno, address):
    command_line = "i2cget -f -y %d 0x%02x 0x%02x " % (bus, devno, address)
    retrytime = 6
    ret_t = ""
    for i in range(retrytime):
        ret, ret_t = rj_os_system(command_line)
        if ret == 0:
            return True, ret_t
        time.sleep(0.1)
    return False, ret_t


def get_mgmt_version():
    cmd = "ethtool -i eth0"
    valstr = ""
    ret , log = rj_os_system(cmd)
    if ret != 0:
        return "get version failed: 210 fw"
    else:
        version_temp = log.split('\n')
        for i in version_temp:
            valstr = "%s %s \n" %(valstr, '%s' % i)
    return valstr


def get_harddisk_info(sddev):
    ret = {}
    cmd = "smartctl -i /dev/%s |grep Device -A13" % sddev
    ret1, log1 = rj_os_system(cmd)
    if ret1 != 0 or len(log1) <= 0:
        return False, "命令执行出错[%s]" % cmd
    its = log1.replace("\t", "").strip().split("\n")
    for it in its:
        if ":" in it:
            key = it.split(":", 1)[0].lstrip()
            value = it.split(":", 1)[1].lstrip()
            ret[key] = value
    return True, ret

def show_harddisk_info():
    RET = {RETURN_KEY1 : -1, RETURN_KEY2 : ""}
    cmd = "ls -l /sys/block/sda"
    ind = None
    val = None
    ret, output = log_os_system(cmd, 0)
    sata_key, times = re.subn(".*/(ata.)/*","\g<1>",output.lower())
    ret, log = log_os_system("which smartctl", 0)
    if len(log):
        ind, val =get_harddisk_info("sda")
    else:
        RET[RETURN_KEY2] = "no smartctl cmd"
        return RET
    # print val
    valtemp = "    序列号    :{Serial Number} \n"\
              "    型号      :{Device Model} \n"\
              "    版本号    :{SATA Version is} \n"\
              "    空间      :{User Capacity} \n"\
              "    固件版本号:{Firmware Version} \n"

    s = valtemp.format(**val)
    if TESTCASE.get("ssd_slot_num", 1) == 2:
        if sata_key[0:4] == "ata1" :
            RJPRINT("  SATA slot:        1")
            RJPRINT(s)
            RJPRINT("\n  SATA slot:        2 (Not present)")
        else:
            RJPRINT("  SATA slot:        1 (Not present)")

            RJPRINT("\n  SATA slot:        2")
            RJPRINT(s)
    else:
        RJPRINT(s)
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    return RET

def get_cpld_version():
    # header = ["名称","日期","版本"]
    # formatstr = getFormatHead(header)
    result = []
    totalerr = 0
    for cpld in CPLDVERSIONS:
        dict = {}
        gettype = cpld.get("gettype",None)
        bus = cpld.get("bus",None)
        devno = cpld.get("devno",None)
        url = cpld.get("url",None)
        io_addr = cpld.get("io_addr",None)
        data = ""
        t = True
        ret = None
        if gettype == "lpc":
            for i in range(4):
                ret = lpc_cpld_rd(i)
                if ret == None:
                    t = False
                    break;
                data += chr(int(ret,16))
        elif gettype == "io":
            for i in range(4):
                ret = io_rd(io_addr + i)
                if ret == None:
                    t = False
                    break;
                data += chr(int(ret,16))
        elif gettype == "restful":
            ret = cpld_version_restful(url)
            if ret == None:
                continue
            data_1 = ret.replace("\""," ").strip().split(" ")
            for item in data_1:
                data += chr(int(item,16))
        else:
            for i in range(4):
                ind, ret = rji2cget(bus, devno, i)
                if ind == False:
                    t = False
                    break;
                data += chr(int(ret,16))
        if data == "":
            totalerr -= 1
            result.append([ cpld.get('name',None),"NA","NA" ])
        else:
            result.append([ cpld.get('name',None),"%02x%02x%02x" %  (ord(data[1]) ,ord(data[2]) ,ord(data[3])),"%02x" %  (ord(data[0]))])
    # for item in result:
    #    formatstr = "    %%-%ds %%-20s %%-20s "%((20+wide_chars(item[0])))
    #    print (formatstr%(item[0],item[1],item[2]))
    return totalerr,result

def show_81724_version():
    str1 = "phy control  ce fw_get"
    cmd  ='bcmcmd "%s" < /dev/null' % str1
    totalerr = 0
    version = None
    ind, log = rj_os_system(cmd)
    if ind == 0:
        for line in log.splitlines():
            if "fw_version" in line:
                if "success" not in line:
                    totalerr -= 1
                    RJPRINT(line)
                else:
                    versiontmp = re.findall(r"fw_version=(.+?) ", line)[0]
                    if version is None:
                        version = versiontmp
                    else:
                        if version != versiontmp:
                            RJPRINT(line)
            else:
                pass
    else:
        RJPRINT(" 命令执行失败(%s) %s" % (cmd, log))
    if totalerr == 0:
       RJPRINT("    %s" % version)

def show_fpga_version():
    RJPRINT("")
    RJPRINT("%s " % "FPGA版本检测")
    fpgastatus = TESTCASE.get("FPGA_INFO", None)
    totalerr = 0
    for item in fpgastatus:
        if item.get("gettype",None) == 'pci':
            pcibus = item.get("pcibus",None)
            slot = item.get("slot",None)
            fn = item.get("fn",None)
            bar = item.get("bar",None)
            offset = item.get("offset",None)
            ret = rjpcird(pcibus, slot, fn, bar, offset)
            if ret is None:
                totalerr = -1
                RJPRINT("\tget %s failed: fpga"% item.get("name", "error para"))
                continue
            RJPRINT("  %-19s： %s" % (item.get("name", "error para"), ret))
        else:
            pass
    return totalerr

def check_cpu_mac():
    #    print "CPU,BMC,TLV,FRU的MAC和录入的MAC进行比较"
    log1 = getsyseeprombyId(TLV_CODE_MAC_BASE).get('value')
    # cmd="ifconfig eth0 |grep HWaddr |awk '{print $5}'"
    cmd = "ifconfig eth0"
    ret, log2 = log_os_system(cmd, 0)
    if ret != 0:
        log_debug("\n ifconfig eth0 failed")
        return {RETURN_KEY1: -1, RETURN_KEY2: "ifconfig eth0 failed"}
    str_eth_tmp = re.subn('[\r\n\t]', ' ', log2.lower())
    cpu_mac = re.sub(".*(([0-9a-fA-F]{2,2}:){5,5}[0-9a-fA-F]{2,2}).*", "\g<1>", str_eth_tmp[0])
    if len(cpu_mac) != 17:
        log_debug("获取CPU MAC失败")
        return {RETURN_KEY1: -1, RETURN_KEY2: "获取CPU MAC失败"}
    log_debug("cpu_mac = %s, e2_mac = %s" % (cpu_mac.lower(), log1.lower()))
    if cpu_mac.lower() == log1.lower():
        return {RETURN_KEY1: 0, RETURN_KEY2: cpu_mac.lower()}
    else:
        log_debug("cpu_mac与e2_mac不相等")
        return {RETURN_KEY1: -1, RETURN_KEY2: "cpu_mac与e2_mac不相等"}

def show_bmc_mac():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    ret, msg = test_bmc_channel()
    if ret == False:
        log_debug("show_bmc_mac bmc channel error:%s" % msg)
        RET[RETURN_KEY1] = -1
        return RET

    cmd = "ifconfig eth0 |grep HWaddr |awk '{print $5}'"
    func = 'bmc_log_os_system'
    ret = test_bmc_func(func,cmd)
    if ret.get(RETURN_KEY1) == -1 or len(ret.get(RETURN_KEY2)) == 0:
        RET[RETURN_KEY1] = -1
        log_debug("BMC MAC 获取失败\nmessage:%s" % (ret.get(RETURN_KEY2)))
    else:
        RET = ret
        log_debug("BMC MAC 获取成功")
    return RET

def add_mac_num(list_mac,n):
    str_mac_lower=list(list_mac.lower())
    for j in range(int(n)):
        add_n=1
        for i in range(17):
            if str_mac_lower[16-i] ==':':
                continue
            else:
               if add_n==1:
                   if str_mac_lower[16-i]=='f':
                       str_mac_lower[16-i]='0'
                   elif str_mac_lower[16-i]=='9':
                       str_mac_lower[16-i]='a'
                       add_n=0
                   else:
                       int_mac=ord(str_mac_lower[16-i])+1
                       str_mac_lower[16-i]=chr(int_mac)
                       add_n=0
               else:
                   break
    return ''.join(str_mac_lower)

def show_device_mac():
    RJPRINT("%s " % "MAC地址：")
    RET = {RETURN_KEY1: 0, RETURN_KEY2: ""}
    RET = check_cpu_mac()
    result = 0
    if RET[RETURN_KEY1] < 0:
        RJPRINT(" 		CPU：fail %s" % RET[RETURN_KEY2])
        result = -1
    else:
        RJPRINT(" 		CPU：%s" % RET[RETURN_KEY2])
    if FACTESTMODULE.__contains__("bmcsetmac") and FACTESTMODULE['bmcsetmac'] == 1 and bmc_presence_check():
        bmc_right_macaddr = add_mac_num(RET[RETURN_KEY2], 2)
        RET = show_bmc_mac()
        if RET[RETURN_KEY1] < 0:
            RJPRINT(" 		BMC：fail %s" % RET[RETURN_KEY2])
            result = -1
        elif RET[RETURN_KEY2].lower() != bmc_right_macaddr.lower():
            result = -1
            RJPRINT(" 		BMC：%s" % RET[RETURN_KEY2])
            log_debug("bmc mac != cpu mac add 2")
        else:
            RJPRINT(" 		BMC：%s" % RET[RETURN_KEY2])
    RJPRINT("")
    return result

# Obtaining System Information
def test_sysinfo():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    errmsg = ""
    totalerr = 0

    RJPRINT("%-20s： %s"% ("ONIE版本", get_onie_full_version()))
    RJPRINT("%-20s： %s"% ("SONiC版本", get_sonic_version()))
    RJPRINT("%-20s： %s"% ("SDK版本", get_sdk_version()))

    RET1 = test_bios_flash()
    RJPRINT("%-21s： %s" % ('主BIOS版本',"%s"%(RET1["master"])))
    RJPRINT("%-21s： %s" % ('备BIOS版本',"%s"%(RET1["slave"])))
    if RET1[RETURN_KEY1] < 0 :
        totalerr -= 1
        RET[RETURN_KEY2] += RET1[RETURN_KEY2]
    log = get_bios_info()
    RJPRINT("%-20s： %s" % ('当前BIOS',"%s"%(log)))


    log_debug("正在获取软件版本信息")
    RJPRINT("")
    RJPRINT("%s "% "CPU")
    ret , biosmsg = get_cpu_message()
    if ret == True:
        # RJPRINT("      供应商       : %s" % (biosmsg["Manufacturer"]))
        RJPRINT("      版本         : %s" % (biosmsg["Version"]))
        RJPRINT("      Core Count   : %s" % (biosmsg["Core Count"]))
        RJPRINT("      Thread Count : %s" % (biosmsg["Thread Count"]))
    else:
        totalerr -= 1
    RJPRINT("")
    if FACTESTMODULE.get("show_device_mac", 0) == 1:
        totalerr += show_device_mac()
    if FACTESTMODULE.get("mac_pcie", 1) == 1:
        RJPRINT("%s "% "PCIE")
        ver = get_phypcie_version()
        RJPRINT(ver)
        if "version" not in ver or "error" in ver.lower():
            RJPRINT("PCIE 固件版本获取异常")
            totalerr -= 1

    if FACTESTMODULE.get("81724firmware", 0) == 1:
        RJPRINT("%s "% "81724版本")
        show_81724_version()
    RJPRINT("")

    RJPRINT("%s "% "I210版本")
    RJPRINT(get_mgmt_version())

    if FACTESTMODULE.get("sata", 1) == 1:
        RJPRINT("%s "% "SATA")
        show_harddisk_info()

    RJPRINT("")
    log_debug("正在获内存信息")
    # print "%s "% "内存"
    RJPRINT("%s "% "内存条:")
    ret ,log  = getsysmeminfo_detail()
    if ret == True:
        for item in log:
            if(len(MEM_SLOTS) == len(log)):
                RJPRINT("      槽位【%s】/【%s】" % (item["Locator"], MEM_SLOTS[log.index(item)]))
            else:
                RJPRINT("      槽位【%s】" % (item["Locator"]))
            RJPRINT("         序列号: %s" % (item["Serial Number"]))
            RJPRINT("         容量  : %s" % (item["Size"]))
            RJPRINT("         速度  : %s" % (item["Speed"]))
    else:
        totalerr -= 1

    if FACTESTMODULE.get("sysinfo_showhw", 1) == 1:
        RJPRINT("")
        RJPRINT("%s "% "硬件系统")
        ret ,sysmsg = gethwsys()
        if ret == True:
            RJPRINT("      产品名称      : %s" % (sysmsg["Product Name"]))
            RJPRINT("      版本          : %s" % (sysmsg["Version"]))
            RJPRINT("      序列号        : %s" % (sysmsg["Serial Number"]))
            RJPRINT("      产商          : %s" % (sysmsg["Manufacturer"]))
            RJPRINT("      SKU           : %s" % (sysmsg["SKU Number"]))
            RJPRINT("      UUID          : %s" % (sysmsg["UUID"]))
            RJPRINT("      Family        : %s" % (sysmsg["Family"]))
            RJPRINT("      Wake-up Type  : %s" % (sysmsg["Wake-up Type"]))
        else:
            totalerr -= 1
    else:
        pass

    RJPRINT("")
    RJPRINT("%s "% "CPLD版本检测")
    ind, val  = get_cpld_version()
    for item in val:
        formatstr = "  %-20s： %s%s"
        RJPRINT(formatstr%(item[0],item[2],item[1]))
    totalerr += ind

    if FACTESTMODULE.get("fpga_show", 0) == 1:
        totalerr += show_fpga_version()

    if totalerr <= 0:
        RET[RETURN_KEY1] += totalerr
        RET[RETURN_KEY2] += errmsg

    return RET

def test_diag_sysinfo():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    errmsg = ""
    totalerr = 0

    RJPRINT("%-20s： %s"% ("ONIE版本", get_onie_full_version()))
    RJPRINT("%-20s： %s"% ("SONiC版本", get_sonic_version()))
    RJPRINT("%-20s： %s"% ("SDK版本", get_sdk_version()))

    log = get_bios_info()
    RJPRINT("%-20s： %s" % ('当前BIOS',"%s"%(log)))

    RET1 = test_bios_flash()
    RJPRINT("%-20s： %s" % ('BIOS版本',"%s"%(RET1.get(log))))

    log_debug("正在获取软件版本信息")
    RJPRINT("")
    RJPRINT("%s "% "CPU")
    ret , biosmsg = get_cpu_message()
    if ret == True:
        # RJPRINT("      供应商       : %s" % (biosmsg["Manufacturer"]))
        RJPRINT("      版本         : %s" % (biosmsg["Version"]))
        RJPRINT("      Core Count   : %s" % (biosmsg["Core Count"]))
        RJPRINT("      Thread Count : %s" % (biosmsg["Thread Count"]))
    else:
        totalerr -= 1
    RJPRINT("")
    if FACTESTMODULE.get("mac_pcie", 1) == 1:
        RJPRINT("%s "% "PCIE")
        RJPRINT(get_phypcie_version())

    if FACTESTMODULE.get("81724firmware", 0) == 1:
        RJPRINT("%s "% "81724版本")
        show_81724_version()
    RJPRINT("")

    RJPRINT("%s "% "I210版本")
    RJPRINT(get_mgmt_version())

    RJPRINT("%s "% "SATA")
    show_harddisk_info()

    RJPRINT("")
    log_debug("正在获内存信息")
    # print "%s "% "内存"
    RJPRINT("%s "% "内存条:")
    ret ,log  = getsysmeminfo_detail()
    if ret == True:
        for item in log:
            if(len(MEM_SLOTS) == len(log)):
                RJPRINT("      槽位【%s】/【%s】" % (item["Locator"], MEM_SLOTS[log.index(item)]))
            else:
                RJPRINT("      槽位【%s】" % (item["Locator"]))
            RJPRINT("         序列号: %s" % (item["Serial Number"]))
            RJPRINT("         容量  : %s" % (item["Size"]))
            RJPRINT("         速度  : %s" % (item["Speed"]))
    else:
        totalerr -= 1

    if FACTESTMODULE.get("sysinfo_showhw", 1) == 1:
        RJPRINT("")
        RJPRINT("%s "% "硬件系统")
        ret ,sysmsg = gethwsys()
        if ret == True:
            RJPRINT("      产品名称      : %s" % (sysmsg["Product Name"]))
            RJPRINT("      版本          : %s" % (sysmsg["Version"]))
            RJPRINT("      序列号        : %s" % (sysmsg["Serial Number"]))
            RJPRINT("      产商          : %s" % (sysmsg["Manufacturer"]))
            RJPRINT("      SKU           : %s" % (sysmsg["SKU Number"]))
            RJPRINT("      UUID          : %s" % (sysmsg["UUID"]))
            RJPRINT("      Family        : %s" % (sysmsg["Family"]))
            RJPRINT("      Wake-up Type  : %s" % (sysmsg["Wake-up Type"]))
        else:
            totalerr -= 1
    else:
        pass

    RJPRINT("")
    RJPRINT("%s "% "CPLD版本检测")
    ind, val  = get_cpld_version()
    for item in val:
        formatstr = "  %-20s： %s%s"
        RJPRINT(formatstr%(item[0],item[2],item[1]))
    totalerr += ind


    if totalerr <= 0:
        RET[RETURN_KEY1] += totalerr
        RET[RETURN_KEY2] += errmsg

    return RET

# ====================================
# test item:RTC
# ====================================
def test_rtc():
    RET = ERROR_RETURN
    time1 = time.time();
    timeArraystart = time.localtime(time1)
    my_log("start time:" + str(time1))
    otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArraystart)
    RJPRINT("开始时间:%s" % otherStyleTime)
    time.sleep(RTC_WAIT_TIME)
    time2 = time.time();
    timeArrayend = time.localtime(time2)
    otherStyleTime1 = time.strftime("%Y-%m-%d %H:%M:%S", timeArrayend)
    RJPRINT("结束时间:%s" % otherStyleTime1)
    my_log("end time:" + str(time2))
    timeCompare =  time2 - time1
    my_log("time difference:" + str(timeCompare))
    if timeCompare < RTC_THRESHOLD_LOWER or timeCompare > RTC_THRESHOLD_UPPER:
        log_debug("RTC 测试失败")
        RET = {RETURN_KEY1: -1 , RETURN_KEY2 : "Error:RTC测试失败"}
    else:
        log_debug("RTC 测试成功")
        RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    return RET

# ====================================
# Executing shell commands
# ====================================
def get_sys_execute(str):
    # function 1
    result = os.popen(str)
    res = result.read()
    for line in res.splitlines():
        RJPRINT(line)
    '''
    #function 2
    output = subprocess.getstatusoutput(str)
    print  output


    #function 3
    p = subprocess.Popen('ps aux',shell=True,stdout=subprocess.PIPE)
    out,err = p.communicate()
    for line in out.splitlines():
       print line
    '''
# mylog
def my_log(txt):
    if DEBUG == True:
        RJPRINT("[RAGILE]:",)
        RJPRINT(txt)
    return
# ====================================
# Executing shell commands
# ====================================
def log_os_system(cmd, show):
    my_log ('         Run :'+ cmd)
    status, output = subprocess.getstatusoutput(cmd)
    my_log (" with result :" + str(status))
    my_log ("      output :" + output)
    if status:
        log_error('Failed :'+cmd)
        if show:
            RJPRINT('Failed :'+ cmd)
    return  status, output
# ====================================
# Copy machine initialization
# ====================================
def kj_init():
    global KAOJILOGFILE
    time1 = time.time()
    timeArraystart = time.localtime(time1)
    otherStyleTime = time.strftime("%Y%m%d_%H%M", timeArraystart)
    KAOJILOGFILE = "/var/grtd/kjlog_%s.log" % otherStyleTime
    log_debug("创建的拷机日志:" + KAOJILOGFILE)
    file = open(KAOJILOGFILE,'w')
    file.close()

# ====================================
# Copy machine results save
# ====================================
def KJERSULT(log):
    global KAOJILOGFILE
    strval = json.dumps(log, ensure_ascii = False,indent=4)
    with open(KAOJILOGFILE, 'w') as f:
        f.write(strval)

# ====================================
# Whether the test item exists in the copier error array
# ====================================
def kj_isexit(name, result):
    for item in result:
        #log_debug(item)
        if name == item["name"]:
#            log_debug(name + " in result")
            return True
    return False

# ====================================
# Returns information about the test items that exist in the error array
# ====================================
def kj_find_result(name , result):
    for item in result:
        if name == item["name"]:
#            log_debug(name + "exist")
            return item
    return None


# ====================================
# loop test
# ====================================
def test_loop():
    global kj_result
    global KAOJISTATUS
    global ISKAOJI
    kj_result = []
    real_kj_result ={"starttime":"","endtime":"","result":[] ,"loop":0}
    KAOJISTATUS = 1
    kj_init()
    # Create loop test file
    loop = 1
    isloopprint = True
    try:
        time1 = time.time();
        timeArraystart = time.localtime(time1)
        otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArraystart)
        real_kj_result["starttime"] = otherStyleTime
        while True:
            ISKAOJI = 1
            time1 = time.time();
            timetemp_t = time.localtime(time1)
            casestarttime = time.strftime("%Y-%m-%d %H:%M:%S", timetemp_t)
            RJPRINT("\n==================> 生测第%d轮拷机测试开始 <===================" %loop)
            log_debug("==========生测第%d轮拷机测试开始(%s)============" % (loop, casestarttime))
            for item in looptest:
                kj_itemresult = {"name":"test", "loop":[], "error":[]}
                RJPRINT("\n\n %s" % item[MENUITEMNAME])
                RJPRINT("=" * 60)
                log_debug(" ")
                log_debug("==========%s 开始============" % item[MENUITEMNAME])
                RET = dealchoosefunc(item) # eval(item[MENUITEMDEAL])()
                # log_debug(RET)
                if RET[RETURN_KEY1] != 0:
                    RJPRINT("[%s]测试结果:" % item[MENUITEMNAME] + 'Fail')
                    val_tmp = RET[RETURN_KEY2]
                    if kj_isexit(item[MENUITEMNAME], kj_result):
                        it = kj_find_result(item[MENUITEMNAME], kj_result)
                        # log_debug(it)
                        it["loop"].append(loop)
                        it["error"].append(val_tmp)
                    else:
                        kj_itemresult["name"] = item[MENUITEMNAME]
                        kj_itemresult["loop"].append(loop)
                        kj_itemresult["error"].append(val_tmp)
                        kj_result.append(kj_itemresult)
                else:
                    RJPRINT("[%s]测试结果:" % item[MENUITEMNAME] + 'Pass')
                log_debug("==========%s 结束============" % item[MENUITEMNAME])
            time2 = time.time();
            timeArrayend = time.localtime(time2)
            otherStyleTime1 = time.strftime("%Y-%m-%d %H:%M:%S", timeArrayend)
            real_kj_result["endtime"] = otherStyleTime1
            real_kj_result["result"] = kj_result
            real_kj_result["loop"] = loop
            # Write files
            KJERSULT(real_kj_result)
            RJPRINT("\n==================> 生测第%d轮拷机测试结束 <===================\n" %loop)
            log_debug("==========生测第%d轮拷机测试结束(%s)============" % (loop,otherStyleTime1))
            loop += 1
            # isloopprint = True
            # time.sleep(5)
            if KAOJISTATUS == 0:
                break
        ISKAOJI = 0
    except Exception as e:
        RJPRINT(e)
        log_error(str(e))
    return {RETURN_KEY1 : 1,  RETURN_KEY2 : ""}

def file_name(file_dir):
    L=[]
    for dirpath, dirnames, filenames in os.walk(file_dir):
        for file in filenames :
            if file.startswith("kjlog"):
                L.append(os.path.join(dirpath, file))
    datas =sorted(L,reverse=True)
    return datas


def readKjLog(filename):
    str1 =""
    try:
        with open(filename, 'r') as f:
             str1 = f.read()
        if str1 == "":
            raise Exception("文件内容为空")
        val_t = eval(str1)
        ret = val_t["result"]
        RJPRINT("=====================================拷机结果=========================================================")
        RJPRINT("开始时间: %s  \r\n结束时间: %s  \r\n总轮数  :【%d】"% (val_t["starttime"], val_t["endtime"], val_t["loop"]))

        if len(ret) > 0:
            RJPRINT(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>失败测试项:")
        else:
            RJPRINT("本次拷机无失败测试项")
        for item in ret:
            RJPRINT("%s  【%s】 "% ("测试项:", item["name"]))
            loopstr = ""
            for loop in item["loop"]:
                loopstr += " %d " % loop
            RJPRINT("失败的轮数:   %s" % loopstr),
            for loop in item["loop"]:
                RJPRINT("第【%d】轮数错误:" % loop)
                index = item["loop"].index(loop)
                errmsg = item["error"][index]
                if isinstance(errmsg, list):
                    for test in errmsg:
                        RJPRINT("   %s :  " % test["name"])
                        for case_ret  in test["errmsg"]:
                            RJPRINT("           {name}   {error}".format(**case_ret) )
                elif isinstance(errmsg, str):
                    RJPRINT("{0} \n{1}".format(item["name"] , errmsg))
                RJPRINT("\n")
    except Exception as e:
        RJPRINTERR(str(e))

    RJPRINT("\n\n\n\n")
# ====================================
# Copy machine log array selection
# ====================================
def printKJList():
    readtips = True
    L = file_name(KAOJILOGPATH)
    if len(L) <= 0:
        RJPRINT("\n\n没有拷机日志\n\n");
        return
    while(readtips):
        index = 0
        for x in L:
            RJPRINT("%d. %s"%(index, os.path.basename(x)))
            index += 1
            if (index >= kjlogmaxshow):
                break
        RJPRINT("q. %s"%("返回上一层"))
        test = "请选择:"
        str= getch(test)
        RJPRINT(" %s" % str)
        if str.isalnum() == False:
            RJPRINT("")
            continue
        # log_debug("选择:%s" % str)
        str = str.lstrip().lower()
        if str == "q":
            readtips = False
        elif (int(str) >= 0 and  int(str) <= index):
            readKjLog(L[int(str)])
        else:
            log_debug("异常输入项")

# ==================================================
# Copy machine result deleted
# ==================================================
def test_loop_delete():
    L = file_name(KAOJILOGPATH)
    if len(L) <=0:
        RJPRINT("没有拷机记录")
        return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for file in L:
        os.remove(file)    # Delete the file
    return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}

# ====================================
# Copy machine results to view
# ====================================
def test_loop_read():
    printKJList();
    return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}

def getRealUrl(case, param=None):
    http = TESTCASE.get('BMC').get('requesthttp')
    realurl = ""
    if param is None:
        realurl = "%scase=%s" %(http, case)
    else:
        realurl = "%scase=%s&param=%s"% (http, case, param)
    return realurl

def test_bmc_func(func,param=None):
    if param is None:
        ret = HttpRest().Get(getRealUrl(func))
    else:
        ret = HttpRest().Get(getRealUrl(func,json.dumps(param)))
    return ret

def test_bmc_testcase(param_t):
    ret = test_bmc_func(param_t)
    RJPRINT(ret.get(RETURN_KEY2))
    return ret

def uploadfile(filename):
    http = TESTCASE.get('BMC').get('uploadfilehttp')
    return HttpRest().uploadfile(http, filename)

def test_cpld_new():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    ermsg = ""
    # dealtype = E2_PROTECT.get('gettype',None)
    vals = TESTCASE["CPLDTEST"]
    # vals = "123"
    if type(vals) == list:
        for item in vals:
            dealtype = item.get('gettype',None)
            if dealtype is not None and dealtype == "io":
                for wr_tmp in item.get('testval'):
                    io_wr(item.get('io_addr') + item.get('addr'), wr_tmp)
                    rets = io_rd(item.get('io_addr') + item.get('addr'))
                    if int(rets, 16) ==  wr_tmp:
                        RJPRINT("%-30s  0x%02x  %s" % (item.get('name'), wr_tmp, 'OK'))
                    else:
                        totalerr -= 1
                        ermsg = "%s %-30s  io_addr: 0x%0x addr:0x%02x  val:0x%02x rd:0x%02x \n" % (ermsg, item.get('name'),item.get('io_addr'), item.get('addr'),wr_tmp, int(rets, 16) )
            else:
                for wr_tmp1 in item.get('testval'):
                    rji2cset(item.get('bus'), item.get('devno'),item.get('addr'),wr_tmp1)
                    ret,ind = rji2cget(item.get('bus'), item.get('devno'),item.get('addr'))
                    if wr_tmp1 == int(ind, 16):
                        RJPRINT("%-30s  0x%02x  %s" % (item.get('name'), wr_tmp1, 'OK'))
                    else:
                        totalerr -= 1
                        ermsg = "%s %-30s bus:%3d devno:0x%02x addr:0x%02x 0x%02x rd:%s \n" % (ermsg, item.get('name'),item.get('bus'), item.get('devno'),item.get('addr'), wr_tmp1, ind)
    else:
        totalerr -= 1
        ermsg  = '参数错误'
    if totalerr < 0:
        RJPRINTERR("\nerrmsg:")
        RJPRINTERR(ermsg)
    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = ermsg
    return RET



# ====================================
# cpld test
# ====================================
def test_cpld():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for cpld in TESTCASE["CPLD"]:
        RJPRINT("测试项: %s" % cpld["name"])
        if "cases" not in cpld:
            RJPRINT("没有测试项")
            continue
        for case in cpld["cases"]:
            RJPRINTLINE(case["name"])
            # Gets the command invoked
            cmd_t = case["cmd"].lstrip()
            cmd = cmd_t[0 : cmd_t.index(" ")]
            ret, log = log_os_system("which " + cmd, 0)
            if len(log):
                cmd = "cmd find "
            else:
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = "no" + cmd +" found"
                return RET
            log_debug(case["cmd"])
            ret, log = log_os_system(case["cmd"], 0)
            log_debug(log)
            if ret or ("Error" in log ):
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = log
                RJPRINT("[FAILED]")
            else:
                RJPRINT("[OK]")
    return RET


def test_voltage_getValue(item_r):
    gettype = item_r.get('gettype')
    len = item_r.get('len')
    address = item_r.get('io_addr')
    calcuvol = item_r.get('formula')
    min = item_r.get('minThread')
    max = item_r.get('maxThread')
    name = item_r.get('name')
    bus = item_r.get('bus')
    devno = item_r.get('devno')
    offset = item_r.get('addr')
    select = item_r.get('select')
    slectvalue = item_r.get('slectvalue')
    val = None
    if gettype == 'pagei2c':
        rji2cset(bus,devno, select, slectvalue)
        ret, ind = rji2cget(bus,devno, offset)
        if ret == False:
            val = None
        else:
            val =  ind.replace("0x","").replace("0X","")
    elif gettype == 'pagei2cword':
        rji2cset(bus,devno, select, slectvalue)
        ret, ind = rji2cgetWord(bus,devno, offset)
        if ret == False:
            val = None
        else:
            val =  ind.replace("0x","").replace("0X","")
    elif gettype == 'io':
        val = io_rd(address, len)
        val = "%0x" %(int(val, 16) >> 4)
    elif gettype == 'i2c':
        i2ctmp = ''
        for i in range(0,len):
            ret, ind = rji2cget(bus,devno, offset+i)
            if ret == False:
                i2ctmp = None
                break
            i2ctmp += ind.replace("0x","").replace("0X","")
        if i2ctmp == None:
            val = None
        else:
            val = "%0x" %(int(i2ctmp, 16) >> 4)
    return val


def test_voltage():
    RET =  {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg =""
    resultval = []

    voldef = TESTCASE.get("voltagesensors",None)
    if voldef is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    # Find the reference value
    calu = voldef.get("voltagecal",None)
    if calu is None:
        RET[RETURN_KEY1] = -997
        RET[RETURN_KEY2] = 'config error'
        return RET

    boardtemps = voldef.get('voltages',None)
    if boardtemps is None:
        RET[RETURN_KEY1] = -998
        RET[RETURN_KEY2] = 'config error'
        return RET
    try:
        for key in boardtemps.keys():
            voltage_tmp = boardtemps.get(key)
            reference = None
            referenceitem = None

            for item in voltage_tmp:
                if item.get('reference',0)==1:
                    referenceitem = item
            if referenceitem is None:
                totalerr -= 1
                errmsg += "%s not find config\n" % key
                RJPRINT(errmsg)
                continue

            val = test_voltage_getValue(referenceitem)
            if val is None:
                totalerr -= 1
                errmsg += "%s read reference error\n" % key
                RJPRINT(errmsg)
                continue
            result = calu % val
            reference = eval(result)


            if type(val) == str:
                log_debug(" %s reference name:%s val type:0x%s  val:%f"% (key, referenceitem.get('name'),val, reference))
            if reference is None:
                totalerr -= 1
                errmsg += "%s reference cal error\n" % key
            else:
                for item_r in voltage_tmp:
                    val_calc = test_voltage_getValue(item_r)
                    gettype = item_r.get('gettype')
                    calcuvol = item_r.get('formula')
                    min = item_r.get('minThread')
                    max = item_r.get('maxThread')
                    name = item_r.get('name')
                    statusmsg = 'N/A'

                    if val_calc is None:
                        totalerr -= 1
                        resultval.append([("%s_%s"%(key,name)),'N/A' , min, max, statusmsg])
                        continue
                    if gettype == 'pagei2c':
                        pagei2c_tmp = calcuvol %(val_calc, val_calc)
                        val_tmp = eval(pagei2c_tmp)
                    if gettype == 'pagei2cword':
                        pagei2c_tmp = calcuvol %(val_calc)
                        val_tmp = eval(pagei2c_tmp)
                    elif gettype == 'io' or gettype == 'i2c':
                        result_curr_tmp = calu % val_calc
                        result_curr = eval(result_curr_tmp)
                        result = calcuvol % (result_curr, reference)
                        val_tmp = eval(result)
                    if min < val_tmp <max:
                        statusmsg = 'OK'
                    else:
                        totalerr -= 1
                        statusmsg = 'Not OK'
                    log_debug("%s_%s val:%f  threadsold[%f, %f]"%(key, name, val_tmp,min, max))
                    resultval.append([("%s_%s"%(key,name)),val_tmp , min, max, statusmsg])
    except Exception as e:
        totalerr = -1001
        import traceback
        msg = traceback.format_exc() # 方式1
        print (msg)

    header = [ 'Sensor',  'Value', 'LowThd', 'HighThd' ,'State' ]
    result = tabulate(resultval, header, tablefmt='simple')
    RJPRINT(result)
    if totalerr < 0:
        errmsg += str(result)

    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def test_phy_recover():
    RET =  {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret, log = rj_os_system("docker exec -it syncd cat /tmp/repair")
    if ret != 0 or len(log) <= 0 :
        return RET
    RJPRINT("")
    RJPRINT("槽位         端口      修复温度")
    RJPRINT("-------    -------  -----------")
    logic_ports = PortTest().logic_ports
    alias = TESTCASE.get('port_alias', None)
    logs = log.splitlines()
    for line in logs:
        if "temperature" in line:
            ret = re.findall(r'port_start:\[(\d+)\]', line)
            port_num1 = re.findall(r'/(\d+)', alias.get(logic_ports.index((int)(ret[0]))+1,None))
            ret = re.findall(r'port_end:\[(\d+)\]', line)
            port_num2 = re.findall(r'/(\d+)', alias.get(logic_ports.index((int)(ret[0]))+1,None))
            lost_num = re.findall(r'\d+', alias.get(logic_ports.index((int)(ret[0]))+1,None))
            temp_num = ((float)(re.findall(r'temperature:\[(.*?)\]', line)[0]))/1000.0
            port_msg = "%s-%s"%(port_num1[0], port_num2[0])
            keep_message(RET, ("SLOT%-6s%8s%13.1f" % (lost_num[0],port_msg, temp_num )))
    RJPRINT(RET[RETURN_KEY2])
    return RET

def embedded_numbers(s):
    re_digits = re.compile(r'(\d+)')
    pieces = re_digits.split(s)                 # Cut into numbers and non-numbers
    pieces[1::2] = map(int, pieces[1::2])       # Convert the number part to an integer
    return pieces

def test_tempinfo_new():
    '''Temperature detection 19/05/10'''
    RET =  {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ""


    RJPRINT("%s "% "板载温度")
    temp_def = TESTCASE.get("temps",None)
    if temp_def is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    boardtemps = temp_def.get('boards',None)
    if boardtemps is None:
        RET[RETURN_KEY1] = -998
        RET[RETURN_KEY2] = 'config error'
        return RET

    for item in boardtemps:
        retval = ""
        rval = None
        name = item.get('displayname')
        location = item.get('location')
        try:
            locations = glob.glob(location)
            with open(locations[0], 'r') as fd1:
                retval = fd1.read()
            rval = float(retval)/1000
            formatlenstr = "  %%-%ds: %%.2f %%s" % (25+wide_chars(name))
            RJPRINT(formatlenstr %(name, rval, 'C'))
        except Exception as e:
            totalerr -= 1
            errmsg = " %s %s" % (errmsg, str(e))
            formatlenstr2 = "  %%-%ds: %%s" % (25+wide_chars(name))
            RJPRINT(formatlenstr2 %(name, 'NA'))


    RJPRINT("")
    RJPRINT("%s "% "MAC温度")
    ret, log = log_os_system("bcmcmd \"show temp\"",0)
    ret, log = log_os_system("bcmcmd \"show temp\"",0)
    if ret :
        totalerr -= 1
        errmsg += "[获取MAC温度出错]"
        RJPRINT("[FAILED]")
    else:
        # Parse the read information
        logs = log.splitlines()
        for line in logs:
            if "average" in line:
                b = re.findall(r'\d+.\d+',line)
                RJPRINT("  %s : %s %s"%("平均温度  ", b[0],"C"))
                log_debug("平均温度 %s ℃ " %  b[0])
            elif "maximum" in line:
                b = re.findall(r'\d+.\d+',line)
                RJPRINT("  %s : %s %s"%("最高温度  ", b[0],"C"))
                log_debug("最高温度 %s ℃ " %  b[0])
    RJPRINT("")
    RJPRINT("%s "% "CPU温度")
    location = temp_def.get('cpu',None)
    L=[]
    for dirpath, dirnames, filenames in os.walk(location):
        for file in filenames :
            if file.endswith("input"):
                L.append(os.path.join(dirpath, file))
        L =sorted(L, key=embedded_numbers)

    for i in range(len(L)):
        nameloc = L[i].replace("input","label")
        valloc  = L[i]
        # print nameloc
        with open(nameloc, 'r') as fd1:
            retval2 = fd1.read()
        with open(valloc, 'r') as fd2:
            retval3 = fd2.read()
        RJPRINT("  %-25s : %d C" %( retval2.strip(), float(retval3)/1000))
        # print retval3


    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

# ====================================
# Power status detection
# ====================================
def test_power():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    RET1 = sysinfo_show_psumsg()
    RET[RETURN_KEY1] += RET1[RETURN_KEY1]
    RET[RETURN_KEY2] += RET1[RETURN_KEY2]
    return RET


def test_i2c_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       print ("\n\n第 %d/%d 次测试"%(i+1, test_times))
       RET1 = test_i2c_new()
       # print_temp_flush()
       totalerr += RET1[RETURN_KEY1]
       RET[RETURN_KEY2] += RET1[RETURN_KEY2]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def i2cget_python(bus, devno, address):
    ret_t = ""
    ret, ret_t = osutil.rji2cget_python(bus, devno, address)
    if ret:
        return True, ret_t
    return False, ret_t

def test_i2c_stress_new():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    errtotal = 0
    test_times = TESTCASE.get("i2c_test_times", 100) # 100000000000000000
    keep_str = ""
    scan_list = TESTCASE["I2CSCAN"]
    errmsg = ""
    for i in range(0, test_times + 1):
        err_flag = False
        for i2cdev in scan_list:
            formatstr = "    %%-%ds %%-10s\n" % ((40 + wide_chars(i2cdev['name'])))
            if i == 0:
                keep_str += formatstr % (i2cdev['name'], "PASS")
                continue
            ret, log = i2cget_python(i2cdev["bus"], i2cdev["addr"], 0)
            if ret == False:
                tmp = formatstr % (i2cdev['name'], "PASS")
                replace_str = formatstr % (i2cdev['name'], "FAILED")
                keep_str = keep_str.replace(tmp, replace_str)
                errmsg = "%s %s\n" % (errmsg, i2cdev['name'])
                err_flag = True
        if err_flag:
            errtotal += 1
    RJPRINT(keep_str)
    RJPRINT("\n\nI2C %d次压力测试" % test_times)
    RJPRINT("PASS TIMES：%d" % (test_times - errtotal))
    RJPRINT("FAILED TIMES：%d" % errtotal)
    if errtotal != 0:
        RET[RETURN_KEY1] = errtotal
        RET[RETURN_KEY2] = errmsg
    return RET

def test_get_psu_fru():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ""
    psus =  FRULISTS.get('psus')
    for psu in psus:
        try:
            RJPRINT("===============%s ================getmessage" % psu.get('name'))
            eeprom = I2CUTIL.dumpValueByI2c(psu.get('bus'), psu.get('loc'))
            if eeprom is None:
                raise Exception("%s:取值错误" % psu.get('name'))
            fru = ipmifru()
            fru.decodeBin(eeprom)

            if fru.boardInfoArea is not None:
                RJPRINT("=================board=================")
                RJPRINT(fru.boardInfoArea)
            if fru.productInfoArea is not None:
                RJPRINT("=================product=================")
                RJPRINT(fru.productInfoArea)
        except Exception as e:
            RJPRINT(str(e))
            totalerr -=1
            errmsg = " %s %s %s \n" %(errmsg, psu.get('name'), str(e))

    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return  RET

def fan_check1(fans, levelpolicy, errt_t):
    try:
        stopFanctrol()
        ret_t = 0
        for level in levelpolicy["level"]:
            testerror = {}
            ind = levelpolicy["level"].index(level)
            lowspeed = levelpolicy["low_speed"][ind]
            highspeed = levelpolicy["high_speed"][ind]
            strtmp = "风扇转速等级: 【%s】 写入cpld值:0x%02x  阈值: [%d , %d]"% (levelpolicy["tips"][ind], level,lowspeed,highspeed)
            RJPRINT(strtmp)
            log_debug(strtmp)
            for item in fans:
                loc = item.get('location')
                write_sysfs_value(loc, "0x%02x"% level )
                ret_val = get_sysfs_value(loc)
                log_debug("写入的值为%s" % ret_val)
            time.sleep(13)
            caseerror = []
            for item_fan in fans:
                testind = 0
                RJPRINT(item_fan.get('name'))
                for fanstatus in item_fan["childfans"]:
                    nowspeed = test_fan_speed_average(fanstatus["location"])
                    if nowspeed != -1:
                        log_debug("%s (now: %d low:%d high:%d)"% (fanstatus["name"], nowspeed ,lowspeed,highspeed))
                        speedmsg = "(%d)"% ( nowspeed)
                        if lowspeed < nowspeed and highspeed > nowspeed:
                            RJPRINT("    %s %s : %s"%(fanstatus["name"],speedmsg, "[PASS]"))
                        else:
                            RJPRINT("    %s %s : %s"%(fanstatus["name"],speedmsg, "[FAILED]"))
                            caseerror.append({"name": ("%s %s" %(item_fan.get('name'),fanstatus["name"])) ,"error":"不在转速范围内 [nowspeed: %d low_speed:%d high:%d]" % ( nowspeed ,lowspeed,highspeed)})
                            ret_t -= 1
                            testind -= 1
                    else:
                        RJPRINT("    %s : %s"%(fanstatus["name"], "[FAILED]"))
                        caseerror.append({"name": ("%s %s" %(item_fan.get('name'),fanstatus["name"])) ,"error":"获取转速为空"})
                        ret_t -= 1
                        testind -= 1
                if len(caseerror) > 0:
                    testerror["name"] = "转速等级:[%s]0x%02x "% (levelpolicy["tips"][ind], level)
                    testerror['errmsg'] = caseerror
            if testind < 0:
                errt_t.append(testerror)
    except Exception as e:
        print (e)
        log_error(e.message)
        return False
    finally:
        startFanctrol()
    if ret_t < 0:
        return ret_t
    return ret_t

def write_sysfs_value(reg_name, value):
    retval = 'ERR'
    fileLoc = MAILBOX_DIR + reg_name
    try:
        if not os.path.isfile(fileLoc):
            print (fileLoc,  'not found !')
            return False
        with open(fileLoc, 'w') as fd:
            fd.write(value)
    except Exception as error:
        log_error("Unable to open " + fileLoc + "file !")
        return False
    return True


def get_config_file(filename):
    if not os.path.isfile(filename):
        return ""
    machine_vars = {}
    with open(filename) as machine_file:
        for line in machine_file:
            tokens = line.split('=')
            if len(tokens) < 2:
                continue
            machine_vars[tokens[0]] = tokens[1].strip()
    return machine_vars

def get_onie_full_version():
    machine_vars = get_config_file('/host/machine.conf')
    return "%s_%s" % (machine_vars.get("onie_version"),machine_vars.get("onie_build_date"))

def getonieversion():
    if not os.path.isfile('/host/machine.conf'):
        return ""
    machine_vars = {}
    with open('/host/machine.conf') as machine_file:
        for line in machine_file:
            tokens = line.split('=')
            if len(tokens) < 2:
                continue
            machine_vars[tokens[0]] = tokens[1].strip()
    return machine_vars.get("onie_version")


def fac_board_setmac():
    _value = {}

    try:
        onie = onie_tlv()
        # default value
        _value[onie.TLV_CODE_VENDOR_EXT] = generate_ext(RAGILE_CARDID)  # Generates an ID unique to RAGILE
        _value[onie.TLV_CODE_PRODUCT_NAME] = RAGILE_PRODUCTNAME
        _value[onie.TLV_CODE_PART_NUMBER]    = RAGILE_PART_NUMBER
        _value[onie.TLV_CODE_LABEL_REVISION] = RAGILE_LABEL_REVISION
        _value[onie.TLV_CODE_PLATFORM_NAME]  = platform
        _value[onie.TLV_CODE_ONIE_VERSION]   = getonieversion()
        _value[onie.TLV_CODE_MAC_SIZE]       = RAGILE_MAC_SIZE
        _value[onie.TLV_CODE_MANUF_NAME]     = RAGILE_MANUF_NAME
        _value[onie.TLV_CODE_MANUF_COUNTRY]  = RAGILE_MANUF_COUNTRY
        _value[onie.TLV_CODE_VENDOR_NAME]    = RAGILE_VENDOR_NAME
        _value[onie.TLV_CODE_DIAG_VERSION]   = RAGILE_DIAG_VERSION
        _value[onie.TLV_CODE_SERVICE_TAG]    = RAGILE_SERVICE_TAG
        if 0x00004052 == RAGILE_CARDID:
            _value[TLV_CODE_PRODUCT_NAME] = RAGILE_PRODUCTNAME + "-RJ"
        elif 0x00004051 == RAGILE_CARDID or 0x00004050 == RAGILE_CARDID:
            changeTypeValue(_value, TLV_CODE_PRODUCT_NAME,
                        "产品名称",RAGILE_PRODUCTNAME)

        changeTypeValue(_value, TLV_CODE_SERIAL_NUMBER,
                        "SN", "0000000000000")  # Add serial number
        changeTypeValue(_value, TLV_CODE_DEVICE_VERSION,
                        "硬件版本号", "101")  # Hardware Version number
        changeTypeValue(_value, TLV_CODE_MAC_BASE,
                        "MAC地址", "58696cfb2108")  # MAC address
        _value[TLV_CODE_MANUF_DATE] = time.strftime(
            '%m/%d/%Y %H:%M:%S', time.localtime())  # Automatically add setMAC time
        rst, ret = onie.generate_value(_value)
        if util_setmac("eth0", _value[TLV_CODE_MAC_BASE]) == True:  # Setting the NIC IP Address
            writeToEEprom(rst)  # Write the value to e2
        else:
            return False
    except SETMACException as e:
        # print e
        RJPRINTERR("\n\n%s\n\n" % e)
        return False
    except ValueError as e:
        return False
    return True

def generate_ext(cardid):
    s = "%08x" % cardid
    ret = ""
    for t in range(0, 4):
        ret += chr(int(s[2 * t:2 * t + 2], 16))
    ret = chr(0x01) + chr(len(ret)) + ret
    return ret


def test_stop_fanctrol():
    stopFanctrol()
    return True,""

def test_start_fanctrol():
    startFanctrol()
    return True,""

def test_power_pmbus_msg():
    '''Obtain PMBUS information about power supplies'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ""
    fanstatus = TESTCASE.get("frustatus",None)
    if fanstatus is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    psu_pmbus = fanstatus.get('psupmbus', None)
    if psu_pmbus is None:
        RET[RETURN_KEY1] = -998
        RET[RETURN_KEY2] = 'config error'
        return RET

    for item in psu_pmbus:
        print (item.get('name'))
        loc = item.get('values')
        for lo in loc:
            retval = ""
            rval = None
            name = lo.get('displayname')
            unit = lo.get('unit')
            location = lo.get('location')
            min_value = lo.get('min',-999999)
            max_value = lo.get('max',999999)
            try:
                locations = glob.glob(location)
                with open(locations[0], 'r') as fd1:
                    retval = fd1.read()
                if unit == 'A' or unit == 'V' or unit == 'C':
                    rval = float(retval)/1000
                elif unit == 'W':
                    rval = float(retval)/1000/1000
                else:
                    rval = float(retval)
                if rval >= max_value or rval <= min_value:
                    totalerr -= 1
                RJPRINT("  %-10s: %.2f %s" %(name, rval, unit))
            except Exception as e:
                totalerr -= 1
                errmsg = " %s %s" % (errmsg, str(e))
                RJPRINT("  %-10s: error" %(name))
    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def test_power_status():
    '''Test power supply status'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    fanstatusdecode = TESTCASE.get("frustatusdecode",None)
    fanstatus = TESTCASE.get("frustatus",None)
    errmsg = ""

    if fanstatus is None or fanstatusdecode is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    psu_conf = fanstatus.get('psus', None)
    if psu_conf is None:
        RET[RETURN_KEY1] = -998
        RET[RETURN_KEY2] = 'config error'
        return RET

    psupresent = fanstatusdecode.get('psupresent')
    psuoutput = fanstatusdecode.get('psuoutput')
    psualert = fanstatusdecode.get('psualert')

    for item_fan in psu_conf:
        retval = None
        gettype = item_fan.get('gettype',None)
        statusbit = item_fan.get('statusbit')
        presentbit = item_fan.get('presentbit')
        alertbit = item_fan.get('alertbit')
        if gettype is not None and gettype == "io":
            io_addr = item_fan.get('io_addr')
            val = io_rd(io_addr)
            if val is not None:
                retval = val
            else:
                totalerr -=1
                errmsg = " %s  %s" % (errmsg, "lpc读取失败")
                pass
        else:
            i2c_addr = item_fan.get('i2c_addr')
            bus = i2c_addr['bus']
            devno = i2c_addr['devno']
            reg_offset = i2c_addr['reg_offset']
            ind, val = rji2cget(bus, devno,reg_offset)
            if ind == True:
                retval = val
            else:
                totalerr -=1
                errmsg = " %s  %s" % (errmsg, "i2c读取失败")
                pass
        if retval is None:
            continue
        val_t = (int(retval,16) & (1<< presentbit)) >> presentbit
        val_status = (int(retval,16) & (1<< statusbit)) >> statusbit
        val_alert = (int(retval,16) & (1<< alertbit)) >> alertbit
        msg = "%s \n" \
              "    在位状态: %s\n"\
              "    输出状态: %s \n"\
              "    告警状态: %s \n"% (item_fan.get('name'),psupresent.get(val_t),psuoutput.get(val_status),psualert.get(val_alert))
        RJPRINT(msg)
        if val_t != psupresent.get('okval') or val_status != psuoutput.get('okval') or val_alert != psualert.get('okval'):
            errmsg += msg
            totalerr -=1
        else:
            pass

    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def test_fan_speed_average(loc,read_cnt=5,critical_speed=None):
    speedlist = []
    max_cnt = read_cnt + 5    # Redundant 5 times
    for i in range(0,max_cnt):
        real_value = get_pmc_register(loc)
        if real_value.isdigit():
            speedlist.append(int(real_value))
        else:
            log_debug("fan speed read error,times:%d,loc:%s"%(i,loc))
        if len(speedlist) == read_cnt:
            break
        time.sleep(0.01)
    if len(speedlist) == read_cnt:
        log_debug("风扇转速排序前: %s" % speedlist)
        speedlist.sort()
        log_debug("风扇转速排序后: %s" % speedlist)
        if critical_speed is not None and speedlist[read_cnt-1] >= critical_speed:
            return speedlist[read_cnt-1]
        return speedlist[int((read_cnt -1)/2)]    # Take the median
    return -1


def test_fan_speed():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret_t = 0
    errmsg =""
    low_speed = fanlevel.get('low_speed')[0]
    high_speed = fanlevel.get('high_speed')[2]
    for item_fan in fanloc:
        RJPRINT(item_fan.get('name'))
        for fanstatus in item_fan["childfans"]:
            nowspeed = test_fan_speed_average(fanstatus["location"])
            if nowspeed == -1:
                RJPRINT("    %s : %s"%(fanstatus["name"], "[FAILED]"))
                ret_t -= 1
                continue
            if nowspeed not in range(low_speed, high_speed):
                ret_t -= 1
                speedmsg = "(%d) not in [%d, %d] failed"% ( nowspeed, low_speed, high_speed)
                errmsg = " %s %s %s\n" % (errmsg, fanstatus["name"],speedmsg)
            else:
                speedmsg = "(%d)"% (nowspeed)
            RJPRINT("    %s %s"%(fanstatus["name"],speedmsg))
    RET[RETURN_KEY1] = ret_t
    RET[RETURN_KEY2] = errmsg
    return RET

def test_M6510_fan_speed():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    fanspeedcheck = TESTCASE.get("fanspeedcheck",None)
    printmsg = ""
    speedmsg = ""
    errmsg = ""

    if fanspeedcheck is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    low_speed = fanspeedcheck.get("low_speed")
    high_speed = fanspeedcheck.get("high_speed")
    critical_speed = fanspeedcheck.get("critical_speed")
    fanloc = fanspeedcheck.get("fanloc")
    speed_read_times = fanspeedcheck.get("speed_read_times")
    retry = fanspeedcheck.get("retry")          # Retry count
    
    for item_fan in fanloc:
        try:
            fan_name = item_fan.get('name')
            retry_cnt = 0
            while retry_cnt < retry:          # Retry for each fan
                nowspeed = test_fan_speed_average(item_fan["speed_loc"],speed_read_times,critical_speed)
                log_debug("%s speed:%d retry:%d" % (fan_name,nowspeed,retry_cnt))
                if nowspeed == -1 or nowspeed >= critical_speed:
                    speedmsg = "%s (%d) not in [%d, %d] failed"% (fan_name, nowspeed, low_speed, high_speed)
                    totalerr -= 1
                    break
                if nowspeed <= high_speed and nowspeed >= low_speed:
                    speedmsg = "%s (%d)"% (fan_name, nowspeed)
                    break
                speedmsg = "%s (%d) not in [%d, %d] failed"% (fan_name, nowspeed, low_speed, high_speed)
                retry_cnt += 1
            RJPRINT("    %s"% speedmsg)
            if retry_cnt == retry:
                totalerr -= 1
                errmsg += (speedmsg + "\n")
        except Exception as e: 
            totalerr -= 1
            errmsg += (srt(e) + "\n")
    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def test_fan_status():
    '''Test the fan status online and running'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    fanstatusdecode = TESTCASE.get("frustatusdecode",None)
    fanstatus = TESTCASE.get("frustatus",None)

    if fanstatus is None or fanstatusdecode is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    fans_conf = fanstatus.get('fans', None)
    if fans_conf is None:
        RET[RETURN_KEY1] = -998
        RET[RETURN_KEY2] = 'config error'
        return RET

    fanpresent = fanstatusdecode.get('fanpresent')
    fanroll = fanstatusdecode.get('fanroll')

    for item_fan in fans_conf:
        RJPRINTLINE(item_fan.get('name'))
        presentbus = item_fan.get('bus')
        presentaddr = item_fan.get('presentloc')
        presentbit = item_fan.get('presentbit')
        loc      = item_fan.get('loc')
        childs   = item_fan.get('childfans')
        ind, val = rji2cget(presentbus, loc,presentaddr)
        if ind == True:
            val_t = (int(val,16) & (1<< presentbit)) >> presentbit
            RJPRINT(fanpresent.get(val_t))
            if val_t != fanpresent.get('okval'):
                totalerr -=1
            else:
                pass
        else:
            totalerr -=1
            RJPRINT("在位状态获取失败")

        for child in childs:
            RJPRINTLINE("    %s" % child.get('name'))
            statusloc  = child.get('statusloc', None)
            statusbit  = child.get('statusbit', None)
            ind, val = rji2cget(presentbus, loc, statusloc)
            if ind == True:
                val_t = (int(val,16) & (1<< statusbit)) >> statusbit
                RJPRINT(fanroll.get(val_t))
                if val_t != fanroll.get('okval'):
                    totalerr -=1
                else:
                    pass
            else:
                totalerr -=1
                RJPRINT("状态获取失败")
    RET[RETURN_KEY1] = totalerr
    return RET


def test_fan_speed_new(param=None):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    try:
        ret_t = 0
        if param is None:
            RET[RETURN_KEY1] = -999
            RET[RETURN_KEY2] = 'param err'
            return RET
        param_t = json.loads(param)
        speedval  = param_t.get('levelval', None)
        lowspeed  = param_t.get('low', None)
        highspeed = param_t.get('high', None)
        sleeptime = param_t.get('sleep', None)

        if sleeptime is None or isinstance(sleeptime,int) == False:
            RET[RETURN_KEY1] = -998
            RET[RETURN_KEY2] = 'sleeptime param err'
            return RET

        if speedval is None or lowspeed is None or highspeed is None:
            RET[RETURN_KEY1] = -998
            RET[RETURN_KEY2] = 'speedval/lowspeed/highspeed param err'
            return RET

        strtmp = "写入cpld值:0x%02x  阈值: [%d , %d]"% (speedval, lowspeed, highspeed)
        RJPRINT(strtmp)
        log_debug(strtmp)

        for item in fanloc:
            loc = item.get('location')
            write_sysfs_value(loc, "0x%02x"% speedval )
            ret_val = get_sysfs_value(loc)
            log_debug("写入的值为%s" % ret_val)
        time.sleep(sleeptime)

        caseerror = ""
        for item_fan in fanloc:
            RJPRINT(item_fan.get('name'))
            for fanstatus in item_fan["childfans"]:
                real_value = get_pmc_register(fanstatus["location"])
                if real_value.isdigit():
                    nowspeed = int(real_value)
                    log_debug("%s (now: %d low:%d high:%d)"% (fanstatus["name"], nowspeed ,lowspeed,highspeed))
                    speedmsg = "(%d)"% ( nowspeed)
                    if lowspeed < nowspeed and highspeed > nowspeed:
                        RJPRINT("    %s %s : %s"%(fanstatus["name"],speedmsg, "[PASS]"))
                    else:
                        RJPRINT("    %s %s : %s"%(fanstatus["name"],speedmsg, "[FAILED]"))
                        caseerror += "name:%s %s 不在转速范围内 [nowspeed: %d low_speed:%d high:%d] \n" % (item_fan.get('name'),fanstatus["name"], nowspeed ,lowspeed,highspeed)
                        ret_t -= 1
                else:
                    RJPRINT("    %s : %s"%(fanstatus["name"], "[FAILED]"))
                    caseerror +=  "name: %s %s  获取转速为空 \n" % (item_fan.get('name'),fanstatus["name"])
                    ret_t -= 1
        RET[RETURN_KEY1] = ret_t
        RET[RETURN_KEY2] = caseerror
    except Exception as e:
        RET[RETURN_KEY1] = -9999
        RET[RETURN_KEY2] = str(e)
        RJPRINT(str(e))
    return RET

# ====================================
# Fan Status Detection
# ====================================
def test_fan():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    log = []
    #sysinfo_showfanmsg_ind = factest_module.get('sysinfo_showfanmsg', 1)
    #if sysinfo_showfanmsg_ind == 1:
    #    log_debug("正在获取风扇信息")
    #    RJPRINT('%s '% "风扇状态获取")
    #    totalfanstatus = []
    #    status.checkFan(totalfanstatus)
    #    for fanstatus in totalfanstatus:
    #        RJPRINT('%s%s: %s'%    (fanstatus["id"], "状态  ", fanstatus["errmsg"]))
    #    RJPRINT('')

    RJPRINT('%s '% "风扇转速设置")
    ret = fan_check1(fanloc, fanlevel, log)
    if ret == 0:
        RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    else:
        RET[RETURN_KEY1] = ret
        RET[RETURN_KEY2] = log
    return RET


def M6510_check(fanlevelcheck):
    RET = {"status" : "", "printmsg":"","errmsg" : ""}
    errcnt = 0
    failcnt = 0
    printmsg = ""
    speedmsg = ""
    errmsg = ""
    
    fanlevel = fanlevelcheck.get("fanlevel")
    level_loc = fanlevelcheck.get("level_loc")
    fanloc = fanlevelcheck.get("fanloc")
    critical_speed = fanlevelcheck.get("critical_speed")
    sleep_time = fanlevelcheck.get("sleep")
    speed_read_times = fanlevelcheck.get("speed_read_times")
    
    try:
        for level in fanlevel:
            tips = level.get("tips")
            fan_level = level.get("level")
            lowspeed = level.get("low_speed")
            highspeed = level.get("high_speed")
            strtmp = "风扇转速等级: 【%s】 写入cpld值:0x%02x  阈值: [%d , %d]\n"% (tips, fan_level,lowspeed,highspeed)
            log_debug(strtmp)
            errmsg += strtmp
            printmsg += strtmp

            write_sysfs_value(level_loc, "0x%02x"% fan_level )
            ret_val = get_sysfs_value(level_loc)
            log_debug("写入的值为%s" % ret_val)
            time.sleep(sleep_time)

            for fan_item in fanloc:
                name = fan_item.get("name")
                speed_loc = fan_item.get("speed_loc")
                nowspeed = test_fan_speed_average(speed_loc,speed_read_times,critical_speed)
                speedmsg = "(%d)"% ( nowspeed)
                log_debug("%s (now: %d low:%d high:%d)"% (name, nowspeed ,lowspeed,highspeed))
                if nowspeed != -1 and nowspeed < critical_speed:
                    if nowspeed >= lowspeed and nowspeed <= highspeed:
                        strtmp = "    %s %s : %s\n"%(name,speedmsg, "[PASS]")
                    else:
                        strtmp = "    %s %s : %s\n"%(name,speedmsg, "[FAILED]")
                        errmsg += "%s 不在转速范围内 [nowspeed: %d low_speed:%d high:%d]\n" % (name,nowspeed ,lowspeed,highspeed)
                        failcnt -= 1
                else:
                    strtmp = "    %s %s : %s" % (name,speedmsg, "[FAILED]")
                    errmsg += "%s 不在转速范围内 [nowspeed: %d low_speed:%d high:%d]\n" % (name,nowspeed ,lowspeed,highspeed)
                    errcnt -= 1
                printmsg += strtmp
        RET["printmsg"] = printmsg
        RET["errmsg"] = errmsg
        if errcnt < 0:
            RET["status"] = "error"
        elif failcnt < 0:
            RET["status"] = "fail"
        else:
            RET["status"] = "pass"
    except Exception as e:
        RET["status"] = "fail"
        RET["printmsg"] = str(e)
        RET["errmsg"] = str(e)
        log_error(e.message)
    return RET

# ====================================
# M6510 Fan Status Detection
# ====================================
def test_M6510_fan():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    fanlevelcheck = TESTCASE.get("fanlevelcheck",None)
    printmsg = ""
    speedmsg = ""
    errmsg = ""

    if fanlevelcheck is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET
    retry = fanlevelcheck.get("retry")          # Retry count

    RJPRINT('%s '% "风扇转速设置")
    for i in range(retry):
        try:
            ret = M6510_check(fanlevelcheck)
            if ret.get("status") == "pass":
                RET[RETURN_KEY1] = 0
                break
            elif ret.get("status") == "error":
                RET[RETURN_KEY1] = -1
                break
            else :
                RET[RETURN_KEY1] = -1
        except Exception as e:
            log = traceback.format_exc()
            log_error(log)
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    RJPRINT(ret.get("printmsg"))
    RET[RETURN_KEY2] = ret.get("errmsg")
    return RET


# ====================================
# CPU memory test
# ====================================
def test_cpumemoryinfo():
    RET = ERROR_RETURN
    cmd = ""
    ret, log = log_os_system("which memtester", 0)
    if len(log):
        cmd = "memtester "
    else:
        RET[RETURN_KEY2] = "no memtester cmd"
        return RET
    for case in TESTCASE["MEMTORY"]["cases"]:
        RJPRINT("测试项: %s" %case["name"])
        log_debug("case: %s   [%s]" % (case["name"] , case["cmd"]))
        os.system(case["cmd"])
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    return RET

ddr_test_result_file = "/tmp/ddr_test_result"
thread_test_ddr = None;

def test_ddr_stress_with_result():
    test_ddr_stress()
    print_temp("后台执行测试，等待100s", False)
    time.sleep(100)
    return test_ddr_stress_result()

def test_ddr_stress():
    global thread_test_ddr
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    ret, log = log_os_system("which stressapptest", 0)
    if len(log):
        if thread_test_ddr != None:
            RET[RETURN_KEY2] = "已有DDR后台执行任务，请首先查看测试结果或终止上次测试任务"
            RJPRINT(RET[RETURN_KEY2])
            return RET
        RET[RETURN_KEY2] = "已启动后台执行"
        cmd = "free -m|grep Mem"
        ret, log = rj_os_system(cmd)
        if "Mem" not in log:
            RJPRINT("Memory info get fail.log=%s, cmd=%s" % (log, cmd))
            RET[RETURN_KEY1] = -1
            return RET
        tmp = log.split()
        mem_test_size = int(tmp[1]) - int(tmp[2]) - 350 # tmp[1]total,tmp[2] used,200 reserve
        '''
             total       used       free     shared    buffers     cached
Mem:          7896       1247       6649         58        188        343
        '''
        cmd = "stressapptest -M %d -m 1 -s 3600" % mem_test_size
        with open(ddr_test_result_file, "w+") as f:
            # thread_test_ddr = subprocess.Popen("stressapptest -M 512 -m 1 -s 86400",shell=True,stdout=subprocess.PIPE)
            thread_test_ddr = subprocess.Popen(cmd, shell=True, stdout=f)
    else:
        RET[RETURN_KEY2] = "no stressapptest cmd"
    RJPRINT(RET[RETURN_KEY2])
    return RET


def test_ddr_stress_stop():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    global thread_test_ddr
    if thread_test_ddr == None:
        RET[RETURN_KEY2] = "未启动后台测试"
        RJPRINT(RET[RETURN_KEY2])
        return RET
    if not makesure("强行结束将无法查看结果，是否继续？[Yes/No]：",echo = True):
        RET[RETURN_KEY2] = "已撤销"
        RJPRINT(RET[RETURN_KEY2])
        return RET
    thread_test_ddr.terminate()

    cmd = "kill -9 %d"%(thread_test_ddr.pid + 1)
    # Regardless of the output
    ret, log = log_os_system(cmd, 0)
    RET[RETURN_KEY2] = "该后台测试已被终止"
    thread_test_ddr = None
    RJPRINT(RET[RETURN_KEY2])
    return RET

def force_abort_ddr_stress():
    log_os_system("ps -ef | grep stressapptest | grep -v grep | awk '{print $2}' | xargs kill -9 ", 0)

def test_ddr_stress_result():
    global thread_test_ddr
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    if thread_test_ddr == None:
       RJPRINT("未启动后台测试，没有测试结果")
       return RET

    ret, log = log_os_system("ps -ef | grep stressapptest | grep -v grep | awk '{print $2}'", 0)
    if len(log):
        RJPRINT("测试还未结束，测试时长60mins, 请稍后查看结果")
        return RET
    thread_test_ddr = None
    bufferSize = 50000
    input = ""
    resuult = ""

    try:
       file = os.open(ddr_test_result_file, os.O_RDONLY | os.O_NONBLOCK);
       input = os.read(file, bufferSize);
       resuult = input
       os.close(file)
    except OSError as err:
        if err.errno == 11:# Zero, with a small probability
            resuult = "没有数据"
            os.close(file)

    if "Status: PASS"  not in resuult:
        RET[RETURN_KEY1] = -1
    else:
        RET[RETURN_KEY1] = 0
    RET[RETURN_KEY2] = resuult
    RJPRINT(RET[RETURN_KEY2])
    return RET

# ====================================
# hard disk test
# ====================================
def test_hard():
    RET = ERROR_RETURN
    cmd = ""
    ret, log = log_os_system("which smartctl", 0)
    if len(log):
        cmd = "smartctl "
    else:
        RET[RETURN_KEY2] = "no smartctl cmd"
        return RET
    for case in TESTCASE["SMARTCTLCMDS"]["cases"]:
        RJPRINT("测试项: %s" %case["name"])
        log_debug("case: %s   [%s]" % (case["name"] , case["cmd"]))
        os.system(case["cmd"])
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    return RET

# ====================================
# Setting a Log Level
# ====================================
def test_log_setlevel(name):
    logger = logging.getLogger()    # initialize logging class
    logger.setLevel(levelNames[name])  # default log level

def test_log_critical():
    test_log_setlevel("CRITICAL")
def test_log_debug():
    test_log_setlevel("DEBUG")
def test_log_error():
    test_log_setlevel("ERROR")
def test_log_info():
    test_log_setlevel("INFO")
def test_log_notset():
    test_log_setlevel("NOTSET")
def test_log_warning():
    test_log_setlevel("WARNING")

# Log output level menu
def test_loginfolevel():
    logger = logging.getLogger()    # initialize logging class
    RJPRINT("当前调试等级为:  %s" % levelNames[logger.level])
    startMenu(3)

# Signal processing: No processing ctrl + N
def sigint_handler(signum, frame):
    global KAOJISTATUS
    KAOJISTATUS = 0
    if ISKAOJI == 1:
        RJPRINT("\n\n已经输入ctrl+c 请等待本轮执行结束")
    else:
        RJPRINT("\n\n不接收ctrl+c退出")

signal.signal(signal.SIGINT, sigint_handler)
signal.signal(signal.SIGHUP, sigint_handler)
signal.signal(signal.SIGTERM, sigint_handler)

# configuration
def test_config():
    if load_CONFIG() == False:
        sys.exit(1)

# ====================================
# Test item: Verify file MD5
# ====================================
def checkFileMD5(filename):
     if not os.path.isfile(filename):
         return
     myhash = hashlib.md5()
     f = file(filename,'rb')
     while True:
         b = f.read(8096)
         if not b :
             break
         myhash.update(b)
     f.close()
     return myhash.hexdigest()

# ====================================
# Test item: Port broadcast
# ====================================
def test_portbroadcast():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for i in range(3):
        try:
            ret, log = test_port()
            if ret:
                RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : log}
                break
            else :
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = log
        except Exception as e:
            log = traceback.format_exc()
            log_error(log)
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    RJPRINT(log)
    return RET

# ====================================
# Test item:prbs
# ====================================
def test_prbs():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for i in range(3):
        try:
            ret, log = test_port_prbs()
            if ret:
                RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : log}
                break
            else :
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = log
        except Exception as e:
            log = traceback.format_exc()
            log_error(log)
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    RJPRINT(log)
    return RET

def test_prbs_new():
    '''PRBS new method to test add 20190411'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret, log = test_ports_prbs_new()
    if ret:
        RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    else :
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = log
    return RET

def test_bmc_channel():
    '''Testing the BMC Path'''
    ip = TESTCASE.get('BMC').get('ip')
    port = TESTCASE.get('BMC').get('port')
    msg = ''
    returncode = False
    import socket
    try:
        sk = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sk.settimeout(10)
        sk.connect((ip,port))
        returncode =  True
    except Exception:
        msg = '到BMC通路失败,请确认'
        returncode = False
    finally:
        sk.close()
    return returncode, msg

# ===================================================================
# Test item:Load CPU side GPIO analog MDIO driver, disable BMC side MDIO
# ===================================================================
def test_modprobe_cpu_gpio_mdio():
    ret, msg = test_bmc_channel()
    if ret is False:
        return ret, msg
    func = 'bmc_log_os_system'
    cmd = "devmem 0x1e6e2090 32 0x087f0009" # disable bmc mdio
    ret = test_bmc_func(func,cmd)
    if ret[RETURN_KEY1] != 0:
        return ret, msg + " disable bmc mdio fail"
    cmd = "modprobe rg_gpio_mdio"
    ret, msg = log_os_system(cmd, 0)
    if ret != 0:
        return ret, msg + " modprobe rg_gpio_mdio fail"
    time.sleep(1)
    return True, ''

# ===================================================================
# Test item: Unmount the GPIO analog MDIO driver on the CPU and enable the MDIO on the BMC
# ===================================================================
def test_rmmod_cpu_gpio_mdio():
    ret, msg = test_bmc_channel()
    if ret is False:
        return ret, msg
    func = 'bmc_log_os_system'
    cmd = "devmem 0x1e6e2090 32 0x087F000D" # enable bmc mdio
    ret = test_bmc_func(func,cmd)
    if ret[RETURN_KEY1] != 0:
        return False, msg + " enable bmc mdio fail"
    cmd = "rmmod rg_gpio_mdio"
    ret, msg = log_os_system(cmd, 0)
    if ret != 0:
        return ret, msg + " rmmod rg_gpio_mdio fail"
    return True, ''

# ===================================================================
# Test item :CPU side MDIO test
# ===================================================================
def test_cpu_gpio_mdio():
        RET = {RETURN_KEY1: 0, RETURN_KEY2: ""}
        errtotal = 0
        MDIO_dev_dict = {
            "BMC-54616 ": ["11"],
            "MGMT-54616": ["18"],
            "5387      ": ["00", "01", "02", "03", "04", "05", "06", "07"],
        }

        for dev in MDIO_dev_dict.keys():
            check_log = ""
            dev_errtotal = 0
            for i in MDIO_dev_dict[dev]:
                cmd = "cat /sys/bus/mdio_bus/devices/gpio-0:%s/hw_test*" % i
                ret, log = log_os_system(cmd, 0)
                if "reg" in log:
                    check_log += i + ": PASS\n"
                else:
                    check_log += i + ": FAILD\n"
                    dev_errtotal -= 1
            errtotal += dev_errtotal
            if dev_errtotal < 0:
                log_debug(dev + " : FAILED")
                log_debug(check_log)  # Prints detailed error information
            else:
                log_debug(dev + " : PASS")

        if errtotal < 0:
            RET[RETURN_KEY1] = -1
        return RET

# ===================================================================
# Test item :CPU side MDIO pressure test
# ===================================================================
def cpu_test_MDIO_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 :""}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       log_debug("\n\n第 %d/%d 次测试"%(i+1, test_times))
       RET1 = test_cpu_gpio_mdio()
       totalerr += RET1[RETURN_KEY1]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

# ====================================
# Test item: port sending and receiving frames
# ====================================
def test_portframe():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for i in range(3):
        try:
            ret, log = test_port_portframe()
            if ret:
                RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : log}
                break
            else :
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = log
        except Exception as e:
            log = traceback.format_exc()
            log_error(log)
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    RJPRINT(log)
    return RET


def get_raw_input():
    ret=""
    fd=sys.stdin.fileno()
    old_ttyinfo=termios.tcgetattr(fd)
    new_ttyinfo=old_ttyinfo[:]
    new_ttyinfo[3] &= ~termios.ICANON
    new_ttyinfo[3] &= ~termios.ECHO
    try:
        termios.tcsetattr(fd,termios.TCSANOW,new_ttyinfo)
        ret=raw_input("")
    except Exception as e:
        print (e)
    finally:
        termios.tcsetattr(fd,termios.TCSANOW,old_ttyinfo)
    return ret


def test_port_portframe():
    '''Port frame'''
    framenum = 10000
    porttest = PortTest()
    len_t = len(porttest.bcm_ports)
    upports = []
    ret_t = 0
    errt_t = []
    testerror ={}
    caseerror=[]
    testerror["name"] = "端口收发帧"
    successport=[]
    updownerrport=[]
    errorport = []
    try:
        # All values UP Port PRBS
        for i in range(len_t):
            status = porttest.get_port_status(i + 1)
            if status == "up":
                upports.append(i + 1)
            else:
                updownerrport.append(i+1)
        if len(updownerrport) > 0:
            ret_t -= 1
            pass
        else:
            porttest.init_port_cpu()
            porttest.clear_port_packets()
            for i in range(len(porttest.bcm_ports)):
                if (i + 1) in upports :
                    porttest.start_send_port_packets(i + 1, framenum, 1024)
                    log_debug("%d:正在发包"%(i+1))
            time.sleep(5)
            for i in range(len(porttest.bcm_ports)):
                if (i + 1) in upports :
                    ret, log = porttest.check_port_packets(i + 1, framenum, "rx")
                    log_debug(ret)
                    if ret == True:
                        successport.append(i + 1)
                    else:
                        errorport.append(i + 1)
                        ret_t -= 1
                        caseerror.append({"name":"端口%d"%(i + 1), "error":"端口收发帧失败"})
                        log_debug(log)
                else:
                    ret_t -= 1
                    caseerror.append({"name":"端口%d"%(i + 1), "error":"up/down状态异常"})
                    updownerrport.append(i+1)
    except Exception as e:
        msg = traceback.format_exc()
        log_error(msg)
        ret_t  = -1
        return False , msg
    finally:
        porttest.reset_port_cpu()
    result_str = ''
    result_str += print_to_str(successport, "OK")
    result_str += print_to_str(updownerrport, "up/down error")
    result_str += print_to_str(errorport, "failed")
    testerror['errmsg'] = caseerror
    errt_t.append(testerror)
    if ret_t < 0:
        return False , result_str
    return True , result_str


def test_ports_prbs_new():
    '''port prbs'''

    result_t = []
    testerror1 = {}
    testerror1["name"] = "PRBS测试(phy到mac)"
    testerror2 = {}
    testerror2["name"] = "PRBS测试(mac到phy)"
    testerror3 = {}
    testerror3["name"] = "PRBS测试(phy到line)"
    retrytime = 0
    total_err = 0
    pr = None
    val_ber  = TESTCASE.get("PRBS").get("prbsber", None) # 1.0e-8
    totalretrys = TESTCASE.get("PRBS").get("retrytimes", None) # 1.0e-8
    # print val_ber
    macprbsresult = {"success":[], "error":[]}
    sysprbsresult = {"success":[], "error":[]}
    lineprbsresult = {"success":[], "error":[]}

    if val_ber is not None:
        pr = PortPrbsTest(val_ber)
    else:
        pr = PortPrbsTest()
    for i in range(len(pr.bcm_ports)):
        macprbsresult.get('error').append((i+1))
        sysprbsresult.get('error').append((i+1))
        lineprbsresult.get('error').append((i+1))

    while len(macprbsresult.get('error'))> 0 or  len(sysprbsresult.get('error')) > 0 or len(lineprbsresult.get('error'))> 0:
        if retrytime >= totalretrys:
            break
        else:
            ret,log = pr.clear_port_prbs()
            if ret == False:
                raise Exception("prbs清除 %s" % log)
            ret, log = pr.init_port_prbs()
            if  ret == False:
                raise Exception("prbs初始化失败 %s" % log)

            caseerror=[]
            for i in range(len(pr.bcm_ports)):
                ret, result = pr.get_port_prbs_result("mac", i + 1)
                if ret == True:
                    if (i+1) in macprbsresult.get('error'):
                        macprbsresult.get('error').remove((i+1))
                        macprbsresult.get('success').append((i+1))
                else:
                    if retrytime == (totalretrys -1):
                        total_err -= 1
                        caseerror.append({"name":"端口%03d"%(i + 1), "error":str(result)})
                        log_debug("mac 端口%03d error:%s" % ((i + 1), str(result)))
            if retrytime == (totalretrys -1):
                testerror1['errmsg'] = caseerror


            caseerror=[]
            for i in range(len(pr.bcm_ports)):
                ret, result = pr.get_port_prbs_result("sys", i + 1)
                if ret == True:
                    if (i+1) in sysprbsresult.get('error'):
                        sysprbsresult.get('error').remove((i+1))
                        sysprbsresult.get('success').append((i+1))
                else:
                    if retrytime == (totalretrys -1):
                        total_err -= 1
                        caseerror.append({"name":"端口%03d"%(i + 1), "error":str(result)})
                        log_debug("sys 端口%03d error:%s" % ((i + 1), str(result)))
            if retrytime == (totalretrys -1):
                testerror2['errmsg'] = caseerror


            caseerror=[]
            for i in range(len(pr.bcm_ports)):
                ret, result = pr.get_port_prbs_result("line", i + 1)
                if ret == True:
                    if (i+1) in lineprbsresult.get('error'):
                        lineprbsresult.get('error').remove((i+1))
                        lineprbsresult.get('success').append((i+1))
                else:
                    if retrytime == (totalretrys -1):
                        total_err -= 1
                        caseerror.append({"name":"端口%03d"%(i + 1), "error":str(result)})
                        log_debug("line 端口%03d error:%s" % ((i + 1), str(result)))
            if retrytime == (totalretrys -1):
                testerror3['errmsg'] = caseerror

            ret,log = pr.clear_port_prbs()
            if ret == False:
                raise Exception("prbs清除 %s" % log)
            time.sleep(10)

            if retrytime == (totalretrys -1):
                result_t.append(testerror1)
                result_t.append(testerror2)
                result_t.append(testerror3)
        retrytime += 1

    if len(macprbsresult.get('error')) == 0:
        RJPRINT("mac  prbs测试结果: PASS")
    else:
        RJPRINT("mac  prbs测试结果: FAIL")
        port_totalprint(macprbsresult.get('error'),"failed")

    if len(sysprbsresult.get('error')) == 0:
        RJPRINT("sys  prbs测试结果: PASS")
    else:
        RJPRINT("sys  prbs测试结果: FAIL")
        port_totalprint(sysprbsresult.get('error'),"failed")

    if len(lineprbsresult.get('error')) == 0:
        RJPRINT("line prbs测试结果: PASS")
    else:
        RJPRINT("line prbs测试结果: FAIL")
        port_totalprint(lineprbsresult.get('error'),"failed")

    if total_err < 0:
        return False , result_t
    return True ,""

# port prbs
def test_port_prbs():
    ret_t = 0
    # Take port
    porttest = PortTest()
    len_t = len(porttest.bcm_ports)
    errmsg = []
    upports = []
    successport=[]
    updownerrport=[]
    errorport = []
    try:
        # Obtain the UP/DOWN status of the port
        for i in range(len_t):
            status = porttest.get_port_status(i + 1)
            if status == "up":
                upports.append(i + 1)
            else:
                updownerrport.append(i+1)
        log_debug(",".join(str(index) for index in upports))
        if len(updownerrport) > 0:
            ret_t -= 1
            pass
        else:
            porttest.init_port_prbs()
            for i in range(len_t):
                porttest.set_port_prbs(i + 1, 1)
            time.sleep(5)
            # get values
            for i in range(len_t):
                log_debug("端口prbs校验:%d"% (i + 1))
                ret  = porttest.get_port_prbs_result(i + 1)
                if ret == 0:
                    successport.append(i + 1)
                else:
                    errorport.append(i + 1)
                    ret_t -= 1
            # All values UP Port PRBS
    except Exception as e:
        msg = traceback.format_exc()
        log_error(msg)
        ret_t  = -1
        return False , msg
    finally:
        for i in range(len_t):
            porttest.set_port_prbs(i + 1, 0)
        porttest.reset_port_prbs()
        time.sleep(5)
    result_str = ''
    result_str += print_to_str(successport, "OK")
    result_str += print_to_str(updownerrport, "up/down error")
    result_str += print_to_str(errorport, "failed")
    if ret_t < 0:
        return False , result_str
    return True ,result_str


# Port broadcast test
def test_port():
    # errt_t = []
    ret_t = 0
    porttest = PortTest()
    # Take port
    len_t = len(porttest.bcm_ports)

    successport=[]
    updownerrport=[]
    errorport = []
    upports = []
    try:
        # Obtain the UP/DOWN status of the port
        for i in range(len_t):
            status = porttest.get_port_status(i + 1)
            if status == "up":
                upports.append(i + 1)
            else:
                updownerrport.append(i+1)
        if len(updownerrport) > 0:
            ret_t -= 1
            pass
        else:
            # All ports must be up before testing, and broadcast packets are sent through the first port
            log_debug("发送广播报文...")
            ret = porttest.start_send_port_packets(1, 10000)
            # Waiting time
            time.sleep(GRTD_BROADCAST_RETRY_SLEEP_TIME)
            log_debug("等待结果......")
            for i in range(len_t):
                ret , fcs = porttest.get_port_fcs_status(i + 1)
                if ret == True and fcs[0] == 0 and fcs[1] == 0:
                    successport.append(i + 1)
                else:
                    ret_t -= 1
                    errorport.append(i + 1)
                    log_debug("error: 端口%d  发送校验：%d  接收校验 %d" %( (i + 1), fcs[0], fcs[1]) )
    except Exception as e:
        msg = traceback.format_exc()
        log_error(msg)
        ret_t  = -1
        return False , msg
    finally:
        # Close the radio
        sta = porttest.stop_send_port_packets()
        time.sleep(5)
    result_str = ''
    result_str += print_to_str(successport, "OK")
    result_str += print_to_str(updownerrport, "up/down error")
    result_str += print_to_str(errorport, "failed")
    if ret_t < 0:
        return False , result_str
    return True ,result_str

def startFanctrol():
    if STARTMODULE['fancontrol'] == 1:
        cmd = "nohup fancontrol.py start >/dev/null 2>&1 &"
        rets = getPid("fancontrol.py")
        if len(rets) == 0:
            os.system(cmd)


def getUsbLocation():
    dir = "/sys/block/"
    spect = "sd"
    usbpath = ""
    result = searchDirByName(spect, dir)
    if len(result) <= 0:
        return False
    for item in result:
        with open(os.path.join(item, "removable"), 'r') as fd:
            value = fd.read()
            if value.strip() == "1":  # USB flash drive is found
                usbpath = item
                break
    if usbpath == "":  # No flash drive was found
        log_debug("no usb found")
        return False, usbpath
    return True, usbpath

def searchDirByName(name, dir):
    result = []
    try:
        files = os.listdir(dir)
        for file in files:
            if name in file:
                result.append(os.path.join(dir, file))
    except Exception as e:
        pass
    return result



def getusbinfo():
    ret, path = getUsbLocation()
    if ret == False:
        return False, "not usb exists"
    str = os.path.join(path, "size")
    ret, value = getfilevalue(str)
    if ret == True:
        return True, {"id": os.path.basename(path), "size": float(value) * 512 / 1024 / 1024 / 1024}
    else:
        return False, "Err"


def stopFanctrol():
    '''Disable the fan timing service'''
    if STARTMODULE['fancontrol'] == 1:
        rets = getPid("fancontrol.py")  #
        for ret in rets:
            cmd = "kill "+ ret
            os.system(cmd)
        time.sleep(3)
        return True


# ====================================
# Test item: Check the CPLD version
# ====================================
def test_cpldversion():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret, log = log_os_system("which grtd_test.py", 0)
    if len(log):
        cmd = "cmd find "
    else:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "    [FAILED]:no grtd_test.py found"
        RJPRINT(RET[RETURN_KEY2])
        return RET
    ret, log = log_os_system("grtd_test.py sys cpld_version", 0)
    log_debug(log)
    if ret or ("Error" in log ):
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = log
        RJPRINT("    [FAILED]:CPLD版本读取失败")
    else:
        RJPRINT(log)
    return RET


def test_cpu_stress_stop():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    global cpu_stress_test
    if cpu_stress_test:
        ret, log = log_os_system("ps -ef | grep \"stress -c 4\" | grep -v grep | awk '{print $2}' | xargs kill -9 ", 0)
        if ret or len(log):
            RET[RETURN_KEY2] = "取消压力测试异常:%s"%log
        else:
             RET[RETURN_KEY2] = "该后台测试已被终止"
             cpu_stress_test = False
    else:
        RET[RETURN_KEY2] = "未启动后台测试"
    RJPRINT(RET[RETURN_KEY2])
    return RET

# ====================================
# Test item :USB test
# ====================================
def test_usb():
    ret , info = getusbinfo();
    if ret == True:
        RJPRINT("%s %s"%("-"*6,"-"*20))
        RJPRINT("{id}    {size}G".format(**info))
        return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    else:
        log_debug(info)
        RJPRINT("读取USB信息失败")
    return {RETURN_KEY1 : -1,  RETURN_KEY2 : "读取USB信息失败"}



def test_usb2(test_times = 1):
    totalerr = 0
    errmsg = ""
    RET = test_usb()
    if RET[RETURN_KEY1] == -1:
       return RET
    # print_clean()# Prevents printing the contents of test_USB
    ret,info = getusbinfo()
    usb_dev = info["id"]
    cmd = "fdisk -l |grep '%s'|grep 'Disk' -v|sort -k4 |tail -n1|awk '{print $1;}'"%usb_dev
    ret, usb_disk = log_os_system(cmd,0)
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    # Generate test files
    ret, log = log_os_system("dd if=/dev/random of=/tmp/file.txt bs=1M count=10", 0)
    ret, log = log_os_system("mkdir /tmp/usb_stress_test && mount  %s /tmp/usb_stress_test/"%usb_disk, 0)
    if ret != 0 or len(log) > 0:
        RJPRINT(log)
        RJPRINT("挂载U盘   FAILED")
        totalerr -= 1
    else:
        for i in range(0, test_times):
            if test_times != 1:
                RJPRINT("\n\n第 %d/%d 次测试"%(i+1, test_times))

            cmd = 'cp -rf /tmp/file.txt /tmp/usb_stress_test/file.txt'
            ret, log = log_os_system(cmd,0)
            if ret != 0 or len(log) > 0:
                RJPRINT( log)
                RJPRINT( "拷贝文件   FAILED")
                totalerr -= 1
            else:
                RJPRINT( "拷贝文件   PASS")

            cmd = 'diff /tmp/file.txt /tmp/usb_stress_test/file.txt'
            ret, log = log_os_system(cmd,0)
            if ret != 0 or len(log) > 0:
                RJPRINT( "校验文件   FAILED")
                totalerr -= 1
            else:
                RJPRINT( "校验文件   PASS")

            cmd = 'rm -rf /tmp/usb_stress_test/file.txt'
            ret, log = log_os_system(cmd,0)
            if ret != 0 or len(log) > 0:
                RJPRINT( log)
                RJPRINT( "删除文件   FAILED")
                totalerr -= 1
            else:
                RJPRINT( "删除文件   PASS")

    ret, log = log_os_system("umount /tmp/usb_stress_test", 0)
    ret, log = log_os_system("rm /tmp/usb_stress_test -r", 0)
    ret, log = log_os_system("rm /tmp/file.txt", 0)
    if totalerr < 0:
        RET[RETURN_KEY1] = -1
    return RET

def test_usb_stress():
    return test_usb2(10)


def test_bmc_setmac():
    while bmc_setmac() == False:
        pass
    return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}

def test_e2_setmac():
    while fac_board_setmac() == False:
        pass
    return {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}

# ====================================
# Test item: fan SETMAC
# ====================================
def test_fan_setmac():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    try:
        stopFanctrol()
        if(fac_fans_setmac() == False):
            totalerr -= 1
    except Exception as e:
        RJPRINTERR(e)
        totalerr -= 1
    finally:
        startFanctrol()
    RET[RETURN_KEY1] = totalerr
    return RET

pidfile = 0
############################################################################################
##  File lock
############################################################################################
def ApplicationInstance():
    global pidfile
    pidfile = open(os.path.realpath(__file__), "r")
    try:
        fcntl.flock(pidfile, fcntl.LOCK_EX | fcntl.LOCK_NB) #创建一个排他锁,并且所被锁住其他进程不会阻塞
    except:
        RJPRINT("已有一个程序在运行...."  )
        sys.exit(1)

def fac_init_setmac():
    if getsyseeprombyId(TLV_CODE_PRODUCT_NAME) == None or getsyseeprombyId(TLV_CODE_SERIAL_NUMBER) == None or\
       getsyseeprombyId(TLV_CODE_MAC_BASE) == None or getsyseeprombyId(TLV_CODE_DEVICE_VERSION) == None :
        log_debug("需要重新setmac")
        return False
    return True

def fac_sensors_kill():
    cmdstr = "docker exec pmon  ps -ef | grep sensord | grep -v grep | cut -c 9-15 | xargs docker exec pmon kill -s 9"
    try:
        log_debug("正在停止sensord服务")
        ret, status = rj_os_system(cmdstr)
        if ret != 0:
            RJPRINT("停止sensord服务异常，请确认")
    except:
        pass

def fac_init():
    global DIAGTEST
    firmware_check()         # firmware testing
    if DIAGTEST == False: # Enter the menu setMac by ATE itself to maintain consistency
        fac_setmac_check()   # setmac check
    waitForSDK()             # wait SDK
    closeProtocol()          # Close the deal
    if FACTESTMODULE.get("sensord",0)==1: # sensord Background processes
        fac_sensors_kill()
    if FACTESTMODULE.get("firmware_init",0)==1: # Firmware initialization
        fac_firmware_init()
    if FACTESTMODULE.get("usb0_config",0)==1 and bmc_presence_check(): # USB0 IP configuration
        ret_t = usb0_init()
        if ret_t == False:
            RJPRINT("配置SONIC端USB网口失败，请手动配置")

    RJPRINT("")

def fac_init_check_ipmi():
    if not os.path.exists("/dev/ipmi0"):
        ret, log = log_os_system("rmmod ipmi_watchdog; rmmod ipmi_si; modprobe ipmi_msghandler; modprobe ipmi_si trydefaults=1 tryacpi=1;modprobe ipmi_devintf", 0)
        if not os.path.exists("/dev/ipmi0"):
            msg ="     无/dev/ipmi0设备,请检查"
            RJPRINT(msg)
            return False
    return True

def fac_setmac_check():
    # Check the CARD ID
    if fac_init_cardidcheck() == False:
        RJPRINTERR("\n\n板卡ID检测失败，请确认!\n\n")
        sys.exit(-1);

    # setmac check
    if fac_init_setmac() is False:
        RJPRINT("未检测到SETMAC信息, 请先进入系统配置执行E2SETMAC")

def io_rd(reg_addr, len =1):
    '''io read'''
    try:
        regaddr = 0
        if type(reg_addr) == int:
            regaddr = reg_addr
        else:
            regaddr = int(reg_addr, 16)
        devfile = "/dev/port"
        fd = os.open(devfile, os.O_RDWR|os.O_CREAT)
        os.lseek(fd, regaddr, os.SEEK_SET)
        str = os.read(fd, len)
        return "".join(["%02x"% ord(item) for item in str])
    except ValueError:
        return None
    except Exception as e:
        print (e)
        return None
    finally:
        os.close(fd)
    return None


def io_wr(reg_addr, reg_data):
    '''io write'''
    try:
        regdata  = 0
        regaddr  = 0
        if type(reg_addr) == int:
            regaddr = reg_addr
        else:
            regaddr = int(reg_addr, 16)
        if type(reg_data) == int:
            regdata = reg_data
        else:
            regdata = int(reg_data, 16)
        devfile = "/dev/port"
        fd = os.open(devfile, os.O_RDWR|os.O_CREAT)
        os.lseek(fd, regaddr, os.SEEK_SET)
        ret = os.write(fd, chr(regdata))
        return True
    except ValueError as e:
        print (e)
        return False
    except Exception as e:
        print (e)
        return False
    finally:
        os.close(fd)
    return False

def getBMCMAC():
    cmd = "ipmitool lan print 1 | grep 'MAC Address'"
    ret , status = rj_os_system(cmd)
    if ret == 0:
        return status[status.index(":") + 1:len(status)].strip().upper()
    else:
        RJPRINTERR("获取BMC MAC失败[%s]" % status)
        return None

def checkkallsyms(name):
    symsisexistcmd = "cat /proc/kallsyms | grep %s | wc -l" % name
    status, output = log_os_system(symsisexistcmd, 0)
    # System execution error
    if status:
        return False
    if output.isdigit() and int(output) > 0:    # symbol
        return True
    else:
        return False

def checksignaldriver(name):
    modisexistcmd = "lsmod | grep %s | wc -l" % name
    status, output = log_os_system(modisexistcmd, 0)
    # System execution error
    if status:
        return False
    if output.isdigit() and int(output) > 0:
        return True
    else:
        return False

def adddriver(name, delay):
    cmd = "modprobe %s" % name
    if checksignaldriver(name) != True:
        log_os_system(cmd, 0)
        if delay != 0:
            time.sleep(delay)
            log_debug('%s sleep %d second!' %(name,delay))

def removedriver(name, delay):
    realname = name.lstrip().split(" ")[0];
    cmd = "rmmod -f %s" % realname
    if checksignaldriver(realname):
        log_os_system(cmd, 0)
        if delay != 0:
            time.sleep(delay)
            log_debug('%s sleep %d second!' %(name,delay))
'''
# Select the packet sending mode during the rate switching test of the management port
def test_mgmt_packet_send(issonic = True,packet_count = 2000):
    if issonic:
        sendp(Ether(dst='FF:FF:FF:FF:FF:FF',src='00:00:00:00:00:03')/ARP(op=1), iface='eth0', count=packet_count)
    else:
        cmd = "ssh root@240.1.1.1 'export %s && ftg100_tool tx %d'"%(BMC_PATH,packet_count)
        ret, log = password_command(cmd,OPENBMC_PASSWORD)
        if "packet" not in log:
            raise Exception,"发送数据包出错:\n"+log
        time.sleep(3)
'''

def print_to_str(arr, tips):
    return_str = ''
    alias = TESTCASE.get('port_alias',None)
    if len(arr) <= 0:
        return_str += "\n"
        return return_str
    return_str += "%-20s" % tips
    for index in range(len(arr)):
        if alias is not None:
            return_str += ("%s" % alias.get(arr[index],"unkowned"))
        else:
            return_str += ("%03d" % arr[index])
        return_str +=(" ")  # Add a space
        if (index + 1) % 8 == 0:
            return_str += "\n"
            return_str += (" " * 20)
    return_str += "\n"
    return return_str

def port_totalprint(arr, tips):
    '''Print out in format (with transcoding)'''
    alias = TESTCASE.get('port_alias',None)
    if len(arr) <= 0:
        return
    RJPRINTLINE("%-20s" % tips)
    for index in range(len(arr)):
        if alias is not None:
            RJPRINTLINE("%s" % alias.get(arr[index],"unkowned"))
        else:
            RJPRINTLINE("%03d" % arr[index])
        if (index + 1) % 8 == 0:
            RJPRINT("")
            RJPRINTLINE(" " * 20)
    RJPRINT("")

def getmgmtrx():
    mgmtrxloc = "/eth0/statistics/rx_packets"
    value_t = get_pmc_register(mgmtrxloc)
    return int(value_t,10)


# ==============================================
# MGMT Network Port Test
# ==============================================
def test_mgmt_speed(speed , bmctest ):
    MGMT_LPBK_CMD  = ("ethtool -s eth0 speed %d duplex full autoneg on" % speed)    # MGMT Command for setting the self-loop network port
    MGMT_LINK_CHK_CMD  = "mii-tool eth0"    # MGMT Command to check whether the self-loophead connection of the network port is successful
    LINK_CHK_KEY = "link ok"    # MGMT Log Indicates the keyword for checking whether the self-loophead connection of the network port is successful
    MGMT_LPBK_1000M_EN_CMD  = "echo 1 > /sys/class/lpbk_1000m/enable"    # Enable the MGMT self-ring network port configuration:1000M
    MGMT_LPBK_1000M_DIS_CMD = "echo 0 > /sys/class/lpbk_1000m/enable"    # Enable the MGMT self-ring network port configuration:1000M
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    try:
        PACKET_NUM = TESTCASE.get('mgmt').get("packetcount")
        retrytimes = TESTCASE.get('mgmt').get("retrytimes",5)
        # MGMT:Set the self-loop network port
        if speed == 1000:
            ret, log = log_os_system(MGMT_LPBK_1000M_EN_CMD, 0)
            if ret != 0:
                RJPRINT("1000m: %s 命令运行错误   [Fail]" % MGMT_LPBK_1000M_EN_CMD)
                RET = {RETURN_KEY1 : -1, RETURN_KEY2 : "Error: 1000M自环网口设置命令出错\n"}
                return RET
        else:
            ret, log = log_os_system(MGMT_LPBK_CMD, 0)
            if ret != 0:
                RJPRINT("%dM: %s 命令运行错误   [Fail]" % (speed,MGMT_LPBK_CMD))
                RET = {RETURN_KEY1 : -1, RETURN_KEY2 : ("Error: %dM自环网口设置命令出错\n" % speed)}
                return RET
        # MGMT Verify that the self-loophead connection of the network port is successful
        time.sleep(1)
        for i in range(10):
            ret, log = log_os_system(MGMT_LINK_CHK_CMD, 0)
            if ret != 0:
                RJPRINT("%dM: %s 命令运行错误   [Fail]" % (speed,MGMT_LINK_CHK_CMD))
                RET = {RETURN_KEY1 : -1, RETURN_KEY2 : ("Error: %dM自环头连接成功命令出错\n" % speed)}
                return RET
            if LINK_CHK_KEY not in log:
                time.sleep(1)
                continue
            # MGMT After the loop head is successfully connected to the UP state, packets are sent and the port sending and receiving information is obtained
            RJPRINT("MGMT测试 speed:%dM" % speed)
            # X86 receiving and sending test
            for i in range(retrytimes):
                message = ''
                totalerr = 0
                RXstart,TXstart = get_frame_count()
                test_mgmt_packet_send(packet_count = PACKET_NUM)
                RXend,TXend = get_frame_count()
                Tx_total = TXend - TXstart
                Rx_total = RXend - RXstart
                if Rx_total >= PACKET_NUM:    # Consider that other processes may send packets to the MGMT port
                    message += "X86端确认: MGMT网口测试  [OK]\n"
                else:
                    totalerr -= 1
                    message += "X86端确认: [Fail](packets=%d Tx_total=%d Rx_total=%d)\n" % (PACKET_NUM, Tx_total, Rx_total)
                # Receiving and sending packets test on the BMC
                if bmctest == True:
                    ret, log = bmc_test_mgmt_speed()
                    totalerr += ret
                    message += log
                RET[RETURN_KEY2] += message
                if totalerr == 0:
                    RJPRINT(message)
                    return RET
            RJPRINT(message)
            RET[RETURN_KEY1] = -1
            return RET
        RJPRINT("%dM: MGMT自环头连接 up 失败  [Fail]" % speed)
        RET = {RETURN_KEY1 : -1, RETURN_KEY2 : ("Fail: %dM自环头连接 up 失败\n" % speed)}
    except Exception as e:
        RJPRINT(str(e))
        RET[RETURN_KEY1] = -1
    finally:
        if speed == 1000:
            log_os_system(MGMT_LPBK_1000M_DIS_CMD, 0)
    return RET

def bmc_test_mgmt_speed():
    # Receiving and sending packets test on the BMC
    totalerr = 0
    message = ''
    bmccheck = TESTCASE.get('mgmt').get("bmccheck")
    try:
        ret = test_bmc_func(bmccheck.get('case'), bmccheck.get('param'))
        if ret.get(RETURN_KEY1) == 0:
            message += "BMC端确认: MGMT网口测试  [OK]"
        else:
            totalerr -= 1
            message += "BMC端确认: [Fail]%s \n" % ret.get(RETURN_KEY2)

    except Exception as e:
        message += str(e) + "\n"
        totalerr -= 1
    finally:
        return totalerr, message

def test_mgmt_loopback_new_noconfirm():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret_t = test_mgmt_loop_new_real('10M')
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_loop_new_real('100M')
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_loop_new_real('1000M')
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)
    return RET

def test_mgmt_loopback_new():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret = makesure("  !!!请确保登入的是串口终端!!!  自环工装是否插入[Yes/no]：", echo = 1)
    if ret != True:
        RET = {RETURN_KEY1 : -1, RETURN_KEY2 : "Fail"}
        return RET

    return test_mgmt_loopback_new_noconfirm()

def test_mgmt_packet_send(iface1='eth0', packet_count = 2000):
    sendp(Ether(dst='FF:FF:FF:FF:FF:FF',src='00:00:00:00:00:03')/ARP(op=1), iface=iface1, count=packet_count,verbose=0)

def test_check_cpu_loopback(iface, packet_count, pktthread):
    '''
      iface: such as eth0
      packet_count: 2000
      pktthread: 1.0
    '''
    RXstart,TXstart = get_frame_count(iface)
    test_mgmt_packet_send(iface1 = iface, packet_count = packet_count) # Contract first
    RXend,TXend = get_frame_count(iface)
    Tx_total = TXend - TXstart
    Rx_total = RXend - RXstart
    log_debug("发送帧计数：%d，接收帧计数：%d"%(Tx_total,Rx_total))
    packet_rate = float(Rx_total)/float(Tx_total)
    if Rx_total >= packet_count  and Tx_total >= packet_count and packet_rate >= pktthread:
         return True,""
    return False, "发送帧计数：%d，接收帧计数：%d"%(Tx_total,Rx_total)


def get_frame_count(iface ='eth0'):
    txcmd = "ifconfig %s |grep -E 'TX packets'" % iface
    rxcmd = "ifconfig %s |grep -E 'RX packets'" % iface
    ret, txlog = log_os_system(txcmd, 0)
    ret, rxlog = log_os_system(rxcmd, 0)
    tx = re.findall(r"\d+\.?\d*",txlog)[0]
    rx = re.findall(r"\d+\.?\d*",rxlog)[0]
    return int(rx), int(tx)

def test_mgmt_loop_new_real(speed):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    http = TESTCASE.get('mgmt').get(speed)
    http2 = TESTCASE.get('mgmt').get('clear')
    bcmcheckk = TESTCASE.get('mgmt').get('bmccheck')
    iface = TESTCASE.get('mgmt').get('iface')
    pk_count = TESTCASE.get('mgmt').get('packetcount')
    pktthread = TESTCASE.get('mgmt').get('pktpassthread')
    retrytimes = TESTCASE.get('mgmt').get('retrytimes', 1)

    RJPRINT("MGMT测试 speed:%s" % speed)
    RJPRINT("----------------------")
    for i in range(retrytimes):
        totalerr = 0
        errmsg = ""
        printmsg = ""
        try:
            ret = test_bmc_func(http2.get('case'),http2.get('param'))
            if ret is None:
                raise Exception('SONiC reset失败')
            time.sleep(0.5)
            ret = test_bmc_func(http.get('case'),http.get('param'))
            if ret is None:
                raise Exception('SONiC设置回环失败')
            time.sleep(0.5)
            if ret.get(RETURN_KEY1) != 0:
                totalerr += ret.get(RETURN_KEY1)
                errmsg  += ret.get(RETURN_KEY2)
                printmsg += errmsg + ' \n'
            else:
                val_check, errmsg = test_check_cpu_loopback(iface, pk_count, pktthread)
                printmsg += "SONiC端确认:"
                if val_check == True:
                    printmsg += " [ok] \n"
                else:
                    printmsg += "[failed] %s \n" % errmsg
                    if i  < (retrytimes -1):
                        continue
                printmsg += "BMC端确认:"
                ret = test_bmc_func(bcmcheckk.get('case'),bcmcheckk.get('param'))
                if ret is None:
                    raise Exception('BMC端确认失败')
                if ret.get(RETURN_KEY1) == 0:
                    printmsg +="[ok] \n"
                else:
                    totalerr += ret.get(RETURN_KEY1)
                    errmsg  += ret.get(RETURN_KEY2)
                    printmsg += "[failed] %s \n" % ret.get(RETURN_KEY2)
                    if i  < (retrytimes -1):
                        continue
        except Exception as e:
            totalerr = -998
            RET[RETURN_KEY1] = -999
            RET[RETURN_KEY2] += str(e)
            printmsg += str(e) + ' \n'
        finally:
            ret = test_bmc_func(http2.get('case'),http2.get('param'))
            time.sleep(0.5)
        if totalerr >=0:
            break
    RJPRINT(printmsg)
    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

# ==============================================
# MGMT Network Port Test
# ==============================================
def test_mgmt():
    bmctest = False
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}

    # MGMT Self-loop fixture insertion confirmation
    ret = makesure("  !!!请确保登入的是串口终端!!!  自环工装是否插入[Yes/no]：", echo = 1)
    if ret != True:
        RET = {RETURN_KEY1 : -1, RETURN_KEY2 : "Fail"}
        return RET
    if FACTESTMODULE.__contains__("mgmttest") and FACTESTMODULE['mgmttest'] == 1:
        if checkkallsyms("phy_backup_data") != True:
            removedriver("igb",1)
            adddriver("igb",2)
            log_os_system("ifconfig eth0 up", 0)
        adddriver("lpbk_1000m",1)
    if bmc_presence_check():
        bmctest = True
    ret_t = test_mgmt_speed(10 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_speed(100 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_speed(1000 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    time.sleep(5)
    return RET


# ==============================================
# MGMT Network port loop test
# ==============================================
def test_mgmt_loop():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    bmctest = True
    if FACTESTMODULE.__contains__("mgmttest") and FACTESTMODULE['mgmttest'] == 1:
        if checkkallsyms("phy_backup_data") != True:
            removedriver("igb",1)
            adddriver("igb",2)
            log_os_system("ifconfig eth0 up", 0)
        adddriver("lpbk_1000m",1)
    if bmc_presence_check():
        status, msg = test_bmc_channel()
        if status == False:
            RJPRINT("到BMC通路异常，无法测试BMC端NCSI通路")
            RET[RETURN_KEY1] -= 1
            bmctest = False
    else:
        bmctest = False
    ret_t = test_mgmt_speed(10 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_speed(100 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    ret_t = test_mgmt_speed(1000 , bmctest)
    RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
    RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)

    time.sleep(5)
    return RET



def diff_pcie():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    ret, log = log_os_system("lspci -n", 0)
    pci_list = log.split("\n")
    if len(pci_list) != len(PCIe_DEV_LIST):
        RET[RETURN_KEY2] = "Error:PCIe设备数量不相等, lspci设备数量:%d, 配置文件设备数量:%d\n" % (len(pci_list),len(PCIe_DEV_LIST))
        log_debug("Error:PCIe设备数量不相等, lspci设备数量:%d, 配置文件设备数量:%d\n" % (len(pci_list),len(PCIe_DEV_LIST)))
    pci_dict = {}
    for pci in pci_list:
        pci_item = pci.split(" ")
        pci_dict[pci_item[0]] = pci_item[2]
    try:
        for dev in PCIe_DEV_LIST:
            if dev["pci_addr"] not in pci_dict:
                RET[RETURN_KEY2] += "Error:PCIe 设备未找到.PCIe addr = %s,device ID = %s\n" % (dev["pci_addr"],dev["dev_id"])
                log_debug("Error:PCIe 设备未找到.PCIe addr = %s,device ID = %s\n" % (dev["pci_addr"],dev["dev_id"]))
                if dev.get("ignore",0) == 1:    # Avoiding Baidu BIOS switchover causes two devices fail to scan
                    pass
                else:
                    RET[RETURN_KEY1] -= 1
            elif dev["dev_id"] != pci_dict[dev["pci_addr"]]:
                RET[RETURN_KEY1] -= 1
                RET[RETURN_KEY2] += "Error:PCIe设备ID不一致。PCIe地址：%s,配置文件设备ID：%s,lspci设备ID:%s,\n"% (dev["pci_addr"],dev["dev_id"],pci_dict[dev["pci_addr"]])
                log_debug("Error:PCIe设备ID不一致。PCIe地址：%s,配置文件 设备ID：%s,lspci 设备ID:%s,\n"% (dev["pci_addr"],dev["dev_id"],pci_dict[dev["pci_addr"]]))
                del pci_dict[dev["pci_addr"]]
            else:
                del pci_dict[dev["pci_addr"]]
        for pci_addr, dev_id in sorted(pci_dict.items()):
            RET[RETURN_KEY1] -= 1
            RET[RETURN_KEY2] += "Error:lspci扫描到的PCIe设备不在配置文件中.PCIe addr = %s,device ID = %s\n" % (pci_addr, dev_id)
            log_debug("Error:扫描到的PCIe 设备不在配置文件中.PCIe addr = %s,device ID = %s\n" % (pci_addr, dev_id))
    except Exception as e:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = str(e)
        log_debug(str(e))

    return RET

def check_pcie_speed():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ""
    try:
        for pci in PCIe_SPEED_ITEM:
            ret, log = log_os_system("lspci|grep %s"%pci["PCIe_name"], 0)
            if pci["PCIe_name"] in log:
                result_t = log.split(" ")
                vvcmd = "lspci -s %s -vvv | grep LnkSta | grep Width" % result_t[0]
                ret2, log2 = log_os_system(vvcmd, 0)
                filted_list = re.findall(r".*(speed.*, width.*).*",log2.lower())
                if len(filted_list) > 0 :
                    value_list = filted_list[0].split(",")
                    checklist = pci.get("check",None)
                    if checklist is None:
                        RJPRINT("%-10s (%-13s, %s): PASS"%(pci["dev_desc"], value_list[0], value_list[1]))
                    else:
                        realdata = {"speed":"","width":""}
                        realdata["speed"] = value_list[0].strip().split(" ")[1].strip()
                        realdata["width"] = value_list[1].strip().split(" ")[1].strip()
                        for key,value in checklist.items():
                            if realdata[key] != value:
                                totalerr -= 1
                                errmsg += "%s %s check error,correct value is :%s\n" %(pci["dev_desc"],key,value)
                        if totalerr < 0:
                            RET[RETURN_KEY1] = -1
                            RJPRINT("%-10s (%-13s, %s): FAILED"%(pci["dev_desc"], value_list[0], value_list[1]))
                            RJPRINT(errmsg)
                            errmsg = ""
                            totalerr = 0
                        else:
                            RJPRINT("%-10s (%-13s, %s): PASS"%(pci["dev_desc"], value_list[0], value_list[1]))
                else:
                    RJPRINT("%-10s : PASS"%pci["dev_desc"])
            else:
                RJPRINT("%-10s : FAILED"%pci["dev_desc"])
                RET[RETURN_KEY2] += "%-10s : FAILED"%pci["dev_desc"]
                RET[RETURN_KEY1] = -1
    except Exception as e:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = str(e)
        log_debug(str(e))

    return RET


def pci_scan():
   # check diff
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    RET1 = diff_pcie()
    if RET1[RETURN_KEY1] != 0:
        RET[RETURN_KEY1] += RET1[RETURN_KEY1]
        RET[RETURN_KEY2] += RET1[RETURN_KEY2]
        RJPRINT("PCIe        devices scan             : FAILED")
    else:
        RJPRINT("PCIe        devices scan             : PASS")

    RET1 = check_pcie_speed()
    if RET1[RETURN_KEY1] != 0:
        RET[RETURN_KEY1] += RET1[RETURN_KEY1]
        RET[RETURN_KEY2] += RET1[RETURN_KEY2]

    return RET

def test_cpu_gpio_6920V2():# C3000CPU does not have chip selection gPIO CPLD Upgrade chip selection through the CPLD register
    tolalerr = 0
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    ret, log = log_os_system("which firmware_upgrade", 0)
    if len(log):
        cmd = "firmware_upgrade cpld test"
    else:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "no firmware_upgrade cmd find"
        RJPRINT("no firmware_upgrade cmd find")
        return RET
    commands = TESTCASE.get("cpld_switch", {}).get("SWITCH", None)
    clearcmd = TESTCASE.get("cpld_switch", {}).get("CLEAR", None)
    for tmp in commands:
        ret, log = log_os_system(tmp, 0)
        if ret:
            tolalerr += -1
            log_error(cmd + "cmd fail")
            continue
        ret, log = log_os_system(cmd, 0)
        if "PASS" not in log or ret:
            RET[RETURN_KEY2] += log
            log_error(cmd + log)
            tolalerr += -1
        ret, log = log_os_system(clearcmd, 0)
        if ret:
            tolalerr += -1
            log_error(cmd + "clear env fail")
    if tolalerr < 0:
        RET[RETURN_KEY1] = -1
    return RET

def test_cpu_gpio():
    errmsg = ""
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    cmd = ""
    ret, log = log_os_system("which firmware_upgrade", 0)
    if len(log):
        cmd = "firmware_upgrade cpld test"
    else:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "no firmware_upgrade cmd find"
        RJPRINT("no firmware_upgrade cmd find")
        return RET

    ret, log = log_os_system(cmd, 0)
    RJPRINT(log)
    if "PASS" not in log:
        RET[RETURN_KEY2] = log
        RET[RETURN_KEY1] = -1
    return RET

def bmc_get_sensor_info():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    cmd = ""
    ret, log = log_os_system("ipmitool sdr list", 0)
    RET[RETURN_KEY2] = log
    RJPRINT(log)
    if "disabled" in log or "failed"in log:
        RET[RETURN_KEY1] = -1
    return RET

def test_bmc_image_force_switch(bmc_info):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    RET = test_bmc_func("bmc_get_flash")
    status = False
    timeout = TESTCASE.get("SONIC",{}).get("timeout",120)
    if RET[RETURN_KEY1]:
        RJPRINT(RET[RETURN_KEY2])
        return RET
    if bmc_info in RET[RETURN_KEY2]:
        RJPRINT("已是%s，无需切换"%bmc_info)
        RET[RETURN_KEY1] = 0
        return RET
    if makesure("切换会导致BMC重启，是否继续？[Yes/No]：",False,echo = True):
        RJPRINT("执行切换中，请等待约90s...")
        path = getRealUrl("bmc_test_switch")
        cmd = "curl -m 90 %s" % path
        ret, log =log_os_system(cmd, 0)
        if "timed out" not in log:
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = "强制切换BMC失败"
            return RET
        RJPRINT("已成功执行切换操作")
        # After the BMC switchover, the USB0 IP address on the X86 terminal will be lost and needs to be reconfigured
        ret_t = usb0_init()
        while timeout > 0:
            if ret_t == False:
                ret_t = usb0_init()
            status,msg = test_bmc_channel()
            if status == True:
                break
            time.sleep(2)
            timeout -= 2
        if timeout < 0:
            RJPRINT(msg)
            RET[RETURN_KEY1] = -1
    else:
        print ("已撤销")
        RET[RETURN_KEY1] = -1
    return RET

def test_bmc_image_force_switch_master():
    return test_bmc_image_force_switch("master")

def test_bmc_image_force_switch_slave():
    return test_bmc_image_force_switch("slave")

def generate_value(_t):
    ret = []
    for i in TLV_INFO_ID_STRING:
        ret.append(i)
    ret.append(chr(TLV_INFO_VERSION))
    ret.append(chr(TLV_INFO_LENGTH))
    ret.append(chr(TLV_INFO_LENGTH_VALUE))

    total_len = 0
    for key in _t:
        x = getTLV_BODY(key, _t[key])
        ret += x
        total_len += len(x)
    ret[10] = chr(total_len + 6)

    ret.append(chr(0xFE))
    ret.append(chr(0x04))
    s = _crc32(''.join(ret))
    for t in range(0, 4):
        ret.append(chr(int(s[2 * t + 2:2 * t + 4], 16)))
    totallen = len(ret)
    if (totallen < 256):
        for left_t in range(0, 256 - totallen):
            ret.append(chr(0x00))
    return (ret, True)



def isValidMac(mac):
    if re.match(r"^\s*([0-9a-fA-F]{2,2}:){5,5}[0-9a-fA-F]{2,2}\s*$", mac):
        return True
    return False

def RJPRINTERR(str):
    print("\033[0;31m%s\033[0m" % str)


def test_bmc_ddr_stress_stop():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    if not makesure("强行结束将无法查看结果，是否继续？[Yes/No]：",echo = True):
        RET[RETURN_KEY2] = "已撤销"
        RJPRINT(RET[RETURN_KEY2])
        return RET
    RET = test_bmc_func("bmc_test_ddr_stress_stop_by_sonic")
    RJPRINT(RET[RETURN_KEY2])
    return RET

def test_bmc_emmc_stress_stop():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    if not makesure("强行结束将无法查看结果，是否继续？[Yes/No]：",echo = True):
        RET[RETURN_KEY2] = "已撤销"
        RJPRINT(RET[RETURN_KEY2])
        return RET
    RET = test_bmc_func("bmc_test_emmc_stress_stop")
    RJPRINT(RET[RETURN_KEY2])
    return RET

def bmc_test_ddr_stress_with_result():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : ""}
    RET = test_bmc_func("bmc_test_ddr_stress")
    RJPRINT(RET[RETURN_KEY2])
    if "已启动后台执行" not in RET[RETURN_KEY2]:
        return RET
    RJPRINT("后台执行测试，等待100s")
    time.sleep(100)
    RET = test_bmc_func("bmc_test_ddr_stress_result")
    RJPRINT(RET[RETURN_KEY2])
    return RET

def get_fane2_sysfs(bus, loc):
    rg_fan_e2 = "%d-%04x/fan" % (bus, loc)
    eeprom = get_sysfs_value(rg_fan_e2)
    return eeprom

def checkfansninput(fan_sn, fansntemp):
    if fan_sn in fansntemp:
        RJPRINTERR("存在相同序列号，请重新输入！")
        return False
    if fan_sn.isalnum() == False:
        RJPRINTERR("序列号非法字符串，请重新输入！")
        return False
    if(len(fan_sn) != 13):
        RJPRINTERR("序列号长度错误(13位)，请重新输入！")
        return False
    return True

# Check the input hardware version number
def checkfanhwinput(hw):
    if len(hw) != 4:
        RJPRINTERR("硬件版本号长度不正确,请重新输入！")
        return False
    if hw.find(".") != 1:
        RJPRINTERR("硬件版本号不正确,请重新输入！")
        return False
    return True

def util_show_fanse2(fans):
    formatstr = "%-8s  %-20s  %-20s  %-20s"
    print (formatstr % ("id", "名称", "硬件版本号", "序列号"))
    formatstr = "%-8s  %-18s  %-15s  %-15s"
    print (formatstr % ("------", "------------", "-----------", "---------------"))
    formatstr = "%-10s  %-18s  %-15s  %-15s"
    for fan in fans:
        # print fan.dstatus
        if fan.dstatus < 0:
            print "%-8s" % ("风扇%d" % (fans.index(fan) + 1)),
            RJPRINTERR("  解析e2出错")
        else:
            print (formatstr % ("风扇%d" % (fans.index(fan) + 1), fan.typename.replace(chr(0x00), ""),
                               fan.typehwinfo.replace(chr(0x00), ""), fan.typesn.replace(chr(0x00), "")))

def fac_fan_setmac(item):

    I2CUTIL.openFanE2Protect()
    I2CUTIL.writeToFanE2(item.fanbus, item.fanloc, item.generate_fan_value())
    I2CUTIL.closeFanE2Protect()

    pass


def fac_fans_setmac_tlv(ret):
    if len(ret) <=0:
        return None
    fans = []
    fansntemp = []
    for index in range(len(ret)):
        item = ret[index]
        log_debug(item)
        eeprom = get_fane2_sysfs(item["bus"], item["loc"])
        fane2 = fan_tlv()
        fane2.decode(eeprom)
        fane2.fanbus = item["bus"]
        fane2.fanloc = item["loc"]
        log_debug("decode eeprom success")

        print ("风扇【%d】-【%s】setmac" % ((index + 1), FANS_DEF[fane2.typedevtype]))
        while True:
            print ("请输入[%s如(0000000000000)]:" % "序列号",)
            fan_sn = raw_input()
            if checkfansninput(fan_sn, fansntemp) == False:
                continue
            fansntemp.append(fan_sn)
            fan_sn = fan_sn + chr(0x00)
            fane2.typesn = fan_sn
            break
        while True:
            print ("请输入[%s如(1.00)]:" % "硬件版本号",)
            hwinfo = raw_input()
            if checkfanhwinput(hwinfo) == False:
                continue
            fan_hwinfo = hwinfo + chr(0x00)
            fane2.typehwinfo = fan_hwinfo
            break
        log_debug(fane2.typedevtype)
        fane2.typename = FANS_DEF[fane2.typedevtype] + chr(0x00)
        fans.append(fane2)
        print ("\n")
    print ("\n*******************************\n")

    util_show_fanse2(fans)
    if makesure("确认是否输入正确（Yes/No):",echo = 1) == True:
        for fan in fans:
            log_debug("ouput fan")
            fac_fan_setmac(fan)
    else:
        print ("setmac退出")
        return False

def fac_fans_show_tlv(ret):
    totalerr = 0
    fans =  ret
    for fan in fans:
        try:
            RJPRINT("===============fan%d ================getmessage" % (fans.index(fan)+1))
            # Check whether the fan module is installed
            fanstatus = TESTCASE.get("frustatus",None)
            fanstatusdecode = TESTCASE.get("frustatusdecode",None)
            fanpresent = fanstatusdecode.get('fanpresent')
            fans_conf = fanstatus.get('fans', None)
            item_fan = fans_conf[fans.index(fan)]
            presentbus = item_fan.get('bus')
            presentaddr = item_fan.get('presentloc')
            presentbit = item_fan.get('presentbit')
            loc      = item_fan.get('loc')
            ind, val = rji2cget(presentbus, loc,presentaddr)
            if ind == True:
                val_t = (int(val,16) & (1<< presentbit)) >> presentbit
                if val_t != fanpresent.get('okval'):# fan is not detected.
                    formatstr = "fan%%-%dd:ABSENT"%((17+wide_chars("fan")))
                    RJPRINT(formatstr%(fans.index(fan)+1))
                    totalerr -= 1
                    continue
                else:
                    eeprom = I2CUTIL.dumpValueByI2c(fan.get('bus'), fan.get('loc'))
                    tlv = fan_tlv()
                    rets = tlv.decode(eeprom)
                    if len(rets) == 0:
                        totalerr -= 1
                        RJPRINT("fan E2 read error, please set fan E2 !")
                        continue
                    for item in rets:
                        formatstr = "%%-%ds:%%-20s"%((20+wide_chars(item["name"])))
                        RJPRINT(formatstr%(item["name"],item["value"]))
            else:
                totalerr -= 1
                RJPRINT("get fan present fail!")
        except Exception as e:
            RJPRINT(str(e))
            totalerr -= 1
    if totalerr < 0:
        return False
    return True



def fac_fans_show_fru(ret):
    fans =  ret
    totalerr = 0
    for fan in fans:
        try:
            RJPRINT("===============%s ================getmessage" % fan.get('name'))
            eeprom = I2CUTIL.dumpValueByI2c(fan.get('bus'), fan.get('loc'))# getsysvalue(I2CUTIL.getE2File(fan.get('bus'), fan.get('loc')))
            fru = ipmifru()
            fru.decodeBin(eeprom)

            RJPRINT("=================board=================")
            RJPRINT(fru.boardInfoArea)
            RJPRINT("=================product=================")
            RJPRINT(fru.productInfoArea)
        except Exception as e:
            totalerr -= 1
    if totalerr <0:
        return False
    return True

def getfilevalue(location):
    try:
        with open(location, 'r') as fd:
            value = fd.read()
        return True, value.strip()
    except Exception as e:
        return False, "error"

def test_psu_eeprom():
    return test_get_psu_fru()

def test_tlv_eeprom():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    errmsg = ""
    totalerr = 0

    RJPRINT("")
    RJPRINT("%s "% "系统TLV E2信息:")
    ret, log = log_os_system("show platform syseeprom", 0)
    RJPRINT(log)
    if ret or "TlvInfo" not in log:
        RET[RETURN_KEY1] = -1
        totalerr -= 1
        RJPRINT("获取eeprom信息失败")

    RJPRINT("")
    RJPRINT("%s "% "硬件TLV E2信息:")
    eeprom  = get_sysfs_value(rg_eeprom)
    onietlv = onie_tlv()
    rets    = onietlv.decode(eeprom)
    for item in rets:
        if item["code"] == TLV_CODE_PRODUCT_NAME :
            RJPRINT("      %s : %s "%("产品名称  ", item["value"]))
        if item["code"] == TLV_CODE_DEVICE_VERSION :
            RJPRINT("      %s : V%s "%("硬件版本号", item["value"]))
        if item["code"] == TLV_CODE_SERIAL_NUMBER :
            RJPRINT("      %s : %s "%("序列号    ", item["value"]))
        if item["code"] == TLV_CODE_MAC_BASE :
            RJPRINT("      %s : %s "%("MAC       ", item["value"]))
        if item["code"] == TLV_CODE_PLATFORM_NAME :
            RJPRINT("      %s : %s "%("平台名称  ", item["value"]))
        if item["code"] == TLV_CODE_ONIE_VERSION :
            RJPRINT("      %s : %s "%("ONIE版本  ", item["value"]))
    RJPRINT("")

    return RET

def test_fan_eeprom():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    try:
        if (fans_eeprom_show() == False):
            totalerr -= 1
    except Exception as e:
        RJPRINTERR(e)
        totalerr -= 1
    RET[RETURN_KEY1] = totalerr
    return RET

def fans_eeprom_show():
    ret =  I2CUTIL.getvaluefromdevice("rg_fan")
    if ret is not None and len(ret) > 0:
        return fac_fans_show_tlv(ret)
    fans =  FRULISTS.get('fans', None)
    if fans is not None and len(fans)>0:
        return fac_fans_show_fru(fans)
    return False

def fac_fan_setmac_fru(ret):
    fans =  ret
    fanfrus = {}
    newfrus = {}
    # getmsg
    try:
        for fan in fans:
            RJPRINT("===============%s ================getmessage" % fan.get('name'))
            eeprom = getsysvalue(I2CUTIL.getE2File(fan.get('bus'), fan.get('loc')))
            if eeprom is None:
                raise Exception("错误")
            fru = ipmifru()
            fru.decodeBin(eeprom)
            fanfrus[fan.get('name')] = fru
    except Exception as e:
        RJPRINT(str(e))
        return False

    # setmsg
    for fan in fans:
        RJPRINT("===============%s ================setmac" % fan.get('name'))
        fruold = fanfrus.get(fan.get('name'))
        newfru = getInputSetmac(fruold)
        newfru.recalcute()
        newfrus[fan.get('name')] = newfru

    # writemsg
    for fan in fans:
        RJPRINT("===============%s ================writeToE2" % fan.get('name'))
        ret_t = newfrus.get(fan.get('name'))
        I2CUTIL.openFanE2Protect()
        I2CUTIL.writeToFanE2(fan.get('bus'), fan.get('loc'), ret_t.bindata)
        I2CUTIL.closeFanE2Protect()

    # check
    try:
        for fan in fans:
            RJPRINT("===============%s ================getmessage" % fan.get('name'))
            eeprom = getsysvalue(I2CUTIL.getE2File(fan.get('bus'), fan.get('loc')))
            fru = ipmifru()
            fru.decodeBin(eeprom)

            RJPRINT("=================board=================")
            RJPRINT(fru.boardInfoArea)
            RJPRINT("=================product=================")
            RJPRINT(fru.productInfoArea)
    except Exception as e:
        RJPRINT(str(e))
        return False
    return True

def fac_fans_setmac():
    ret =  I2CUTIL.getvaluefromdevice("rg_fan")
    if ret is not None and len(ret) > 0:
        return fac_fans_setmac_tlv(ret)
    fans =  FRULISTS.get('fans', None)
    if fans is not None and len(fans)>0:
        return fac_fan_setmac_fru(fans)
    return False


def getinputsetmac_slot():
    slot_info = {}
    slot_sn = upper_input("产品序列号:")
    if len(slot_sn) != 13:
        raise Exception("序列号长度不对")
    checkinputproduct(slot_sn)
    hw_version = upper_input("硬件版本号:(如1.00)")
    slot_info["slot_sn"] = slot_sn
    slot_info["hw_version"] = hw_version
    return slot_info

def test_tlv_slot_eeprom():

    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    slots =  FRULISTS.get('slots_tlv', [])
    for slot in slots:
        try:
            RJPRINT("===============%s ================getmessage" % slot.get('name'))
            eeprom = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
            if eeprom is None:
                raise Exception("错误")
            slote2 = fan_tlv()
            slote2.decode(eeprom)
            RJPRINT(slote2)
        except Exception as e:
            RJPRINT(str(e))
            RET[RETURN_KEY1] -= 1
            RET[RETURN_KEY2] = str(e)

    return RET

def test_fru_slot_eeprom():

    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    slots =  FRULISTS.get('slots_fru', [])
    for slot in slots:
        try:
            RJPRINT("===============%s ================getmessage" % slot.get('name'))
            eeprom = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
            if eeprom is None:
                raise Exception("错误")
            slote2 = ipmifru()
            slote2.decodeBin(eeprom)
            RJPRINT(slote2.boardInfoArea)
        except Exception as e:
            RJPRINT(str(e))
            RET[RETURN_KEY1] -= 1
            RET[RETURN_KEY2] = str(e)

    return RET

def fac_tlv_slots_setmac(old_eeprom,setmac_info):
    '''TLV subcard setMAC'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    slots_tlv =  FRULISTS.get('slots_tlv', [])
    protect = TESTCASE.get('tlv_slots_E2protect',[])

    try:
        for item in protect:
            rji2cset(item["bus"], item["devno"], item["addr"], item["open"])
        for slot in slots_tlv:
            try:
                slote2 = old_eeprom.get(slot.get('name'))
                slot_info = setmac_info.get(slot.get('name'))
                slote2.typesn = slot_info.get("slot_sn") + chr(0x00)
                slote2.typehwinfo = slot_info.get("hw_version") + chr(0x00)

                RJPRINT("===============tlv_%s ================writeToE2" % slot.get('name'))
                I2CUTIL.writeToE2(slot.get('bus'), slot.get('loc'), slote2.generate_fan_value())

                RJPRINT("===============tlv_%s ================showmessage" % slot.get('name'))
                eeprom_new = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
                if eeprom_new is None:
                    raise Exception("错误")
                slote2.decode(eeprom_new)
                RJPRINT(slote2)
            except Exception as e:
                RJPRINT(str(e))
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = str(e)
    except Exception as e:
        RJPRINT(str(e))
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = str(e)
    finally:
        for item in protect:
            rji2cset(item["bus"], item["devno"], item["addr"], item["close"])

    return RET


def fac_fru_slots_setmac(old_eeprom,setmac_info):
    '''Fru format sub-card setMAC'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    slots_fru =  FRULISTS.get('slots_fru', [])
    protect = TESTCASE.get('fru_slots_E2protect',[])

    try:
        for item in protect:
            rji2cset(item["bus"], item["devno"], item["addr"], item["open"])

        for slot in slots_fru:
            try:
                slote2 = old_eeprom.get(slot.get('name'))
                slot_info = setmac_info.get(slot.get('name'))
                slote2.boardInfoArea.boardSerialNumber = slot_info.get("slot_sn")
                slote2.boardInfoArea.boardextra1 = slot_info.get("hw_version")
                slote2.recalcute()
                # writemsg
                RJPRINT("===============fru_%s ================writeToE2" % slot.get('name'))
                I2CUTIL.writeToE2(slot.get('bus'), slot.get('loc'), slote2.bindata)

                RJPRINT("===============fru_%s ================showmessage" % slot.get('name'))
                eeprom_new = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
                if eeprom_new is None:
                    raise Exception("错误")
                slote2.decodeBin(eeprom_new)
                RJPRINT(slote2.boardInfoArea)
            except Exception as e:
                RJPRINT(str(e))
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = str(e)
    except Exception as e:
        RJPRINT(str(e))
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = str(e)
    finally:
        for item in protect:
            rji2cset(item["bus"], item["devno"], item["addr"], item["close"])

    return RET


def fac_slots_setmac():
    u"""子卡setmac"""
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    setmac_info = {}
    tlv_setmac_flag = FACTESTMODULE.get('tlv_slotsetmac',0)
    fru_setmac_flag = FACTESTMODULE.get('fru_slotsetmac',0)
    if tlv_setmac_flag == 0 and fru_setmac_flag == 0:
        RJPRINT("=============== 无子卡E2 SETMAC信息！================")
        return RET

    slots_tlv =  FRULISTS.get('slots_tlv', [])
    slots_fru =  FRULISTS.get('slots_fru', [])

    if tlv_setmac_flag == 1 and len(slots_tlv) == 0 or fru_setmac_flag == 1 and len(slots_fru) == 0:
        RET[RETURN_KEY1] -= 1
    if tlv_setmac_flag == fru_setmac_flag and len(slots_tlv) != len(slots_fru):
        RET[RETURN_KEY1] -= 1
    if RET[RETURN_KEY1] < 0 :
        RJPRINT("===============子卡E2 SETMAC错误，请检查配置文件! ========" )
        RJPRINT("===============tlv_setmac_flag:%d,length:%d ================" %(tlv_setmac_flag,len(slots_tlv)))
        RJPRINT("===============fru_setmac_flag:%d,length:%d ================" %(fru_setmac_flag,len(slots_fru)))
        return RET


    tlv_old_eeprom = {}
    fru_old_eeprom = {}
    if tlv_setmac_flag == 1:
        for slot in slots_tlv:
            try:
                RJPRINT("===============tlv_%s ================getmessage" % slot.get('name'))
                eeprom = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
                if eeprom is None:
                    raise Exception("错误")
                slote2 = fan_tlv()
                slote2.decode(eeprom)
                tlv_old_eeprom[slot.get('name')] = slote2
            except Exception as e:
                 RJPRINT(str(e))
                 RET[RETURN_KEY1] = -1
                 RET[RETURN_KEY2] = str(e)

    if fru_setmac_flag == 1:
        for slot in slots_fru:
            try:
                RJPRINT("===============fru_%s ================getmessage" % slot.get('name'))
                eeprom = I2CUTIL.dumpValueByI2c(slot.get('bus'), slot.get('loc'))
                if eeprom is None:
                    raise Exception("错误")
                slote2 = ipmifru()
                slote2.decodeBin(eeprom)
                fru_old_eeprom[slot.get('name')] = slote2
            except Exception as e:
                 RJPRINT(str(e))
                 RET[RETURN_KEY1] = -1
                 RET[RETURN_KEY2] = str(e)
    if RET[RETURN_KEY1] < 0 :
        RJPRINT("=============== 请确认原始烧片是否正常! ================" )
        return RET

    if tlv_setmac_flag == 1:
        for slot in slots_tlv:
            RJPRINT("=============== %s ================setmac" % slot.get('name'))
            slot_info = getinputsetmac_slot()
            setmac_info[slot.get('name')] = slot_info
    else:
        for slot in slots_fru:
            RJPRINT("=============== %s ================setmac" % slot.get('name'))
            slot_info = getinputsetmac_slot()
            setmac_info[slot.get('name')] = slot_info

    # tlv slot setmac
    if tlv_setmac_flag == 1:
        ret_t = fac_tlv_slots_setmac(tlv_old_eeprom,setmac_info)
        RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
        RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)
    # fru slot setmac
    if fru_setmac_flag == 1:
        ret_t = fac_fru_slots_setmac(fru_old_eeprom,setmac_info)
        RET[RETURN_KEY1] += ret_t.get(RETURN_KEY1)
        RET[RETURN_KEY2] += ret_t.get(RETURN_KEY2)
    return RET

def checkinput(b):
    if b.isdigit() == False:
        raise Exception("非法数字")
    if int(b) > 0xff or int(b) < 0:
        raise Exception("不在区间内")

def checkinputproduct(b):
    if b.isalnum() ==False:
        raise Exception("非法字符串")


def getInputSetmac(val):
    bia = val.boardInfoArea
    pia = val.productInfoArea
    if bia != None:
        a = upper_input("[板卡区]产品序列号:")
        if len(a) != 13:
            raise Exception("序列号长度不对")
        checkinputproduct(a)
        bia.boardSerialNumber = a
        b = upper_input("[板卡区]产品版本号:(从1-255)")
        checkinput(b)
        # b = "%0x" % int(b)
        bia.boardextra1 = b.upper()
    if pia != None:
        a = upper_input("[产品区]产品序列号:")
        if len(a) != 13:
            raise Exception("序列号长度不对")
        checkinputproduct(a)
        pia.productSerialNumber = a
        b = upper_input("[产品区]产品版本号:(从1-255)")
        checkinput(b)
        # b = "%0x" % int(b)
        pia.productVersion = b.upper()
    return val



class I2CUTIL():
    @staticmethod
    def getvaluefromdevice(name):
        ret = []
        if DEVICE == None:
            return None
        for item in DEVICE:
            if item["name"] == name:
                ret.append(item)
        return ret

    @staticmethod
    def openFanE2Protect():
        if FAN_PROTECT is None or len(FAN_PROTECT) <= 0:
            return
        if type(FAN_PROTECT) == list: # expand 20190429
            for item in FAN_PROTECT:
                rji2cset(item["bus"], item["devno"],
                         item["addr"], item["open"])
        elif type(FAN_PROTECT) == dict:
            rji2cset(FAN_PROTECT["bus"], FAN_PROTECT["devno"],
                     FAN_PROTECT["addr"], FAN_PROTECT["open"])
        else:
            return

    @staticmethod
    def closeFanE2Protect():
        if FAN_PROTECT is None or len(FAN_PROTECT) <= 0:
            return
        if type(FAN_PROTECT) == list: # expand 20190429
            for item in FAN_PROTECT:
                rji2cset(item["bus"], item["devno"],
                         item["addr"], item["close"])
        elif type(FAN_PROTECT) == dict:
            rji2cset(FAN_PROTECT["bus"], FAN_PROTECT["devno"],
                     FAN_PROTECT["addr"], FAN_PROTECT["close"])
        else:
            return

    @staticmethod
    def writeToFanE2(bus, loc, rst_arr):
        index = 0
        for item in rst_arr:
            rji2cset(bus, loc, index, ord(item))
            index += 1

    @staticmethod
    def writeToE2(bus, loc, rst_arr):
        index = 0
        for item in rst_arr:
            rji2cset(bus, loc, index, ord(item))
            index += 1

    @staticmethod
    def getE2File(bus, loc):
        return "/sys/bus/i2c/devices/%d-00%02x/eeprom" % (bus, loc)

    @staticmethod
    def dumpValueByI2c(bus, loc):
        str = ""
        for i in range(256):
            ret,val = rji2cget(bus, loc, i)
            str += chr(int(val, 16))
        return str

def getsysvalue(location):
    retval = None
    mb_reg_file = location
    try:
        if (not os.path.isfile(mb_reg_file)):
            print (mb_reg_file,  'not found !')
            return retval
        with open(mb_reg_file, 'r') as fd:
            retval = fd.read()
    except Exception as error:
        log_error("Unable to open " + mb_reg_file + "file !")
    retval = retval.rstrip('\r\n')
    retval = retval.lstrip(" ")
    # log_debug(retval)
    return retval

def waitForDocker(need_restart=False):
    time_cnt = 0
    while True:
        try:
            ret, status = rj_os_system("docker ps |wc -l")
            if ret == 0 and int(status) >= 9:
                break
            else:
                sys.stdout.write(".")
                sys.stdout.flush()
                time_cnt = time_cnt + 1
                time.sleep(1)
                if (need_restart == True):
                    if (time_cnt >= 120 and time_cnt%10 == 0):
                        if (time_cnt >= 180):
                            restartDockerService(True)
                        else:
                            restartDockerService()
        except Exception as e:
            continue

def waitForSDK():
    timeout = 300
    while timeout > 0:
        try:
            ret, status = rj_os_system("bcmcmd -t 1 ps < /dev/null")
            if ret != 0 :
                sys.stdout.write(".")
                sys.stdout.flush()
                timeout -= 1
                time.sleep(1)
            else:
                break
        except Exception as e:
            continue

def closeProtocol():
    # close LLDP
    log_info("关闭LLDP")
    sys.stdout.write(".")
    sys.stdout.flush()
    rj_os_system("systemctl stop lldp.service")
    log_info("关闭网关边界服务")
    sys.stdout.write(".")
    sys.stdout.flush()
    rj_os_system("systemctl stop bgp.service")
    log_info("关闭生成树")
    sys.stdout.write(".")
    sys.stdout.flush()

def fac_init_cardidcheck():
    rest = getsyseeprombyId(TLV_CODE_RJ_CARID)  # Check whether cardId are the same
    if rest == None:
        print ("需要烧写bin文件")
        return False
    else:
        rest_v = rest['value']
        value = int(rest_v, 16)
        if value == RAGILE_CARDID:
            log_debug("板卡ID检测通过")
        else:
            log_debug("板卡ID有误")
            return False
    return True

def get_sys_eeprom():
    onietlv = onie_tlv()
    eeprom = get_sysfs_value(rg_eeprom)
    return onietlv.decode(eeprom)


def getsyseeprombyId(id):  # Obtain the system system by ID
    ret = get_sys_eeprom()
    for item in ret:
        if item["code"] == id:
            return item
    return None

def test_tbd():
    RJPRINT("待实现")
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    return RET

def set_port_mac_lb():
    bmc_cmd = "port all en=1 lb=mac"
    ret, log = log_os_system("bcmcmd \"%s\" < /dev/null"%bmc_cmd, 0)
    if ret or bmc_cmd not in log:
        RJPRINT("FAILED")
        return False, "配置回环失败"
    time.sleep(6)
    return True, ""

def cancel_port_mac_lb():
    bmc_cmd = "port all lb=none"
    ret, log = log_os_system("bcmcmd \"%s\" < /dev/null"%bmc_cmd, 0)
    if ret or bmc_cmd not in log:
        RJPRINT("取消配置回环失败")
        return False, "取消配置回环失败"
    time.sleep(6)
    return True, ""

def test_PCIe_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    ''' old code backup'''
    '''
    totalerr = 0
    test_times = 3
    try:
        for i in range(0, test_times):
           RJPRINT("\n\n第 %d/%d 次测试"%(i+1, test_times))
           RET1 = test_portframe()
           totalerr += RET1[RETURN_KEY1]
           RET[RETURN_KEY2] += str(RET1[RETURN_KEY2])
    except Exception as e:
        totalerr = -999
        RET[RETURN_KEY2] = str(e)
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET
    '''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    for i in range(3):
        ret, log = test_port_portframe()
        if ret:
            RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : log}
            break
        else :
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    RJPRINT(log)
    return RET

def test_opt_module_present():
    pass_list = []
    failed_list = []
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    empty_str = "      "
    ret, log = log_os_system("show interfaces transceiver presence | grep -a -E '^Ethernet'", 0)
    if "Traceback" in log:
        RJPRINT( "在位检测失败，请确认光模块是否在位")
    else:
        log,times = re.subn("Ethernet\d{1,3}\s*","",log)
        if len(log) == 0:
            RET[RETURN_KEY1] = -1
            return RET
        dev_list = log.split("\n")
        i = 1
        for dev in dev_list:
            if "Not present" in dev:
                failed_list.append(i)
            else:
                pass_list.append(i)
            i += 1
        if len(pass_list) > 0:
            port_totalprint(pass_list, "OK")
        if len(failed_list) >0:
            port_totalprint(failed_list, "failed")
        if ret or "FAILED" in log:
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = log
    if ret or "Not" in log or "Unknown" in log:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = log
    return RET

def test_cpu_i2c_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : []}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       RJPRINT("\n\nCPU端第 %d/%d 次测试"%(i+1, test_times))
       RET1 = test_i2c()
       totalerr += RET1[RETURN_KEY1]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def test_bmc_testcase_new(func, param_t=None, timeout = 600):
    if param_t is None:
        ret = HttpRest().Get(getRealUrl(func), timeout=timeout)
    else:
        ret = HttpRest().Get(getRealUrl(func, json.dumps(param_t)), timeout=timeout)
    RJPRINT(ret.get(RETURN_KEY2))
    return ret

def test_bmc_i2c_stress():
    totalerr = 0
    try:
        test_bmc_i2c_open()
        RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
        test_times = 10
        returncode, msg = test_bmc_channel()
        if returncode == False:
            RJPRINT(msg)
            return {RETURN_KEY1 : -1, RETURN_KEY2 : msg}
        RET1 = test_bmc_testcase_new("bmc_test_i2c_stress")
        RET[RETURN_KEY2] += RET1[RETURN_KEY2]
        totalerr += RET1[RETURN_KEY1]
    except Exception as e:
        RJPRINT(str(e))
    finally:
        test_bmc_i2c_close()
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def countdown():
    global ssd_status
    i = 0
    while True:
        time.sleep(1)
        i += 1
        if ssd_status == 3:
            ssd_status = 0
            return
        elif i == 120:
            ssd_status = 2
            return

ssd_status = 0 # 0 undo 1 doing 2 done 3stopping
def test_ssd_stress():
    RET = {RETURN_KEY1 : 1, RETURN_KEY2 : "已启动后台执行"}
    cmd = "smartctl -t long  /dev/sda"
    global ssd_status
    if ssd_status == 1:
        RET[RETURN_KEY2] = "已存在后台ssd测试"
        RJPRINT(RET[RETURN_KEY2])
        return RET

    ret, log = log_os_system("which smartctl", 0)
    if len(log):
        # smartctl Built-in background detection
        # by to smartctl -l selftest  /dev/sda look
        os.system(cmd)
        ssd_status = 1
    else:
        RET[RETURN_KEY2] = "no smartctl cmd"
    RJPRINT(RET[RETURN_KEY2])
    thread_tmp = threading.Thread(target=countdown)
    thread_tmp.setDaemon(True)
    thread_tmp.start()
    return RET

def abort_ssd_stress():
    RET = {RETURN_KEY1 : 1,  RETURN_KEY2 : ""}
    cmd = "smartctl -X /dev/sda"

    ret, log = log_os_system("which smartctl", 0)
    if len(log):
        # smartctl Built-in background detection
        # by to smartctl -l selftest  /dev/sda look
        os.system(cmd)
        global ssd_status
        ssd_status = 3
        time.sleep(1)
        RET[RETURN_KEY2] = "该后台测试已被终止"
    else:
        RET[RETURN_KEY2] = "no smartctl cmd"
    RJPRINT(RET[RETURN_KEY2])
    return RET

def force_abort_ssd_stress():
    log_os_system("smartctl -X /dev/sda", 0)

def get_ssd_stress_result():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    cmd = "smartctl -l selftest  /dev/sda "

    ret, log = log_os_system("which smartctl", 0)
    global ssd_status
    if ssd_status == 1:
        RET = {RETURN_KEY1: 1, RETURN_KEY2: "后台ssd测试还未结束，请稍等"}
        RJPRINT(RET[RETURN_KEY2])
        return RET
    elif ssd_status == 0:
        RET = {RETURN_KEY1: 1, RETURN_KEY2: "未执行后台ssd测试"}
        RJPRINT(RET[RETURN_KEY2])
        return RET
    if len(log):
        ret, logout = rj_os_system(cmd)
        tmpval = ''
        for line in logout.splitlines():
            if "# 1" in line:
                tmpval = line
                break
        if tmpval == '' or 'Completed without error' not in tmpval:
            RJPRINT(logout)
            RET[RETURN_KEY1] =  -1
            RET[RETURN_KEY2] =  logout
        else:
            RJPRINT(tmpval)
            RET[RETURN_KEY1] = 0
    else:
        RET[RETURN_KEY2] = "no smartctl cmd"
    # RJPRINT(RET[RETURN_KEY2])
    return RET



def test_kr_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       print ("\n\n第 %d/%d 次测试"%(i+1, test_times))
       RET1 = test_kr()
       print_temp_flush()
       totalerr += RET1[RETURN_KEY1]
       RET[RETURN_KEY2] += RET1[RETURN_KEY2]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def test_subprocess_run():
    RET = {RETURN_KEY1 : 1,  RETURN_KEY2 : "开始子进程后台测试"}
    if subprocess_case.is_running() or subprocess_case.is_stopping():
        RET[RETURN_KEY2] = "已存在后台测试"
        RJPRINT(RET[RETURN_KEY2])
    else:
        subprocess_case.start_run_bgtest()
    return RET

def test_subprocess_stop():
    RET = {RETURN_KEY1: 1, RETURN_KEY2: "结束子进程后台测试"}
    if subprocess_case.is_running():
        subprocess_case.shutdown_bgtest()
    else:
        RJPRINT("未进行后台测试")
        # exit
    return RET

def test_subprocess_result():
    RET = {RETURN_KEY1: 1, RETURN_KEY2: "查看子进程后台测试结果"}
    if subprocess_case.is_undo():
        res = subprocess_case.get_all_message()
        if res == "":
            RJPRINT("未执行后台测试")
            return RET
        else:
            RJPRINT(res)
        if "Fail" in res:
            RET[RETURN_KEY1] = -1
        else:
            RET[RETURN_KEY1] = 0
    else:
        RJPRINT("后台测试正在运行，请稍后查看")
    return RET

class BackgroundOperation():
    UNDO             = 0 # Background test items were not executed
    DOING            = 1 # Tests are running in the background
    STOPPING         = 2 # Closing background test items
    StatusFlag       = None # Current status of the child process
    lock             = None # Shared memory lock
    message          = None # Store test log
    bgmenulist       = None # A menu list of background tests
    subprocess_obj   = None #  child process
    record_file      = "/tmp/out.txt"  # Background test output is rerouted
    def __init__(self):
        self.lock = multiprocessing.Lock()
        self.StatusFlag = multiprocessing.Value('i', self.UNDO) #  initial undo
        self.message = multiprocessing.Queue()
        self.bgmenulist = TESTCASE.get("BackgroundMenuList", None)

    @staticmethod
    def paren_proce_status(): # child process starts a thread to determine if the parent process exits unexpectedly (taken over by process 1), and then exits
        while True:
            log_debug("subprocess ppid %d" % os.getppid())
            if os.getppid() == 1:
                log_debug("parent process  aborted, kill subprocess self")
                cmd = "kill -9 %d" % os.getpid()
                os.system(cmd)
            time.sleep(1)

    def subprocess_real(self):
        RET = {RETURN_KEY1: -1, RETURN_KEY2: ""}
        thread_tmp = threading.Thread(target=BackgroundOperation.paren_proce_status)
        thread_tmp.setDaemon(True)
        thread_tmp.start()
        data = self.bgmenulist
        stdout = sys.stdout
        with open(self.record_file, 'w+') as file:
            sys.stdout = file
            try:
                totalresult = ""
                if data is None:
                    RJPRINT("获取后台测试用例错误")
                    self.turn_undo()
                    return RET
                for item in data:  # todo Consider test items before and after
                    if self.is_stopping():
                        formatstr = "======%%-%ds 因用户终止未执行\n" % ((40 + wide_chars(item[MENUITEMNAME])))
                        totalresult += formatstr % item[MENUITEMNAME]
                        continue
                    RJPRINT(item[MENUITEMNAME])
                    RET = eval(item[MENUITEMDEAL])()
                    if RET[RETURN_KEY1] == 0:
                        RJPRINT("Test Result: " + SUCCESS_TIPS + '\n\n')
                        formatstr = "======%%-%ds Test Result: %s\n" % ((40 + wide_chars(item[MENUITEMNAME])), SUCCESS_TIPS)
                        totalresult += formatstr % (item[MENUITEMNAME])
                    elif RET[RETURN_KEY1] == 1:
                        pass
                    elif RET[RETURN_KEY1] == -1:
                        RJPRINT("Test Result: Fail" + '\n\n')
                        formatstr = "======%%-%ds Test Result: Fail\n" % ((40 + wide_chars(item[MENUITEMNAME])))
                        totalresult += formatstr % item[MENUITEMNAME]
                    RJPRINT("==============================================================")
                RJPRINT(totalresult)
            except Exception as e:
                msg = traceback.format_exc()
                RJPRINT(msg)
            finally:
                self.turn_undo()
                sys.stdout = stdout
        return RET

    def start_run_bgtest(self):
        keep_val = sys.stdin
        sys.stdin = subprocess.PIPE
        self.turn_doing()
        self.subprocess_obj = multiprocessing.Process(target=self.subprocess_real)
        self.subprocess_obj.daemon = True
        self.subprocess_obj.start()
        sys.stdin = keep_val
        print ("已开始后台测试，部分测试项不可访问")

    def put_message(self, str, newline = True):
        if newline:
            self.message.put(str + '\n')
        else:
            self.message.put(str)

    def get_message(self):
        return self.message.get()

    def get_all_message(self):
        if os.path.exists(self.record_file) is False:
            return ""
        with open(self.record_file, 'r') as fd:
            return fd.read()


    def turn_doing(self):
        with self.lock:
            self.StatusFlag.value = self.DOING

    def turn_undo(self):
        with self.lock:
            self.StatusFlag.value = self.UNDO

    def turn_stoping(self):
        with self.lock:
            self.StatusFlag.value = self.STOPPING

    def is_running(self):
        with self.lock:
            if self.StatusFlag.value == self.DOING:
                return True
            else:
                return False

    def is_undo(self):
        with self.lock:
            if self.StatusFlag.value == self.UNDO:
                return True
            else:
                return False

    def is_stopping(self):
        with self.lock:
            if self.StatusFlag.value == self.STOPPING:
                return True
            else:
                return False

    def print_bgtest_name(self, newline =True):# Prints tests that need to be run in the background
        tmp = ""
        for item in self.bgmenulist:
            tmp += item[MENUITEMNAME]
            if newline:
                tmp += "\n"
        return tmp

    def print_result(self, str):
        if self.is_undo():
            print (str)
        else:
            self.put_message(str)

    def shutdown_bgtest(self):
        with self.lock:
            if self.StatusFlag.value == self.DOING:
                print ("正在等待后台进程结束，请稍等")
                self.StatusFlag.value = self.STOPPING
        while self.is_stopping():
            sys.stdout.write(".")
            sys.stdout.flush()
            time.sleep(2)
subprocess_case = BackgroundOperation()

def print_menulist_before_choose():
    RJPRINT("以下测试项将进入后台测试：")
    RJPRINT(subprocess_case.print_bgtest_name())
    return True, ''

def test_opt_module_e2_read():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    pass_list = []
    failed_list = []
    empty_str = "      "
    ret, log = log_os_system("show interfaces transceiver eeprom | grep -a -E '^Ethernet'", 0)
    if ret:
       RET[RETURN_KEY1] = -1
       return RET
    log,times = re.subn("SFP EEPROM detected","PASS",log)
    log,times = re.subn("SFP EEPROM not detected","FAILED",log)
    log,times = re.subn("Ethernet\d{1,3}","",log)

    if len(log) == 0:
       RET[RETURN_KEY1] = -1
       return RET

    dev_list = log.split("\n")
    i = 1
    for dev in dev_list:
        if "FAILED" in dev:
            failed_list.append(i)
        else:
            pass_list.append(i)
        i += 1
    if len(pass_list) >0:
        port_totalprint(pass_list, "OK")
    if len(failed_list) > 0:
        port_totalprint(failed_list, "failed")
        tmpstr = '\nFAILED:\n'
        tmpstr += empty_str
        for i in range(len(failed_list)):
            tmpstr +="%-5s"% failed_list[i]
            if((i + 1) %8 == 0):
                tmpstr +="\n"
                tmpstr += empty_str
        tmpstr += ""
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = tmpstr
        return RET

    return RET


def test_lpc():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ''

    items = []
    for item in CPLDVERSIONS:
        if item.get("gettype", None) == 'io':
            items.append(item)

    if len(items) > 0:
        RJPRINT("LPC读写CPLD测试:")

    for it in items:
        addr = it.get('io_addr')
        name = it.get('name')
        testaddr = 0
        RJPRINT(name)
        if name == 'X86_CPLD' or name == 'CPU板CPLD':
            testaddr = addr + 0x05
        else:
            testaddr = addr +  0xaa
        for wr_byte in [0x5a,0xa5]:
            ret = io_wr(testaddr, wr_byte)
            ret = io_rd(testaddr)
            if wr_byte != int(ret,16):
                totalerr -= 1
                msg = "    写入%x，读出%x"%(wr_byte, int(ret,16))
                RJPRINT(msg)
                RJPRINT("    FAILED")
                errmsg += "%s %s \n" % (errmsg, msg)
            else:
                msg = "    写入%x，读出%x"%(wr_byte, int(ret,16))
                RJPRINT(msg)
                RJPRINT("    PASS")
        RJPRINT("\r\n")
    lpc_item = TESTCASE.get("LPC",[])
    for item in lpc_item:
        RJPRINT("LPC读写%s测试:"%item['name'])
        addr = item.get('addr')
        for wr_byte in [0x5a,0xa5]:
            ret = io_wr(addr, wr_byte)
            ret = io_rd(addr)
            if wr_byte != int(ret,16):
                totalerr -= 1
                msg = "    写入%x，读出%x"%(wr_byte, int(ret,16))
                RJPRINT(msg)
                RJPRINT("    FAILED")
                errmsg += "%s %s \n" % (errmsg, msg)
            else:
                msg = "    写入%x，读出%x"%(wr_byte, int(ret,16))
                RJPRINT(msg)
                RJPRINT("    PASS")
        RJPRINT("\r\n")
    if bmc_presence_check():
        ret, log = lpc_test_bmc()
        totalerr += ret
        errmsg += log

    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def lpc_test_bmc():
    totalerr = 0
    Silicon_Revision = 0x1E6E207C # Silicon Revision ID Register
    ret, val = LPCTool().read_bmc_reg_32(Silicon_Revision)
    RJPRINT("LPC读写BMC测试:")
    if ret is False:
        RJPRINT("    FAILED")
        totalerr -= 1
    else:
        RJPRINT("    PASS")
    return totalerr, val

def test_MDIO_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 :""}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       RJPRINT("\n\n第 %d/%d 次测试"%(i+1, test_times))
       func = "bmc_test_MDIO"
       RET1 = test_bmc_testcase(func)
       totalerr += RET1[RETURN_KEY1]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def test_lpc_stress():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    totalerr = 0
    test_times = 10
    for i in range(0, test_times):
       RJPRINT("\n\n第 %d/%d 次测试"%(i+1, test_times))
       RET1 = test_lpc()
       # print_temp_flush()
       totalerr += RET1[RETURN_KEY1]
       RET[RETURN_KEY2] += RET1[RETURN_KEY2]
    if totalerr < 0:
       RET[RETURN_KEY1] = -1
    return RET

def lpc_test_cpld(retry_times = 1):
    items = []
    totalerr = 0
    for item in CPLDVERSIONS:
        if item.get("gettype", None) == 'io':
            items.append(item)
    if len(items) > 0:
        RJPRINT("LPC读写CPLD测试:")
    for i in range(0, retry_times):
        err_flag = False
        for it in items:
            keep_str = ""
            addr = it.get('io_addr')
            name = it.get('name')
            if i == 0:
                it.update({'info': ""})
                it['info'] += "    写入5a，读出5a\n    PASS\n"
                it['info'] += "    写入a5，读出a5\n    PASS\n"
            if name == 'X86_CPLD' or name == 'CPU板CPLD':
                testaddr = addr + 0x05
            else:
                testaddr = addr +  0xaa
            for wr_byte in [0x5a,0xa5]:
                io_wr(testaddr, wr_byte)
                ret = io_rd(testaddr)
                if wr_byte != int(ret,16):
                    keep_str += "    写入%x，读出%x\n"%(wr_byte, int(ret,16))
                    keep_str += "    FAILED"
                    keep_str += "\r\n"
                    err_flag = True
            if keep_str != "":
                it['info'] = keep_str
        if err_flag:
            totalerr += 1
    for it in items:
        RJPRINT(it.get('name'))
        RJPRINT(it['info'])
    return totalerr

def lpc_test_cpu_cpld(retry_times = 1):
    totalerr = 0
    lpc_item = list(TESTCASE.get("LPC",[]))
    for i in range(0, retry_times):
        err_flag = False
        for item in lpc_item:
            addr = item.get('addr')
            keep_str = ""
            if i == 0:
                item.update({'info':""})
                item['info'] += "    写入5a，读出5a\n    PASS\n"
                item['info'] += "    写入a5，读出a5\n    PASS\n"
            for wr_byte in [0x5a, 0xa5]:
                io_wr(addr, wr_byte)
                ret = io_rd(addr)
                if wr_byte != int(ret, 16):
                    keep_str += "    写入%x，读出%x\n" % (wr_byte, int(ret, 16))
                    keep_str += "    FAILED"
                    keep_str += "\r\n"
                    err_flag = True
            if keep_str != "":
                item['info'] = keep_str
        if err_flag:
            totalerr +=1
    for item in lpc_item:
        RJPRINT("LPC读写%s测试:" % item['name'])
        RJPRINT(item['info'])
    return totalerr

def lpc_test_bmc_new(retry_times = 1):
    lcptool = LPCTool()
    Silicon_Revision = 0x1E6E207C  # Silicon Revision ID Register\
    totalerr = 0
    if bmc_presence_check() is False:
        return totalerr

    keep_str = ""
    keep_str += "LPC读写BMC测试:\n"
    keep_str += "    PASS\n"
    for i in range(0, retry_times):
        ret, val = lcptool.read_bmc_reg_32(Silicon_Revision)
        if ret is False:
            keep_str = ""
            keep_str += "LPC读写BMC测试:\n"
            keep_str += "    FAILED\n"
            totalerr += 1
    RJPRINT(keep_str)
    return totalerr

def test_lpc_stress_new():
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    test_times = TESTCASE.get("lpc_test_times", 100)
    err1 = lpc_test_cpld(test_times)
    err2 = lpc_test_cpu_cpld(test_times)
    err3 = lpc_test_bmc_new(test_times)
    totalerr = err2
    if err1 > err2:
        totalerr = err1
    if totalerr < err3:
        totalerr = err3
    RJPRINT("LPC %d次压力测试" % test_times)
    RJPRINT("PASS TIMES：%d" % (test_times - totalerr))
    RJPRINT("FAILED TIMES：%d" % totalerr)
    if totalerr != 0:
        RET[RETURN_KEY1] = -1
    return RET

def createbmcMac(cpumac , num = 2):
    cpumacvalue = int(cpumac.replace(":",""),16)
    bmcmacvalue = cpumacvalue + 2

    len = 6
    s =[''] * len
    for i in range(len):
        tmpval = bmcmacvalue & 0xff
        s[len - i - 1] = "%02x" % tmpval
        bmcmacvalue = bmcmacvalue >> 8

    bmcmac = ":".join(s)
    return  bmcmac.upper()

def ipmi_set_mac(mac):
    if fac_init_check_ipmi() == True:
        macs = mac.split(":")
        cmdinit = "ipmitool raw 0x0c 0x01 0x01 0xc2 0x00"
        cmdset = "ipmitool raw 0x0c 0x01 0x01 0x05"
        for ind in range(len(macs)):
            cmdset += " 0x%02x" % int(macs[ind], 16)
        rj_os_system(cmdinit)
        ret, status = rj_os_system(cmdset)
        if ret:
            RJPRINTERR("\n\n%s\n\n" % status)
            return False
        return True
    else:
        return False

def test_bios_flash():
    '''Verify this by reading the active and standby BIOS versions'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : "","master":"","slave":""}
    file_path = TESTCASE.get("BIOS_INFO",None)
    if file_path == None:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "No BIOS flash test case."
        return RET
    try:
        with open(file_path, 'r') as fd:
            log = fd.read().strip()
        # RJPRINT(log)
        if "master" not in log.lower() or "slave" not in log.lower():
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = "No master/slave BIOS version!"
            return RET
        version = log.split("\n",1)
        for version_item in version:
            bios_version = version_item.split(":",1)
            if len(bios_version) != 2 or len(bios_version[1].strip()) == 0:
                RET[RETURN_KEY1] -= 1
                if "master" in bios_version[0]:
                    RET[RETURN_KEY2] += "master BIOS version read error!\n"
                else:
                    RET[RETURN_KEY2] += "slave BIOS version read error!\n"
                continue
            if "master" in bios_version[0]:
                RET["master"] = bios_version[1].strip()
            else:
                RET["slave"] = bios_version[1].strip()
    except Exception as error:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = str(error)
    return RET

def get_bios_info():
    biosstatusdecode = TESTCASE.get("biosstatusdecode",None)
    biosstatus = TESTCASE.get("biosstatus",None)

    if biosstatus is None or biosstatusdecode is None:
        return None

    if biosstatus["gettype"] == "i2c":
        bus = biosstatus["bus"]
        loc = biosstatus["loc"]
        reg = biosstatus["reg"]
        ind, val = rji2cget(bus, loc,reg)
        if ind == False:
            val = None
    else:
        io_addr = biosstatus.get('io_addr')
        val = io_rd(io_addr)
    if val is not None:
        bitmask = biosstatus["bitmask"]
        val_t = int(val,16) & bitmask
        if val_t not in biosstatusdecode.keys():
            return None
        return biosstatusdecode.get(val_t,None)
    return None

def test_bios_force_switch(bios_info, cpu = False):
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    log = get_bios_info()

    if log == None:
        RET[RETURN_KEY1] = -1
        RJPRINT("获取BIOS信息失败")
        return RET
    elif bios_info in log:
        RJPRINT("已是%s，无需切换"%bios_info,False)
        RET[RETURN_KEY1] = 0
        return RET

    if bios_info == "master":
        switch_mod = 0
    else:
        switch_mod = 1

    if makesure("切换BIOS会导致X86重启，是否继续？[Yes/No]：",True,echo = True):
        func = "test_bmc_bios_switch"
        if cpu == False:
            ret = test_bmc_func(func,switch_mod)
            return ret
        else:
            test_bios_swtch(switch_mod)
    else:
        print ("已撤销")
        RET[RETURN_KEY1] = -1
    return RET

def test_bios_force_switch_slave():
    return test_bios_force_switch("slave")

def test_bios_force_switch_master():
    return test_bios_force_switch("master")

def test_cpu_bios_force_switch_slave():
    return test_bios_force_switch("slave", True)

def test_cpu_bios_force_switch_master():
    return test_bios_force_switch("master", True)

def test_bmc_command(param):    
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    cmd = param.get("cmd",None)
    func = param.get("bmc_interface",None)
    if cmd == None or func == None:
        RET[RETURN_KEY1] = -88
        RET[RETURN_KEY2] = "获取配置文件错误"
    else:
        ret = test_bmc_func(func,cmd)
        if ret.get(RETURN_KEY1) == -1 or len(ret.get(RETURN_KEY2)) == 0:
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = "获取固件版本号 测试失败\nmessage:%s" % (ret.get(RETURN_KEY2))
        else:
            RET[RETURN_KEY1] = 0
            RET[RETURN_KEY2] = ret.get(RETURN_KEY2)
    RJPRINT(RET[RETURN_KEY2])
    return RET

def test_bmc_5387MD5():
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    cmd = TESTCASE.get("eeprom5387_bmc",{}).get("cmd",None)
    func = TESTCASE.get("eeprom5387_bmc",{}).get("bmc_interface",None)
    if cmd == None or func == None:
        RET[RETURN_KEY1] = -88
        RET[RETURN_KEY2] = "获取配置文件错误"
    else:
        ret = test_bmc_func(func,cmd)
        if ret.get(RETURN_KEY1) == -1 or len(ret.get(RETURN_KEY2)) == 0:
            RET[RETURN_KEY1] = -1
            RET[RETURN_KEY2] = "获取固件版本号 测试失败\nmessage:%s" % (ret.get(RETURN_KEY2))
        else:
            RET[RETURN_KEY1] = 0
            RET[RETURN_KEY2] = ret.get(RETURN_KEY2)
    RJPRINT(RET[RETURN_KEY2])
    return RET

def test_bios_swtch(switch_mod):
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    # switch BIOS
    BIOS_TEST = TESTCASE.get("BIOS_TEST", None)
    if BIOS_TEST is None:
        RET = {RETURN_KEY1: -1, RETURN_KEY2: "no find config"}
        return RET
    if switch_mod == 0:    # switch to master BIOS
        switch_oplist = BIOS_TEST.get("switch_master",[])
    elif switch_mod == 1:    # switch to slave BIOS
        switch_oplist = BIOS_TEST.get("switch_slave",[])
    else:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "switch_mod error!"
        return RET
    for switch_opitem in switch_oplist:
        type = switch_opitem.get("gettype", "i2c")
        if type == "i2c":
            bus = switch_opitem["bus"]
            loc = switch_opitem["loc"]
            reg = switch_opitem["reg"]
            val = switch_opitem["val"]
            ret,log = rji2cset(bus,loc,reg,val)
            if ret == False:
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = "switch i2c write failed!"
                return RET
        elif type == "io":
            io_addr = switch_opitem["io_addr"]
            val = switch_opitem["val"]
            ret = io_wr(io_addr, val)
            if ret == False:
                RET[RETURN_KEY1] = -1
                RET[RETURN_KEY2] = "switch i2c write failed!"
                return RET
        elif type == "func":
            funcname = eval(switch_opitem["funcname"])
            ret, msg = funcname()
            if ret is False:
                RET[RETURN_KEY1] = -1
                log_debug("switch bios func fail %s" % switch_opitem["funcname"])
                return RET
    return RET

def readsysfs(location):
    try:
        locations = glob.glob(location)
        with open(locations[0], 'r') as fd1:
            val = fd1.read()
    except Exception as e:
        return False, (str(e)+" location[%s]" % location)
    return True, val

def test_dcdc():
    RET = {RETURN_KEY1: 0, RETURN_KEY2: ""}
    totalerr = 0
    errmsg = ""
    resultval = []

    items = TESTCASE.get("dcdcsensor", None)
    if items is None:
        RET[RETURN_KEY1] = -999
        RET[RETURN_KEY2] = 'config error'
        return RET

    # get dcdcsensor value
    for item in items:
        Sensor = item.get('Sensor', None)
        Address = item.get('Address', None)
        min = item.get('CriticalLow', None)
        max = item.get('CriticalHigh', None)
        Unit = item.get('Unit', "")
        format = item.get("format", None)
        gettype = item.get("gettype", None)
        if gettype == "sysfs":
            location = item.get("location", "error_url")
            ret,ind = readsysfs(location)
        elif gettype == "pagei2cword":
            bus = item.get('bus')
            devno = item.get('devno')
            offset = item.get('addr')
            select = item.get('select')
            slectvalue = item.get('slectvalue')
            rji2cset(bus, devno, select, slectvalue)
            ret, ind = rji2cgetWord(bus, devno, offset)
            if ret == False:
                val = None
            else:
                val = ind.replace("0x", "").replace("0X", "")
        else:
            pass
        if ret == True:
            val = ind.replace("\n", "")
            if format is not None:
                tmp = format % val
                val_tmp = eval(tmp)
            else:
                val_tmp = int(val, 10)
            if min < val_tmp < max:
                statusmsg = "OK"
            else:
                totalerr -= 1
                statusmsg = 'Not OK'
        else:
            totalerr -= 1
            statusmsg = 'Not OK'
            val_tmp = "fail "
            Unit = ""
            log_debug("get dcdc value fail %s", Sensor)
        resultval.append([Sensor, Address, statusmsg, "%s%s"%(val_tmp, Unit), "%s%s"%(min, Unit), "%s%s"%(max, Unit)])

    # print
    header = ['Sensor', 'Address', 'State', 'Value', 'CriticalLow', 'CriticalHigh']
    result = tabulate(resultval, header, tablefmt='simple')
    RJPRINT(result)
    if totalerr < 0:
        errmsg += str(result)

    RET[RETURN_KEY1] = totalerr
    RET[RETURN_KEY2] = errmsg
    return RET

def test_bmc_sol():
    '''Serial Port (SOL) test between the CPU and BMC'''
    RET = {RETURN_KEY1 : 0, RETURN_KEY2 : ""}
    cur_time = time.time();
    timeArray = time.localtime(cur_time)
    otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArray)
    teststr = 'SOL test,current time:%s' % otherStyleTime
    cmd = "echo '%s' > /dev/ttyS0" % teststr
    log_os_system(cmd,0)
    time.sleep(1)
    
    func = 'bmc_log_os_system'
    cmd = "cat /var/log/obmc-console.log | grep '%s'" % teststr
    ret = test_bmc_func(func,cmd)
    if ret.get(RETURN_KEY1) == -1 or len(ret.get(RETURN_KEY2)) == 0:
        RET[RETURN_KEY1] = -1
        RET[RETURN_KEY2] = "SOL 测试失败\nmessage:%s" % (ret.get(RETURN_KEY2))
    else:
        RET[RETURN_KEY1] = 0
        RET[RETURN_KEY2] = "SOL 测试成功"
    RJPRINT(RET[RETURN_KEY2])
    return RET


def fac_check_eth_mac():
    '''Check whether I210 and MAC can be detected'''
    totalerr = 0
    errmsg = ""
    for pci in PCIe_SPEED_ITEM:
        try:
            status, output = log_os_system("lspci|grep %s | wc -l"%pci["PCIe_name"], 0)
            if output.isdigit() and int(output) == 0:
                totalerr -= 1
                RJPRINT("%s can't find!" % pci["PCIe_name"])
        except Exception as error:
             totalerr -= 1
             errmsg = str(error)
             RJPRINT("errmsg")
    if totalerr < 0:
        quit()

def cpld_init():
    '''Write the CPLD register to initialize the CPLD'''
    items = TESTCASE.get("init_param",{}).get("CPLD",None)
    if items == None:
        return True
    try:
        for item in items:
            if item.get("gettype") == "i2c":
                bus = item["bus"]
                loc = item["loc"]
                reg = item["reg"]
                val = item["val"]
                ret, log = rji2cset(bus, loc, reg, val)
                if ret == False:
                    RJPRINT("Write cpld falied,bus:%d,loc:0x%2x,reg:0x%2x,value:0x%2x" %(bus,loc,reg,val))
                    return False
            else:
                pass
    except Exception as error:
        errmsg = str(error)
        RJPRINT("errmsg")
        return False
    return True

def usb0_init():
    '''Set the IP address of USB0'''
    usbip = TESTCASE.get("SONIC",{}).get("ip","1.1.1.1")
    cmd = "ifconfig usb0 %s netmask 255.255.255.0" % usbip
    ret,log = log_os_system(cmd, 0)
    if ret or "ERROR" in log:
        return False
    return True

class IniRdwr():
    from ConfigParser import ConfigParser
    path = '/tmp/.status.ini'
    config = None
    def __init__(self):
        self.config = ConfigParser.ConfigParser()
        self.config.read(self.path)

    def check_section(self, section):
        return self.config.has_section(section)

    def check_option(self, section, option):
        return self.config.has_option(section, option)

    def rd_ini_option(self, section, option, type = "str"):
        self.config.read(self.path)
        if self.check_option(section, option) is False:
            return False, 'no section or option in %s' % self.path
        if type == 'int':
            value = self.config.getint(section, option)
        elif type == 'bool':
            value = self.config.getboolean(section, option)
        elif type == "float":
            value = self.config.getfloat(section, option)
        elif type == "str":
            value = self.config.get(section, option)
        else:
            return False, 'error para'
        return True, value

    def wr_ini_option(self, section, option, value):
        if self.check_section(section) is False:
            self.config.add_section(section)
        self.config.set(section, option, value)
        with open(self.path, "w") as f:
            self.config.write(f)
        return True, "success"

def bmc_presence_check():
    obj = IniRdwr()
    ret, val = obj.rd_ini_option("bmc", "bmc_present", "bool")
    if ret and val:
        return True
    else:
        return False

def psu_check():
    '''Power supply anti-freeze detection'''
    RET = {RETURN_KEY1 : 0,  RETURN_KEY2 : ""}
    totalerr = 0
    errmsg = ""
    psus =  FRULISTS.get('psus',[])
    psucheckitem = TESTCASE.get("firmware_check",{}).get("psus",None)

    if psucheckitem == None: # No power check item
        return True
    psutypes = psucheckitem.get("psutype")
    for psu in psus:
        psuscheck = False
        try:
            eeprom = I2CUTIL.dumpValueByI2c(psu.get('bus'), psu.get('loc'))
            if eeprom is None:
                continue
            fru = ipmifru()
            fru.decodeBin(eeprom)
            realtype = fru.productInfoArea.productPartModelName.strip()
            for type in psutypes:
                if type in realtype:   # match is successful
                    psuscheck = True
                    break
            if psuscheck == False:
                RJPRINT("%s 电源类型不匹配，请检查!" % psu.get("name"))
                totalerr -= 1
        except Exception as e:
            errmsg = " %s %s %s \n" %(errmsg, psu.get('name'), str(e))
            continue

    if totalerr < 0:
        RJPRINT("检测错误，无法启动生测程序!请使用以下型号电源进行测试:")
        for type in psutypes:
            RJPRINT(type)
        quit()
    return  True

def fac_check_rtc():
    try:
        time1 = time.time();
        timeArraystart = time.localtime(time1)
        otherStyleTime = time.strftime("%Y-%m-%d %H:%M:%S", timeArraystart)
        log_debug("当前时间:%s" % otherStyleTime)
        time_t = otherStyleTime.split("-")
        time_year = int(time_t[0].strip())
        log_debug("当前时间:%d年" % time_year)
        if time_year <= 2000:
            RJPRINT("当前时间:%s,请先进入系统配置,设置RTC" % otherStyleTime)
    except Exception as e:
        log_debug(str(e))
        pass

class LPCTool():
    REG_ADDR = None
    REG_DATA = None

    def __init__(self, reg_addr = 0x4E, re_data = 0x4F):
        self.REG_ADDR = reg_addr
        self.REG_DATA = re_data
        self.disable_sio_val = 0xAA
        self.enable_sio_val = 0xA5
        self.SIORx_07 = 0x07
        self.SIORD_30 = 0x30
        self.ldu_0d_val = 0x0D # Select LDU 0D (iLPC2AHB-LPC to AHB bus bridge)
        self.SIORD_F8 = 0xF8
        self.sio_length_4 = 0x02
        self.PORT_ADDR = "/dev/port"

    def dis_ilpc2ahb(self):
        try:
            # disabled ilpc2ahb
            self.seek_addr(self.SIORD_30)
            self.port_write(self.REG_DATA, 0x00)
            # dis_superio
            self.seek_addr(self.disable_sio_val)
        except Exception as error:
            RJPRINT("dis_ilpc2ahb fail:" + str(error))

    def en_ilpc2ahb(self):
        try:
            # dis_superio
            self.seek_addr(self.disable_sio_val)
            # en_superio
            self.seek_addr(self.enable_sio_val)
            self.seek_addr(self.enable_sio_val)
            # enable bmc ilpc2ahb
            self.seek_addr(self.SIORx_07)
            self.port_write(self.REG_DATA, self.ldu_0d_val)

            self.seek_addr(self.SIORD_30)
            self.port_write(self.REG_DATA, 0x01)
            self.seek_addr(self.SIORD_F8)
            val = self.port_read(self.REG_DATA)
        except Exception as error:
            RJPRINT("en_ilpc2ahb fail:" + str(error))
            return False, None
        if int(val, 16) & 0x03 != self.sio_length_4:
            return False, val
        return True, val

    def port_read(self, offset, size=1):
        ret = None
        with open(self.PORT_ADDR, "rb") as f:
            f.seek(offset)
            ret = f.read(size)
        # return ret
        return "".join(["{:02x}".format(ord(item)) for item in ret])

    def port_write(self, offset, val):
        if isinstance(val, int):
            val = chr(val)

        with open(self.PORT_ADDR, "r+b") as f:
            f.seek(offset)
            f.write(val)
            f.flush()

    def write_32bit_val(self, addr):
        address_base = 0xF0 # reg for access address
        for i in range(4):
            self.seek_addr(address_base + i)
            bit = 32 - (i + 1) * 8
            self.port_write(self.REG_DATA, addr >> bit & 0xFF)

    def seek_addr(self, addr):
        self.port_write(self.REG_ADDR, addr)

    def read_bmc_reg_32(self, addr):
        try:
            value_address_base = 0xF4 # reg for value address
            ret, _ = self.en_ilpc2ahb()
            if ret is False:
                return ret, ""
            self.write_32bit_val(addr)
            self.seek_addr(0xFE)
            ret = self.port_read(self.REG_DATA)
            val = ""
            for i in range(4):
                self.seek_addr(value_address_base + i)
                val += self.port_read(self.REG_DATA)
            self.dis_ilpc2ahb()
        except Exception as error:
            RJPRINT("read_bmc_reg_32 fail:" + str(error))
            return False, ""
        return True, val

def fac_check_bmc_status():
    try:
        lpctool = LPCTool()
        ret, val = lpctool.en_ilpc2ahb()
        obj = IniRdwr()
        if ret is False and val == "ff":
            obj.wr_ini_option("bmc","bmc_present","False")
        elif ret is True:
            obj.wr_ini_option("bmc","bmc_present","True")
    except Exception as e:
        RJPRINT(str(e))
    finally:
        lpctool.dis_ilpc2ahb()

def reboot_system():
    ret, msg = rj_os_system("reboot -f")
    if ret == 0:
        return True, msg
    return False, msg

def firmware_check():
    # Power supply anti-freeze detection
    psu_check()
    # I210 and MAC detection
    fac_check_eth_mac()
    # RTC detection
    fac_check_rtc()
    # BMC status detection
    fac_check_bmc_status()

def fac_firmware_init():
    cpld_init()

def factest_check(argv):
    global DIAGTEST
    if len(argv) == 2 and argv[1] == 'diag':
        DIAGTEST = True
        bmcmac = getBMCMAC()
        RJPRINT("BMC MAC【%s】" % bmcmac)
    else:
        pass

## Production test master program
if __name__ == '__main__':
    # ApplicationInstance()
    # print sys.getdefaultencoding()
    # print sys.getfilesystemencoding()
    # import locale
    # print locale.getdefaultlocale()
    root_check()
    factest_check(sys.argv)
    fac_init()
    log_info("生产测试主程序")
    start()
