#!/usr/bin/env python
# -*- coding: utf-8 -*-

import re
from os import popen
from sys import path, exit, stderr
from commands import getstatusoutput
from  ragileconfig import *
from monitor import status
import mmap


INDENT = 4

def printerr(vchar):
    stderr.write(vchar + '\n')

g_extra_cache = dict()
g_meminfo_cache = dict()
g_exphy_cache = dict()

def exphyfwsplit():
    # improve performance
    global g_exphy_cache
    if g_exphy_cache:
        return
    cmd = "bcmcmd -t 1 \"phy control xe,ce fw_get\" |grep fw_version"
    status, output = log_os_system(cmd)
    if status or len(output) == 0:
        raise Exception("run cmd: {} error, status {}".format(cmd, status))
    exphyfwstr = output.strip()
    portlist = exphyfwstr.split("\n")
    for port in portlist:
        phy_addr_str = get_regular_val(port,r"phy_addr\s*=\s*\w+",0)
        if phy_addr_str.startswith("ERR"):
            continue
        phy_addr_key = phy_addr_str.replace(" ","")
        if phy_addr_key in g_exphy_cache:
            continue
        
        g_exphy_cache[phy_addr_key] = {}
        
        fw_version_str = get_regular_val(port,r"fw_version\s*=\s*\w+",0)
        if fw_version_str.startswith("ERR"):
            del g_exphy_cache[phy_addr_key]
            continue

        fw_version = fw_version_str.split("=")[1].strip()
        g_exphy_cache[phy_addr_key]["fw_version"] = fw_version
        
        if "success" in port:
            status = "OK"
        else:
            status = "Unexpected"
        g_exphy_cache[phy_addr_key]["status"] = status
    return

def get_exphy_fw(phyid):
    exphyfwsplit()
    if phyid not in g_exphy_cache:
        return "ERR %s not found." % phyid
    fw_version = g_exphy_cache.get(phyid).get("fw_version")
    status = g_exphy_cache.get(phyid).get("status")
    msg = "%s    %s" % (fw_version, status)
    return msg
    
def lshwmemorysplit():
    # improve performance
    global g_meminfo_cache
    if g_meminfo_cache:
        return
    cmd = "lshw -c memory"
    status, output = log_os_system(cmd)
    if status or len(output) == 0:
        raise Exception("run cmd: {} error, status {}".format(cmd, status))
    memstr = output.strip()
    memlist = memstr.split("*-")
    for item in memlist:
        if item.strip().startswith("memory") and "System Memory" not in item:
            continue
        line_index = 0
        for line in item.splitlines():
            line_index += 1
            if line_index == 1:
                memdict_key = line
                g_meminfo_cache[memdict_key] = {}
            else:
                if ":" not in line:
                    continue
                key = line.split(":", 1)[0].strip()
                value = line.split(":", 1)[1].strip()
                g_meminfo_cache[memdict_key][key] = value
            if "empty" in item:
                break
    return


def run_extra_func(funcname):
    # improve performance
    if g_extra_cache.__contains__(funcname):
        return g_extra_cache.get(funcname)
    func = getattr(status, funcname)
    ret = []
    func(ret)
    if ret:
        g_extra_cache[funcname] = ret
    return ret


def get_extra_value(funcname, itemid, key):
    for item in run_extra_func(funcname):
        if item.get("id") == itemid:
            return item.get(key,"NA")
    return "NA"


def get_memory_value(params):
    global g_meminfo_cache
    root_key = params.get("root_key")
    sub_key = params.get("sub_key")
    lshwmemorysplit()
    return g_meminfo_cache.get(root_key,{}).get(sub_key,"NA")


def get_memory_bank_value(params):
    global g_meminfo_cache
    lshwmemorysplit()
    bank = params.get("bankid")
    if g_meminfo_cache.get(bank,{}):
        return True
    return False


def get_func_value(funcname, params):
    ret = eval(funcname)(params)
    return ret

def read_pci_reg(pcibus , slot , fn, bar, offset):
    '''read pci register'''
    if offset % 4 != 0:
        return
    filename = "/sys/bus/pci/devices/0000:%02x:%02x.%x/resource%d" % (int(pcibus), int(slot), int(fn), int(bar))
    size = os.path.getsize(filename)
    with open(filename, "r+") as file:
        data = mmap.mmap(file.fileno(), size)
        result = data[offset: offset + 4]
        s = result[::-1]
        val = 0
        for i in range(0, len(s)):
            val = val << 8  | ord(s[i])
        data.close()
    return "0x%08x" % val


def read_reg(loc, offset, size):
    with open(loc, 'rb') as file:
        file.seek(offset)
        return ' '.join(["%02x" % ord(item) for item in file.read(size)])


def std_match(stdout, pattern):
    if pattern is None:
        return stdout.strip()
    for line in stdout.splitlines():
        if re.match(pattern, line):
            return line.strip()
    raise EOFError("pattern: {} does not match anything in stdout {}".format(
        pattern, stdout))


def i2c_rd(bus, loc, offset):
    '''
    read i2c with i2cget command
    '''
    cmd = "i2cget -f -y {} {} {}".format(bus, loc, offset)
    # TODO: add retry
    retrytime = 6
    for i in range(retrytime):
        ret, stdout = getstatusoutput(cmd)
        if ret == 0:
            return stdout
        time.sleep(0.1)
    raise RuntimeError("run cmd: {} error, status {}".format(cmd, ret))


def i2c_rd_bytes(bus, loc, offset, size):
    blist = []
    for i in range(size):
        ret = i2c_rd(bus, loc, offset + i)
        blist.append(ret)

    return blist


def get_pair_val(source, separator):
    try:
        value = source.split(separator, 1)[1]
    except (ValueError, IndexError) as e:
        # printerr(e.message)
        return ("ERR separator: {} does not match in source: {}".format(separator, source))
    return value.strip()

def get_regular_val(source, pattern, group):
    try:
        value = re.findall(pattern, source)[group]
    except Exception as e:
        # printerr(str(e))
        return ("ERR pattern: {} does not match  in source: {} with group: {}".format(pattern, source, group))
    return value.strip()


def find_match(file2read, pattern):
    with open(file2read, 'r') as file:
        for line in file:
            if not re.match(pattern, line):
                continue
            return line.strip()


def readaline(file2read):
    with open(file2read, 'r') as file:
        return file.readline()


def sort_key(e):
    return e.arrt_index

def log_os_system(cmd):
    status, output = getstatusoutput(cmd)
    return status, output

class CallbackSet:
    def cpld_format(self, blist):
        if isinstance(blist, str):
            blist = blist.split()
        elif not isinstance(blist, list) or len(blist) != 4:
            raise ValueError("cpld format: wrong parameter: {}".format(blist))

        return "{}{}{}{}".format(*blist).replace("0x", "")


class VersionHunter:
    call = CallbackSet()

    def __init__(self, entires):
        self.head = None
        self.next = None
        self.key = None
        self.cmd = None
        self.file = None
        self.reg = None
        self.i2c = None
        self.extra = None
        self.pattern = None
        self.separator = None
        self.parent = None
        self.ignore = False
        self.children = []
        self.level = 0
        self.callback = None
        self.delspace = None
        self.arrt_index = None
        self.config = None
        self.precheck = None
        self.func = None
        self.regular = None
        self.group = 0
        self.pci = None
        self.__dict__.update(entires)

    def check_para(self):
        if self.pattern is None:
            return False
        if self.cmd is None or self.file is None:
            return False
        return True

    def get_version(self):
        ret = "NA"
        try:
            if self.cmd is not None:
                status, output = log_os_system(self.cmd)
                if status or len(output) == 0:
                    raise RuntimeError("run cmd: {} error, status {}".format(self.cmd, ret))
                ret = std_match(output, self.pattern)
            elif self.file is not None:
                ret = self.read_file()
            elif self.reg is not None:
                ret = read_reg(self.reg.get("loc"), self.reg.get("offset"),
                               self.reg.get("size"))
            elif self.extra:
                ret = get_extra_value(self.extra.get("funcname"),
                                      self.extra.get("id"),
                                      self.extra.get("key"))
            elif self.i2c:
                ret = i2c_rd_bytes(self.i2c.get("bus"), self.i2c.get("loc"),
                                   self.i2c.get("offset"),
                                   self.i2c.get("size"))
            elif self.config:
                ret = self.config
            elif self.func:
                ret = get_func_value(self.func.get("funcname"),
                                      self.func.get("params"))
            elif self.pci:
                ret = read_pci_reg(self.pci.get("bus"),self.pci.get("slot"),
                                   self.pci.get("fn"),self.pci.get("bar"),self.pci.get("offset"))
                
        except Exception as e:
            # printerr(e.message)
            return "ERR %s" % str(e)
        return self.exe_callback(ret)

    def exe_callback(self, data):
        try:
            if self.callback:
                method = getattr(self.call, self.callback)
                return method(data)
        except Exception as e:
            # printerr("run callback method: {} error, data: {}".format(self.callback, data))
            # printerr(e.message)
            return "ERR run callback method: {} error, data: {}".format(self.callback, data)
        return data

    def read_file(self):
        if self.pattern is not None:
            return find_match(self.file, self.pattern)
        else:
            return readaline(self.file)

    def hunt(self):
        if self.ignore:
            return
        indent = self.level * INDENT * " "

        if self.precheck:
            try:
                ret = eval(self.precheck.get("funcname"))(self.precheck.get("params"))
                if ret is not True:
                    return
            except Exception as e:
                err_msg = "ERR %s" % str(e)
                format_str = "{}{:<{}}{}".format(indent, self.key + ':',
                                                 (30 - len(indent)), err_msg)
                return
        # has children
        if self.children:
            self.children.sort(key=sort_key)
            format_str = "{}{}:".format(indent, self.key)
            print(format_str)
            for child in self.children:
                if not isinstance(child, VersionHunter):
                    continue
                child.level = self.level + 1
                child.hunt()
        else:
            version = self.get_version() or ""
            if not version.startswith("ERR"):
                version = version.replace("\x00","").strip()
                if self.separator is not None:
                    version = get_pair_val(version, self.separator)
                if self.delspace is not None:
                    version = version.replace(" ", "")
                if self.regular is not None:
                    version = get_regular_val(version, self.regular, self.group)
            format_str = "{}{:<{}}{}".format(indent, self.key + ':',
                                             (30 - len(indent)), version)
            print(format_str)

        if self.next:
            print("")
            self.next.hunt()


if __name__ == "__main__":
    objmap = dict()

    try:
        target = {}
        target.update(MANUINFO_CONF)
        for objname, value in target.items():
            objmap[objname] = VersionHunter(value)
    except Exception as e:
        printerr(e.message)
        exit(-1)

    head = None
    for objname, obj in objmap.items():
        if head is None and obj.head:
            head = obj
        if obj.parent:
            objmap.get(obj.parent).children.append(obj)
        if obj.next:
            obj.next = objmap.get(obj.next)

    head.hunt()
