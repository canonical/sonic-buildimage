From 3c4e5d20a8337561df1e7c48a2103b5a0eb8e7ad Mon Sep 17 00:00:00 2001
From: luohao <luoh@ruijie.com.cn>
Date: Wed, 8 May 2024 21:16:24 +0800
Subject: [PATCH] Summary:(fix pr problem)

BranchName: cust_micas_community_master
CAFID: N202405089956
BUGID: NA
WorkPackageName: BSP
The ratio of self research code(0~1): 1

Change-Id: I32a8f9826741921c9e056dc6986915490d5c3c2a
---
 common/lib/plat_hal/baseutil.py               |   13 +-
 common/modules/Makefile                       |    3 +-
 common/modules/linux-5.10/wb_at24.c           |  861 ------------
 common/modules/{linux-5.10 => linux}/Makefile |    1 -
 .../modules/{linux-5.10 => linux}/wb_csu550.c |    0
 .../{linux-5.10 => linux}/wb_i2c_algo_bit.c   |    0
 .../{linux-5.10 => linux}/wb_i2c_gpio.c       |    0
 .../wb_i2c_gpio_device.c                      |    0
 .../{linux-5.10 => linux}/wb_i2c_i801.c       |    0
 .../{linux-5.10 => linux}/wb_i2c_ismt.c       |    0
 .../wb_i2c_mux_pca954x.c                      |    0
 .../wb_i2c_mux_pca954x.h                      |    0
 .../wb_i2c_mux_pca9641.c                      |    0
 .../wb_i2c_mux_pca9641.h                      |    0
 .../{linux-5.10 => linux}/wb_ina3221.c        |    0
 .../{linux-5.10 => linux}/wb_isl68137.c       |    0
 .../modules/{linux-5.10 => linux}/wb_lm75.c   |    0
 .../modules/{linux-5.10 => linux}/wb_lm75.h   |    0
 .../modules/{linux-5.10 => linux}/wb_pmbus.h  |    0
 .../{linux-5.10 => linux}/wb_pmbus_core.c     |    0
 .../modules/{linux-5.10 => linux}/wb_tmp401.c |    0
 .../{linux-5.10 => linux}/wb_tps53622.c       |    0
 .../{linux-5.10 => linux}/wb_ucd9000.c        |    0
 .../{linux-5.10 => linux}/wb_xdpe12284.c      |    0
 .../wb_xdpe132g5c_pmbus.c                     |    0
 common/modules/wb_optoe.c                     | 1192 -----------------
 common/script/dev_monitor.py                  |    6 +-
 common/script/drv_update.py                   |    6 +-
 common/script/generate_airflow.py             |    8 +-
 common/script/hal_fanctrl.py                  |    4 +-
 .../script/intelligent_monitor/monitor_fan.py |    5 +-
 common/script/platform_driver.py              |    2 +-
 common/script/platform_e2.py                  |    5 +
 common/script/platform_intf.py                |   11 +-
 common/script/platform_process.py             |   58 +-
 common/script/platform_sensors.py             |    3 +
 common/script/platform_util.py                |    2 +-
 common/script/set_eth_mac.py                  |    6 +-
 common/sonic_platform/psu.py                  |   29 +
 .../x86_64_micas_m2_w6510_48v8c_r0_config.py  |   28 +-
 40 files changed, 118 insertions(+), 2125 deletions(-)
 delete mode 100644 common/modules/linux-5.10/wb_at24.c
 rename common/modules/{linux-5.10 => linux}/Makefile (98%)
 rename common/modules/{linux-5.10 => linux}/wb_csu550.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_algo_bit.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_gpio.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_gpio_device.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_i801.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_ismt.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_mux_pca954x.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_mux_pca954x.h (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_mux_pca9641.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_i2c_mux_pca9641.h (100%)
 rename common/modules/{linux-5.10 => linux}/wb_ina3221.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_isl68137.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_lm75.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_lm75.h (100%)
 rename common/modules/{linux-5.10 => linux}/wb_pmbus.h (100%)
 rename common/modules/{linux-5.10 => linux}/wb_pmbus_core.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_tmp401.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_tps53622.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_ucd9000.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_xdpe12284.c (100%)
 rename common/modules/{linux-5.10 => linux}/wb_xdpe132g5c_pmbus.c (100%)
 delete mode 100644 common/modules/wb_optoe.c

diff --git a/common/lib/plat_hal/baseutil.py b/common/lib/plat_hal/baseutil.py
index 5260107c9..abf0ecf97 100644
--- a/common/lib/plat_hal/baseutil.py
+++ b/common/lib/plat_hal/baseutil.py
@@ -9,6 +9,8 @@ import importlib.machinery
 import os
 import syslog
 import json
+import subprocess
+import glob
 from plat_hal.osutil import osutil
 
 SYSLOG_IDENTIFIER = "HAL"
@@ -52,7 +54,7 @@ def getboardairflow():
 def getplatform_config_db():
     if not os.path.isfile(CONFIG_DB_PATH):
         return ""
-    val = os.popen("sonic-cfggen -j %s -v DEVICE_METADATA.localhost.platform" % CONFIG_DB_PATH).read().strip()
+    val = subprocess.check_output(["sonic-cfggen", "-j", CONFIG_DB_PATH, "-v", "DEVICE_METADATA.localhost.platform"]).decode().strip()
     if len(val) <= 0:
         return ""
     return val
@@ -72,10 +74,8 @@ boardairflow = getboardairflow()
 
 
 CONFIG_FILE_PATH_LIST = [
-    "/usr/local/bin/",
     "/usr/lib/python3/dist-packages/",
-    "/usr/local/lib/python3.7/dist-packages/hal-config/",
-    "/usr/local/lib/python3.9/dist-packages/hal-config/"
+    "/usr/local/lib/*/dist-packages/hal-config/"
 ]
 
 
@@ -105,6 +105,11 @@ class baseutil:
     def get_config():
         real_path = None
         for configfile_path in CONFIG_FILE_PATH_LIST:
+            if "/*/" in configfile_path:
+                filepath = glob.glob(configfile_path)
+                if len(filepath) == 0:
+                    continue
+                configfile_path = filepath[0]
             for config_file in DEVICE_CONFIG_FILE_LIST:
                 file = configfile_path + config_file
                 if os.path.exists(file):
diff --git a/common/modules/Makefile b/common/modules/Makefile
index 2e232e1a2..9f55453db 100644
--- a/common/modules/Makefile
+++ b/common/modules/Makefile
@@ -7,7 +7,7 @@ KERNEL_SRC ?=  /lib/modules/$(KVERSION)
 module_out_put_dir := $(PWD)/build
 export module_out_put_dir
 
-KERNEL_MODULES_SRC = $(PWD)/linux-5.10
+KERNEL_MODULES_SRC = $(PWD)/linux
 
 PLAT_SYSFS_DIR = $(PWD)/plat_sysfs
 PHY = $(PWD)/phy
@@ -36,7 +36,6 @@ obj-m += wb_i2c_ocores.o
 obj-m += wb_spi_ocores.o
 obj-m += wb_spi_dev.o
 obj-m += wb_wdt.o
-obj-m += wb_optoe.o
 obj-m += wb_spi_gpio.o
 obj-m += wb_spi_gpio_device.o
 obj-m += wb_spi_nor_device.o
diff --git a/common/modules/linux-5.10/wb_at24.c b/common/modules/linux-5.10/wb_at24.c
deleted file mode 100644
index 5ec39c9d7..000000000
--- a/common/modules/linux-5.10/wb_at24.c
+++ /dev/null
@@ -1,861 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * at24.c - handle most I2C EEPROMs
- *
- * Copyright (C) 2005-2007 David Brownell
- * Copyright (C) 2008 Wolfram Sang, Pengutronix
- */
-
-#include <linux/acpi.h>
-#include <linux/bitops.h>
-#include <linux/capability.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/jiffies.h>
-#include <linux/kernel.h>
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/mutex.h>
-#include <linux/nvmem-provider.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
-#include <linux/property.h>
-#include <linux/regmap.h>
-#include <linux/regulator/consumer.h>
-#include <linux/slab.h>
-
-/* Address pointer is 16 bit. */
-#define AT24_FLAG_ADDR16	BIT(7)
-/* sysfs-entry will be read-only. */
-#define AT24_FLAG_READONLY	BIT(6)
-/* sysfs-entry will be world-readable. */
-#define AT24_FLAG_IRUGO		BIT(5)
-/* Take always 8 addresses (24c00). */
-#define AT24_FLAG_TAKE8ADDR	BIT(4)
-/* Factory-programmed serial number. */
-#define AT24_FLAG_SERIAL	BIT(3)
-/* Factory-programmed mac address. */
-#define AT24_FLAG_MAC		BIT(2)
-/* Does not auto-rollover reads to the next slave address. */
-#define AT24_FLAG_NO_RDROL	BIT(1)
-
-/*
- * I2C EEPROMs from most vendors are inexpensive and mostly interchangeable.
- * Differences between different vendor product lines (like Atmel AT24C or
- * MicroChip 24LC, etc) won't much matter for typical read/write access.
- * There are also I2C RAM chips, likewise interchangeable. One example
- * would be the PCF8570, which acts like a 24c02 EEPROM (256 bytes).
- *
- * However, misconfiguration can lose data. "Set 16-bit memory address"
- * to a part with 8-bit addressing will overwrite data. Writing with too
- * big a page size also loses data. And it's not safe to assume that the
- * conventional addresses 0x50..0x57 only hold eeproms; a PCF8563 RTC
- * uses 0x51, for just one example.
- *
- * Accordingly, explicit board-specific configuration data should be used
- * in almost all cases. (One partial exception is an SMBus used to access
- * "SPD" data for DRAM sticks. Those only use 24c02 EEPROMs.)
- *
- * So this driver uses "new style" I2C driver binding, expecting to be
- * told what devices exist. That may be in arch/X/mach-Y/board-Z.c or
- * similar kernel-resident tables; or, configuration data coming from
- * a bootloader.
- *
- * Other than binding model, current differences from "eeprom" driver are
- * that this one handles write access and isn't restricted to 24c02 devices.
- * It also handles larger devices (32 kbit and up) with two-byte addresses,
- * which won't work on pure SMBus systems.
- */
-
-struct at24_client {
-	struct i2c_client *client;
-	struct regmap *regmap;
-};
-
-struct at24_data {
-	/*
-	 * Lock protects against activities from other Linux tasks,
-	 * but not from changes by other I2C masters.
-	 */
-	struct mutex lock;
-
-	unsigned int write_max;
-	unsigned int num_addresses;
-	unsigned int offset_adj;
-
-	u32 byte_len;
-	u16 page_size;
-	u8 flags;
-
-	struct nvmem_device *nvmem;
-	struct regulator *vcc_reg;
-	void (*read_post)(unsigned int off, char *buf, size_t count);
-
-	/*
-	 * Some chips tie up multiple I2C addresses; dummy devices reserve
-	 * them for us, and we'll use them with SMBus calls.
-	 */
-	struct at24_client client[];
-};
-
-/*
- * This parameter is to help this driver avoid blocking other drivers out
- * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
- * clock, one 256 byte read takes about 1/43 second which is excessive;
- * but the 1/170 second it takes at 400 kHz may be quite reasonable; and
- * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.
- *
- * This value is forced to be a power of two so that writes align on pages.
- */
-static unsigned int at24_io_limit = 128;
-module_param_named(io_limit, at24_io_limit, uint, 0);
-MODULE_PARM_DESC(at24_io_limit, "Maximum bytes per I/O (default 128)");
-
-/*
- * Specs often allow 5 msec for a page write, sometimes 20 msec;
- * it's important to recover from write timeouts.
- */
-static unsigned int at24_write_timeout = 25;
-module_param_named(write_timeout, at24_write_timeout, uint, 0);
-MODULE_PARM_DESC(at24_write_timeout, "Time (in ms) to try writes (default 25)");
-
-struct at24_chip_data {
-	u32 byte_len;
-	u8 flags;
-	void (*read_post)(unsigned int off, char *buf, size_t count);
-};
-
-#define AT24_CHIP_DATA(_name, _len, _flags)				\
-	static const struct at24_chip_data _name = {			\
-		.byte_len = _len, .flags = _flags,			\
-	}
-
-#define AT24_CHIP_DATA_CB(_name, _len, _flags, _read_post)		\
-	static const struct at24_chip_data _name = {			\
-		.byte_len = _len, .flags = _flags,			\
-		.read_post = _read_post,				\
-	}
-
-static void at24_read_post_vaio(unsigned int off, char *buf, size_t count)
-{
-	int i;
-
-	if (capable(CAP_SYS_ADMIN))
-		return;
-
-	/*
-	 * Hide VAIO private settings to regular users:
-	 * - BIOS passwords: bytes 0x00 to 0x0f
-	 * - UUID: bytes 0x10 to 0x1f
-	 * - Serial number: 0xc0 to 0xdf
-	 */
-	for (i = 0; i < count; i++) {
-		if ((off + i <= 0x1f) ||
-		    (off + i >= 0xc0 && off + i <= 0xdf))
-			buf[i] = 0;
-	}
-}
-
-/* needs 8 addresses as A0-A2 are ignored */
-AT24_CHIP_DATA(at24_data_24c00, 128 / 8, AT24_FLAG_TAKE8ADDR);
-/* old variants can't be handled with this generic entry! */
-AT24_CHIP_DATA(at24_data_24c01, 1024 / 8, 0);
-AT24_CHIP_DATA(at24_data_24cs01, 16,
-	AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24c02, 2048 / 8, AT24_FLAG_IRUGO);
-AT24_CHIP_DATA(at24_data_24cs02, 16,
-	AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24mac402, 48 / 8,
-	AT24_FLAG_MAC | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24mac602, 64 / 8,
-	AT24_FLAG_MAC | AT24_FLAG_READONLY);
-/* spd is a 24c02 in memory DIMMs */
-AT24_CHIP_DATA(at24_data_spd, 2048 / 8,
-	AT24_FLAG_READONLY | AT24_FLAG_IRUGO);
-/* 24c02_vaio is a 24c02 on some Sony laptops */
-AT24_CHIP_DATA_CB(at24_data_24c02_vaio, 2048 / 8,
-	AT24_FLAG_READONLY | AT24_FLAG_IRUGO,
-	at24_read_post_vaio);
-AT24_CHIP_DATA(at24_data_24c04, 4096 / 8, 0);
-AT24_CHIP_DATA(at24_data_24cs04, 16,
-	AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-/* 24rf08 quirk is handled at i2c-core */
-AT24_CHIP_DATA(at24_data_24c08, 8192 / 8, 0);
-AT24_CHIP_DATA(at24_data_24cs08, 16,
-	AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24c16, 16384 / 8, 0);
-AT24_CHIP_DATA(at24_data_24cs16, 16,
-	AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24c32, 32768 / 8, AT24_FLAG_ADDR16);
-AT24_CHIP_DATA(at24_data_24cs32, 16,
-	AT24_FLAG_ADDR16 | AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24c64, 65536 / 8, AT24_FLAG_ADDR16 | AT24_FLAG_IRUGO);
-AT24_CHIP_DATA(at24_data_24cs64, 16,
-	AT24_FLAG_ADDR16 | AT24_FLAG_SERIAL | AT24_FLAG_READONLY);
-AT24_CHIP_DATA(at24_data_24c128, 131072 / 8, AT24_FLAG_ADDR16);
-AT24_CHIP_DATA(at24_data_24c256, 262144 / 8, AT24_FLAG_ADDR16);
-AT24_CHIP_DATA(at24_data_24c512, 524288 / 8, AT24_FLAG_ADDR16);
-AT24_CHIP_DATA(at24_data_24c1024, 1048576 / 8, AT24_FLAG_ADDR16);
-AT24_CHIP_DATA(at24_data_24c2048, 2097152 / 8, AT24_FLAG_ADDR16);
-/* identical to 24c08 ? */
-AT24_CHIP_DATA(at24_data_INT3499, 8192 / 8, 0);
-
-static const struct i2c_device_id at24_ids[] = {
-	{ "wb_24c00",	(kernel_ulong_t)&at24_data_24c00 },
-	{ "wb_24c01",	(kernel_ulong_t)&at24_data_24c01 },
-	{ "wb_24cs01",	(kernel_ulong_t)&at24_data_24cs01 },
-	{ "wb_24c02",	(kernel_ulong_t)&at24_data_24c02 },
-	{ "wb_24cs02",	(kernel_ulong_t)&at24_data_24cs02 },
-	{ "wb_24mac402",	(kernel_ulong_t)&at24_data_24mac402 },
-	{ "wb_24mac602",	(kernel_ulong_t)&at24_data_24mac602 },
-	{ "wb_spd",	(kernel_ulong_t)&at24_data_spd },
-	{ "wb_24c02-vaio",	(kernel_ulong_t)&at24_data_24c02_vaio },
-	{ "wb_24c04",	(kernel_ulong_t)&at24_data_24c04 },
-	{ "wb_24cs04",	(kernel_ulong_t)&at24_data_24cs04 },
-	{ "wb_24c08",	(kernel_ulong_t)&at24_data_24c08 },
-	{ "wb_24cs08",	(kernel_ulong_t)&at24_data_24cs08 },
-	{ "wb_24c16",	(kernel_ulong_t)&at24_data_24c16 },
-	{ "wb_24cs16",	(kernel_ulong_t)&at24_data_24cs16 },
-	{ "wb_24c32",	(kernel_ulong_t)&at24_data_24c32 },
-	{ "wb_24cs32",	(kernel_ulong_t)&at24_data_24cs32 },
-	{ "wb_24c64",	(kernel_ulong_t)&at24_data_24c64 },
-	{ "wb_24cs64",	(kernel_ulong_t)&at24_data_24cs64 },
-	{ "wb_24c128",	(kernel_ulong_t)&at24_data_24c128 },
-	{ "wb_24c256",	(kernel_ulong_t)&at24_data_24c256 },
-	{ "wb_24c512",	(kernel_ulong_t)&at24_data_24c512 },
-	{ "wb_24c1024",	(kernel_ulong_t)&at24_data_24c1024 },
-	{ "wb_24c2048",    (kernel_ulong_t)&at24_data_24c2048 },
-	{ "wb_at24",	0 },
-	{ /* END OF LIST */ }
-};
-MODULE_DEVICE_TABLE(i2c, at24_ids);
-
-static const struct of_device_id at24_of_match[] = {
-	{ .compatible = "atmel,24c00",		.data = &at24_data_24c00 },
-	{ .compatible = "atmel,24c01",		.data = &at24_data_24c01 },
-	{ .compatible = "atmel,24cs01",		.data = &at24_data_24cs01 },
-	{ .compatible = "atmel,24c02",		.data = &at24_data_24c02 },
-	{ .compatible = "atmel,24cs02",		.data = &at24_data_24cs02 },
-	{ .compatible = "atmel,24mac402",	.data = &at24_data_24mac402 },
-	{ .compatible = "atmel,24mac602",	.data = &at24_data_24mac602 },
-	{ .compatible = "atmel,spd",		.data = &at24_data_spd },
-	{ .compatible = "atmel,24c04",		.data = &at24_data_24c04 },
-	{ .compatible = "atmel,24cs04",		.data = &at24_data_24cs04 },
-	{ .compatible = "atmel,24c08",		.data = &at24_data_24c08 },
-	{ .compatible = "atmel,24cs08",		.data = &at24_data_24cs08 },
-	{ .compatible = "atmel,24c16",		.data = &at24_data_24c16 },
-	{ .compatible = "atmel,24cs16",		.data = &at24_data_24cs16 },
-	{ .compatible = "atmel,24c32",		.data = &at24_data_24c32 },
-	{ .compatible = "atmel,24cs32",		.data = &at24_data_24cs32 },
-	{ .compatible = "atmel,24c64",		.data = &at24_data_24c64 },
-	{ .compatible = "atmel,24cs64",		.data = &at24_data_24cs64 },
-	{ .compatible = "atmel,24c128",		.data = &at24_data_24c128 },
-	{ .compatible = "atmel,24c256",		.data = &at24_data_24c256 },
-	{ .compatible = "atmel,24c512",		.data = &at24_data_24c512 },
-	{ .compatible = "atmel,24c1024",	.data = &at24_data_24c1024 },
-	{ .compatible = "atmel,24c2048",	.data = &at24_data_24c2048 },
-	{ /* END OF LIST */ },
-};
-MODULE_DEVICE_TABLE(of, at24_of_match);
-
-static const struct acpi_device_id __maybe_unused at24_acpi_ids[] = {
-	{ "INT3499",	(kernel_ulong_t)&at24_data_INT3499 },
-	{ "TPF0001",	(kernel_ulong_t)&at24_data_24c1024 },
-	{ /* END OF LIST */ }
-};
-MODULE_DEVICE_TABLE(acpi, at24_acpi_ids);
-
-/*
- * This routine supports chips which consume multiple I2C addresses. It
- * computes the addressing information to be used for a given r/w request.
- * Assumes that sanity checks for offset happened at sysfs-layer.
- *
- * Slave address and byte offset derive from the offset. Always
- * set the byte address; on a multi-master board, another master
- * may have changed the chip's "current" address pointer.
- */
-static struct at24_client *at24_translate_offset(struct at24_data *at24,
-						 unsigned int *offset)
-{
-	unsigned int i;
-
-	if (at24->flags & AT24_FLAG_ADDR16) {
-		i = *offset >> 16;
-		*offset &= 0xffff;
-	} else {
-		i = *offset >> 8;
-		*offset &= 0xff;
-	}
-
-	return &at24->client[i];
-}
-
-static struct device *at24_base_client_dev(struct at24_data *at24)
-{
-	return &at24->client[0].client->dev;
-}
-
-static size_t at24_adjust_read_count(struct at24_data *at24,
-				      unsigned int offset, size_t count)
-{
-	unsigned int bits;
-	size_t remainder;
-
-	/*
-	 * In case of multi-address chips that don't rollover reads to
-	 * the next slave address: truncate the count to the slave boundary,
-	 * so that the read never straddles slaves.
-	 */
-	if (at24->flags & AT24_FLAG_NO_RDROL) {
-		bits = (at24->flags & AT24_FLAG_ADDR16) ? 16 : 8;
-		remainder = BIT(bits) - offset;
-		if (count > remainder)
-			count = remainder;
-	}
-
-	if (count > at24_io_limit)
-		count = at24_io_limit;
-
-	return count;
-}
-
-static ssize_t at24_regmap_read(struct at24_data *at24, char *buf,
-				unsigned int offset, size_t count)
-{
-	unsigned long timeout, read_time;
-	struct at24_client *at24_client;
-	struct i2c_client *client;
-	struct regmap *regmap;
-	int ret;
-
-	at24_client = at24_translate_offset(at24, &offset);
-	regmap = at24_client->regmap;
-	client = at24_client->client;
-	count = at24_adjust_read_count(at24, offset, count);
-
-	/* adjust offset for mac and serial read ops */
-	offset += at24->offset_adj;
-
-	timeout = jiffies + msecs_to_jiffies(at24_write_timeout);
-	do {
-		/*
-		 * The timestamp shall be taken before the actual operation
-		 * to avoid a premature timeout in case of high CPU load.
-		 */
-		read_time = jiffies;
-
-		ret = regmap_bulk_read(regmap, offset, buf, count);
-		dev_dbg(&client->dev, "read %zu@%d --> %d (%ld)\n",
-			count, offset, ret, jiffies);
-		if (!ret)
-			return count;
-
-		usleep_range(1000, 1500);
-	} while (time_before(read_time, timeout));
-
-	return -ETIMEDOUT;
-}
-
-/*
- * Note that if the hardware write-protect pin is pulled high, the whole
- * chip is normally write protected. But there are plenty of product
- * variants here, including OTP fuses and partial chip protect.
- *
- * We only use page mode writes; the alternative is sloooow. These routines
- * write at most one page.
- */
-
-static size_t at24_adjust_write_count(struct at24_data *at24,
-				      unsigned int offset, size_t count)
-{
-	unsigned int next_page;
-
-	/* write_max is at most a page */
-	if (count > at24->write_max)
-		count = at24->write_max;
-
-	/* Never roll over backwards, to the start of this page */
-	next_page = roundup(offset + 1, at24->page_size);
-	if (offset + count > next_page)
-		count = next_page - offset;
-
-	return count;
-}
-
-static ssize_t at24_regmap_write(struct at24_data *at24, const char *buf,
-				 unsigned int offset, size_t count)
-{
-	unsigned long timeout, write_time;
-	struct at24_client *at24_client;
-	struct i2c_client *client;
-	struct regmap *regmap;
-	int ret;
-
-	at24_client = at24_translate_offset(at24, &offset);
-	regmap = at24_client->regmap;
-	client = at24_client->client;
-	count = at24_adjust_write_count(at24, offset, count);
-	timeout = jiffies + msecs_to_jiffies(at24_write_timeout);
-
-	do {
-		/*
-		 * The timestamp shall be taken before the actual operation
-		 * to avoid a premature timeout in case of high CPU load.
-		 */
-		write_time = jiffies;
-
-		ret = regmap_bulk_write(regmap, offset, buf, count);
-		dev_dbg(&client->dev, "write %zu@%d --> %d (%ld)\n",
-			count, offset, ret, jiffies);
-		if (!ret)
-			return count;
-
-		usleep_range(1000, 1500);
-	} while (time_before(write_time, timeout));
-
-	return -ETIMEDOUT;
-}
-
-static int at24_read(void *priv, unsigned int off, void *val, size_t count)
-{
-	struct at24_data *at24;
-	struct device *dev;
-	char *buf = val;
-	int i, ret;
-
-	at24 = priv;
-	dev = at24_base_client_dev(at24);
-
-	if (unlikely(!count))
-		return count;
-
-	if (off + count > at24->byte_len)
-		return -EINVAL;
-
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0) {
-		pm_runtime_put_noidle(dev);
-		return ret;
-	}
-
-	/*
-	 * Read data from chip, protecting against concurrent updates
-	 * from this host, but not from other I2C masters.
-	 */
-	mutex_lock(&at24->lock);
-
-	for (i = 0; count; i += ret, count -= ret) {
-		ret = at24_regmap_read(at24, buf + i, off + i, count);
-		if (ret < 0) {
-			mutex_unlock(&at24->lock);
-			pm_runtime_put(dev);
-			return ret;
-		}
-	}
-
-	mutex_unlock(&at24->lock);
-
-	pm_runtime_put(dev);
-
-	if (unlikely(at24->read_post))
-		at24->read_post(off, buf, i);
-
-	return 0;
-}
-
-static int at24_write(void *priv, unsigned int off, void *val, size_t count)
-{
-	struct at24_data *at24;
-	struct device *dev;
-	char *buf = val;
-	int ret;
-
-	at24 = priv;
-	dev = at24_base_client_dev(at24);
-
-	if (unlikely(!count))
-		return -EINVAL;
-
-	if (off + count > at24->byte_len)
-		return -EINVAL;
-
-	ret = pm_runtime_get_sync(dev);
-	if (ret < 0) {
-		pm_runtime_put_noidle(dev);
-		return ret;
-	}
-
-	/*
-	 * Write data to chip, protecting against concurrent updates
-	 * from this host, but not from other I2C masters.
-	 */
-	mutex_lock(&at24->lock);
-
-	while (count) {
-		ret = at24_regmap_write(at24, buf, off, count);
-		if (ret < 0) {
-			mutex_unlock(&at24->lock);
-			pm_runtime_put(dev);
-			return ret;
-		}
-		buf += ret;
-		off += ret;
-		count -= ret;
-	}
-
-	mutex_unlock(&at24->lock);
-
-	pm_runtime_put(dev);
-
-	return 0;
-}
-
-static const struct at24_chip_data *at24_get_chip_data(struct device *dev)
-{
-	struct device_node *of_node = dev->of_node;
-	const struct at24_chip_data *cdata;
-	const struct i2c_device_id *id;
-
-	id = i2c_match_id(at24_ids, to_i2c_client(dev));
-
-	/*
-	 * The I2C core allows OF nodes compatibles to match against the
-	 * I2C device ID table as a fallback, so check not only if an OF
-	 * node is present but also if it matches an OF device ID entry.
-	 */
-	if (of_node && of_match_device(at24_of_match, dev))
-		cdata = of_device_get_match_data(dev);
-	else if (id)
-		cdata = (void *)id->driver_data;
-	else
-		cdata = acpi_device_get_match_data(dev);
-
-	if (!cdata)
-		return ERR_PTR(-ENODEV);
-
-	return cdata;
-}
-
-static int at24_make_dummy_client(struct at24_data *at24, unsigned int index,
-				  struct regmap_config *regmap_config)
-{
-	struct i2c_client *base_client, *dummy_client;
-	struct regmap *regmap;
-	struct device *dev;
-
-	base_client = at24->client[0].client;
-	dev = &base_client->dev;
-
-	dummy_client = devm_i2c_new_dummy_device(dev, base_client->adapter,
-						 base_client->addr + index);
-	if (IS_ERR(dummy_client))
-		return PTR_ERR(dummy_client);
-
-	regmap = devm_regmap_init_i2c(dummy_client, regmap_config);
-	if (IS_ERR(regmap))
-		return PTR_ERR(regmap);
-
-	at24->client[index].client = dummy_client;
-	at24->client[index].regmap = regmap;
-
-	return 0;
-}
-
-static unsigned int at24_get_offset_adj(u8 flags, unsigned int byte_len)
-{
-	if (flags & AT24_FLAG_MAC) {
-		/* EUI-48 starts from 0x9a, EUI-64 from 0x98 */
-		return 0xa0 - byte_len;
-	} else if (flags & AT24_FLAG_SERIAL && flags & AT24_FLAG_ADDR16) {
-		/*
-		 * For 16 bit address pointers, the word address must contain
-		 * a '10' sequence in bits 11 and 10 regardless of the
-		 * intended position of the address pointer.
-		 */
-		return 0x0800;
-	} else if (flags & AT24_FLAG_SERIAL) {
-		/*
-		 * Otherwise the word address must begin with a '10' sequence,
-		 * regardless of the intended address.
-		 */
-		return 0x0080;
-	} else {
-		return 0;
-	}
-}
-
-static int at24_probe(struct i2c_client *client)
-{
-	struct regmap_config regmap_config = { };
-	struct nvmem_config nvmem_config = { };
-	u32 byte_len, page_size, flags, addrw;
-	const struct at24_chip_data *cdata;
-	struct device *dev = &client->dev;
-	bool i2c_fn_i2c, i2c_fn_block;
-	unsigned int i, num_addresses;
-	struct at24_data *at24;
-	struct regmap *regmap;
-	bool writable;
-	u8 test_byte;
-	int err;
-
-	i2c_fn_i2c = i2c_check_functionality(client->adapter, I2C_FUNC_I2C);
-	i2c_fn_block = i2c_check_functionality(client->adapter,
-					       I2C_FUNC_SMBUS_WRITE_I2C_BLOCK);
-
-	cdata = at24_get_chip_data(dev);
-	if (IS_ERR(cdata))
-		return PTR_ERR(cdata);
-
-	err = device_property_read_u32(dev, "pagesize", &page_size);
-	if (err)
-		/*
-		 * This is slow, but we can't know all eeproms, so we better
-		 * play safe. Specifying custom eeprom-types via device tree
-		 * or properties is recommended anyhow.
-		 */
-		page_size = 1;
-
-	flags = cdata->flags;
-	if (device_property_present(dev, "read-only"))
-		flags |= AT24_FLAG_READONLY;
-	if (device_property_present(dev, "no-read-rollover"))
-		flags |= AT24_FLAG_NO_RDROL;
-
-	err = device_property_read_u32(dev, "address-width", &addrw);
-	if (!err) {
-		switch (addrw) {
-		case 8:
-			if (flags & AT24_FLAG_ADDR16)
-				dev_warn(dev,
-					 "Override address width to be 8, while default is 16\n");
-			flags &= ~AT24_FLAG_ADDR16;
-			break;
-		case 16:
-			flags |= AT24_FLAG_ADDR16;
-			break;
-		default:
-			dev_warn(dev, "Bad \"address-width\" property: %u\n",
-				 addrw);
-		}
-	}
-
-	err = device_property_read_u32(dev, "size", &byte_len);
-	if (err)
-		byte_len = cdata->byte_len;
-
-	if (!i2c_fn_i2c && !i2c_fn_block)
-		page_size = 1;
-
-	if (!page_size) {
-		dev_err(dev, "page_size must not be 0!\n");
-		return -EINVAL;
-	}
-
-	if (!is_power_of_2(page_size))
-		dev_warn(dev, "page_size looks suspicious (no power of 2)!\n");
-
-	err = device_property_read_u32(dev, "num-addresses", &num_addresses);
-	if (err) {
-		if (flags & AT24_FLAG_TAKE8ADDR)
-			num_addresses = 8;
-		else
-			num_addresses =	DIV_ROUND_UP(byte_len,
-				(flags & AT24_FLAG_ADDR16) ? 65536 : 256);
-	}
-
-	if ((flags & AT24_FLAG_SERIAL) && (flags & AT24_FLAG_MAC)) {
-		dev_err(dev,
-			"invalid device data - cannot have both AT24_FLAG_SERIAL & AT24_FLAG_MAC.");
-		return -EINVAL;
-	}
-
-	regmap_config.val_bits = 8;
-	regmap_config.reg_bits = (flags & AT24_FLAG_ADDR16) ? 16 : 8;
-	regmap_config.disable_locking = true;
-
-	regmap = devm_regmap_init_i2c(client, &regmap_config);
-	if (IS_ERR(regmap))
-		return PTR_ERR(regmap);
-
-	at24 = devm_kzalloc(dev, struct_size(at24, client, num_addresses),
-			    GFP_KERNEL);
-	if (!at24)
-		return -ENOMEM;
-
-	mutex_init(&at24->lock);
-	at24->byte_len = byte_len;
-	at24->page_size = page_size;
-	at24->flags = flags;
-	at24->read_post = cdata->read_post;
-	at24->num_addresses = num_addresses;
-	at24->offset_adj = at24_get_offset_adj(flags, byte_len);
-	at24->client[0].client = client;
-	at24->client[0].regmap = regmap;
-
-	at24->vcc_reg = devm_regulator_get(dev, "vcc");
-	if (IS_ERR(at24->vcc_reg))
-		return PTR_ERR(at24->vcc_reg);
-
-	writable = !(flags & AT24_FLAG_READONLY);
-	if (writable) {
-		at24->write_max = min_t(unsigned int,
-					page_size, at24_io_limit);
-		if (!i2c_fn_i2c && at24->write_max > I2C_SMBUS_BLOCK_MAX)
-			at24->write_max = I2C_SMBUS_BLOCK_MAX;
-	}
-
-	/* use dummy devices for multiple-address chips */
-	for (i = 1; i < num_addresses; i++) {
-		err = at24_make_dummy_client(at24, i, &regmap_config);
-		if (err)
-			return err;
-	}
-
-	/*
-	 * If the 'label' property is not present for the AT24 EEPROM,
-	 * then nvmem_config.id is initialised to NVMEM_DEVID_AUTO,
-	 * and this will append the 'devid' to the name of the NVMEM
-	 * device. This is purely legacy and the AT24 driver has always
-	 * defaulted to this. However, if the 'label' property is
-	 * present then this means that the name is specified by the
-	 * firmware and this name should be used verbatim and so it is
-	 * not necessary to append the 'devid'.
-	 */
-	if (device_property_present(dev, "label")) {
-		nvmem_config.id = NVMEM_DEVID_NONE;
-		err = device_property_read_string(dev, "label",
-						  &nvmem_config.name);
-		if (err)
-			return err;
-	} else {
-		nvmem_config.id = NVMEM_DEVID_AUTO;
-		nvmem_config.name = dev_name(dev);
-	}
-
-	nvmem_config.type = NVMEM_TYPE_EEPROM;
-	nvmem_config.dev = dev;
-	nvmem_config.read_only = !writable;
-	nvmem_config.root_only = !(flags & AT24_FLAG_IRUGO);
-	nvmem_config.owner = THIS_MODULE;
-	nvmem_config.compat = true;
-	nvmem_config.base_dev = dev;
-	nvmem_config.reg_read = at24_read;
-	nvmem_config.reg_write = at24_write;
-	nvmem_config.priv = at24;
-	nvmem_config.stride = 1;
-	nvmem_config.word_size = 1;
-	nvmem_config.size = byte_len;
-
-	i2c_set_clientdata(client, at24);
-
-	err = regulator_enable(at24->vcc_reg);
-	if (err) {
-		dev_err(dev, "Failed to enable vcc regulator\n");
-		return err;
-	}
-
-	/* enable runtime pm */
-	pm_runtime_set_active(dev);
-	pm_runtime_enable(dev);
-
-	at24->nvmem = devm_nvmem_register(dev, &nvmem_config);
-	if (IS_ERR(at24->nvmem)) {
-		pm_runtime_disable(dev);
-		if (!pm_runtime_status_suspended(dev))
-			regulator_disable(at24->vcc_reg);
-		return PTR_ERR(at24->nvmem);
-	}
-
-	/*
-	 * Perform a one-byte test read to verify that the
-	 * chip is functional.
-	 */
-	err = at24_read(at24, 0, &test_byte, 1);
-	if (err) {
-		pm_runtime_disable(dev);
-		if (!pm_runtime_status_suspended(dev))
-			regulator_disable(at24->vcc_reg);
-		return -ENODEV;
-	}
-
-	pm_runtime_idle(dev);
-
-	if (writable)
-		dev_info(dev, "%u byte %s EEPROM, writable, %u bytes/write\n",
-			 byte_len, client->name, at24->write_max);
-	else
-		dev_info(dev, "%u byte %s EEPROM, read-only\n",
-			 byte_len, client->name);
-
-	return 0;
-}
-
-static void at24_remove(struct i2c_client *client)
-{
-	struct at24_data *at24 = i2c_get_clientdata(client);
-
-	pm_runtime_disable(&client->dev);
-	if (!pm_runtime_status_suspended(&client->dev))
-		regulator_disable(at24->vcc_reg);
-	pm_runtime_set_suspended(&client->dev);
-
-	return;
-}
-
-static int __maybe_unused at24_suspend(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct at24_data *at24 = i2c_get_clientdata(client);
-
-	return regulator_disable(at24->vcc_reg);
-}
-
-static int __maybe_unused at24_resume(struct device *dev)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct at24_data *at24 = i2c_get_clientdata(client);
-
-	return regulator_enable(at24->vcc_reg);
-}
-
-static const struct dev_pm_ops at24_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
-	SET_RUNTIME_PM_OPS(at24_suspend, at24_resume, NULL)
-};
-
-static struct i2c_driver at24_driver = {
-	.driver = {
-		.name = "wb_at24",
-		.pm = &at24_pm_ops,
-		.of_match_table = at24_of_match,
-		.acpi_match_table = ACPI_PTR(at24_acpi_ids),
-	},
-	.probe_new = at24_probe,
-	.remove = at24_remove,
-	.id_table = at24_ids,
-};
-
-static int __init at24_init(void)
-{
-	if (!at24_io_limit) {
-		pr_err("at24: at24_io_limit must not be 0!\n");
-		return -EINVAL;
-	}
-
-	at24_io_limit = rounddown_pow_of_two(at24_io_limit);
-	return i2c_add_driver(&at24_driver);
-}
-module_init(at24_init);
-
-static void __exit at24_exit(void)
-{
-	i2c_del_driver(&at24_driver);
-}
-module_exit(at24_exit);
-
-MODULE_DESCRIPTION("Driver for most I2C EEPROMs");
-MODULE_AUTHOR("support");
-MODULE_LICENSE("GPL");
diff --git a/common/modules/linux-5.10/Makefile b/common/modules/linux/Makefile
similarity index 98%
rename from common/modules/linux-5.10/Makefile
rename to common/modules/linux/Makefile
index 02d659d6c..a3da5aadf 100644
--- a/common/modules/linux-5.10/Makefile
+++ b/common/modules/linux/Makefile
@@ -16,7 +16,6 @@ obj-m += wb_i2c_i801.o
 obj-m += wb_i2c_algo_bit.o
 obj-m += wb_i2c_gpio.o
 obj-m += wb_i2c_gpio_device.o
-obj-m += wb_at24.o
 obj-m += wb_pmbus_core.o
 obj-m += wb_csu550.o
 obj-m += wb_ina3221.o
diff --git a/common/modules/linux-5.10/wb_csu550.c b/common/modules/linux/wb_csu550.c
similarity index 100%
rename from common/modules/linux-5.10/wb_csu550.c
rename to common/modules/linux/wb_csu550.c
diff --git a/common/modules/linux-5.10/wb_i2c_algo_bit.c b/common/modules/linux/wb_i2c_algo_bit.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_algo_bit.c
rename to common/modules/linux/wb_i2c_algo_bit.c
diff --git a/common/modules/linux-5.10/wb_i2c_gpio.c b/common/modules/linux/wb_i2c_gpio.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_gpio.c
rename to common/modules/linux/wb_i2c_gpio.c
diff --git a/common/modules/linux-5.10/wb_i2c_gpio_device.c b/common/modules/linux/wb_i2c_gpio_device.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_gpio_device.c
rename to common/modules/linux/wb_i2c_gpio_device.c
diff --git a/common/modules/linux-5.10/wb_i2c_i801.c b/common/modules/linux/wb_i2c_i801.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_i801.c
rename to common/modules/linux/wb_i2c_i801.c
diff --git a/common/modules/linux-5.10/wb_i2c_ismt.c b/common/modules/linux/wb_i2c_ismt.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_ismt.c
rename to common/modules/linux/wb_i2c_ismt.c
diff --git a/common/modules/linux-5.10/wb_i2c_mux_pca954x.c b/common/modules/linux/wb_i2c_mux_pca954x.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_mux_pca954x.c
rename to common/modules/linux/wb_i2c_mux_pca954x.c
diff --git a/common/modules/linux-5.10/wb_i2c_mux_pca954x.h b/common/modules/linux/wb_i2c_mux_pca954x.h
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_mux_pca954x.h
rename to common/modules/linux/wb_i2c_mux_pca954x.h
diff --git a/common/modules/linux-5.10/wb_i2c_mux_pca9641.c b/common/modules/linux/wb_i2c_mux_pca9641.c
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_mux_pca9641.c
rename to common/modules/linux/wb_i2c_mux_pca9641.c
diff --git a/common/modules/linux-5.10/wb_i2c_mux_pca9641.h b/common/modules/linux/wb_i2c_mux_pca9641.h
similarity index 100%
rename from common/modules/linux-5.10/wb_i2c_mux_pca9641.h
rename to common/modules/linux/wb_i2c_mux_pca9641.h
diff --git a/common/modules/linux-5.10/wb_ina3221.c b/common/modules/linux/wb_ina3221.c
similarity index 100%
rename from common/modules/linux-5.10/wb_ina3221.c
rename to common/modules/linux/wb_ina3221.c
diff --git a/common/modules/linux-5.10/wb_isl68137.c b/common/modules/linux/wb_isl68137.c
similarity index 100%
rename from common/modules/linux-5.10/wb_isl68137.c
rename to common/modules/linux/wb_isl68137.c
diff --git a/common/modules/linux-5.10/wb_lm75.c b/common/modules/linux/wb_lm75.c
similarity index 100%
rename from common/modules/linux-5.10/wb_lm75.c
rename to common/modules/linux/wb_lm75.c
diff --git a/common/modules/linux-5.10/wb_lm75.h b/common/modules/linux/wb_lm75.h
similarity index 100%
rename from common/modules/linux-5.10/wb_lm75.h
rename to common/modules/linux/wb_lm75.h
diff --git a/common/modules/linux-5.10/wb_pmbus.h b/common/modules/linux/wb_pmbus.h
similarity index 100%
rename from common/modules/linux-5.10/wb_pmbus.h
rename to common/modules/linux/wb_pmbus.h
diff --git a/common/modules/linux-5.10/wb_pmbus_core.c b/common/modules/linux/wb_pmbus_core.c
similarity index 100%
rename from common/modules/linux-5.10/wb_pmbus_core.c
rename to common/modules/linux/wb_pmbus_core.c
diff --git a/common/modules/linux-5.10/wb_tmp401.c b/common/modules/linux/wb_tmp401.c
similarity index 100%
rename from common/modules/linux-5.10/wb_tmp401.c
rename to common/modules/linux/wb_tmp401.c
diff --git a/common/modules/linux-5.10/wb_tps53622.c b/common/modules/linux/wb_tps53622.c
similarity index 100%
rename from common/modules/linux-5.10/wb_tps53622.c
rename to common/modules/linux/wb_tps53622.c
diff --git a/common/modules/linux-5.10/wb_ucd9000.c b/common/modules/linux/wb_ucd9000.c
similarity index 100%
rename from common/modules/linux-5.10/wb_ucd9000.c
rename to common/modules/linux/wb_ucd9000.c
diff --git a/common/modules/linux-5.10/wb_xdpe12284.c b/common/modules/linux/wb_xdpe12284.c
similarity index 100%
rename from common/modules/linux-5.10/wb_xdpe12284.c
rename to common/modules/linux/wb_xdpe12284.c
diff --git a/common/modules/linux-5.10/wb_xdpe132g5c_pmbus.c b/common/modules/linux/wb_xdpe132g5c_pmbus.c
similarity index 100%
rename from common/modules/linux-5.10/wb_xdpe132g5c_pmbus.c
rename to common/modules/linux/wb_xdpe132g5c_pmbus.c
diff --git a/common/modules/wb_optoe.c b/common/modules/wb_optoe.c
deleted file mode 100644
index 9a55fcdec..000000000
--- a/common/modules/wb_optoe.c
+++ /dev/null
@@ -1,1192 +0,0 @@
-/*
- * optoe.c - A driver to read and write the EEPROM on optical transceivers
- * (SFP, QSFP and similar I2C based devices)
- *
- * Copyright (C) 2014 Cumulus networks Inc.
- * Copyright (C) 2017 Finisar Corp.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Freeoftware Foundation; either version 2 of the License, or
- * (at your option) any later version.
- */
-
-/*
- *	Description:
- *	a) Optical transceiver EEPROM read/write transactions are just like
- *		the at24 eeproms managed by the at24.c i2c driver
- *	b) The register/memory layout is up to 256 128 byte pages defined by
- *		a "pages valid" register and switched via a "page select"
- *		register as explained in below diagram.
- *	c) 256 bytes are mapped at a time. 'Lower page 00h' is the first 128
- *	        bytes of address space, and always references the same
- *	        location, independent of the page select register.
- *	        All mapped pages are mapped into the upper 128 bytes
- *	        (offset 128-255) of the i2c address.
- *	d) Devices with one I2C address (eg QSFP) use I2C address 0x50
- *		(A0h in the spec), and map all pages in the upper 128 bytes
- *		of that address.
- *	e) Devices with two I2C addresses (eg SFP) have 256 bytes of data
- *		at I2C address 0x50, and 256 bytes of data at I2C address
- *		0x51 (A2h in the spec).  Page selection and paged access
- *		only apply to this second I2C address (0x51).
- *	e) The address space is presented, by the driver, as a linear
- *	        address space.  For devices with one I2C client at address
- *	        0x50 (eg QSFP), offset 0-127 are in the lower
- *	        half of address 50/A0h/client[0].  Offset 128-255 are in
- *	        page 0, 256-383 are page 1, etc.  More generally, offset
- *	        'n' resides in page (n/128)-1.  ('page -1' is the lower
- *	        half, offset 0-127).
- *	f) For devices with two I2C clients at address 0x50 and 0x51 (eg SFP),
- *		the address space places offset 0-127 in the lower
- *	        half of 50/A0/client[0], offset 128-255 in the upper
- *	        half.  Offset 256-383 is in the lower half of 51/A2/client[1].
- *	        Offset 384-511 is in page 0, in the upper half of 51/A2/...
- *	        Offset 512-639 is in page 1, in the upper half of 51/A2/...
- *	        Offset 'n' is in page (n/128)-3 (for n > 383)
- *
- *	                    One I2c addressed (eg QSFP) Memory Map
- *
- *	                    2-Wire Serial Address: 1010000x
- *
- *	                    Lower Page 00h (128 bytes)
- *	                    =====================
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |                     |
- *	                   |Page Select Byte(127)|
- *	                    =====================
- *	                              |
- *	                              |
- *	                              |
- *	                              |
- *	                              V
- *	     ------------------------------------------------------------
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    |                 |                  |                       |
- *	    V                 V                  V                       V
- *	 ------------   --------------      ---------------     --------------
- *	|            | |              |    |               |   |              |
- *	|   Upper    | |     Upper    |    |     Upper     |   |    Upper     |
- *	|  Page 00h  | |    Page 01h  |    |    Page 02h   |   |   Page 03h   |
- *	|            | |   (Optional) |    |   (Optional)  |   |  (Optional   |
- *	|            | |              |    |               |   |   for Cable  |
- *	|            | |              |    |               |   |  Assemblies) |
- *	|    ID      | |     AST      |    |      User     |   |              |
- *	|  Fields    | |    Table     |    |   EEPROM Data |   |              |
- *	|            | |              |    |               |   |              |
- *	|            | |              |    |               |   |              |
- *	|            | |              |    |               |   |              |
- *	 ------------   --------------      ---------------     --------------
- *
- * The SFF 8436 (QSFP) spec only defines the 4 pages described above.
- * In anticipation of future applications and devices, this driver
- * supports access to the full architected range, 256 pages.
- *
- * The CMIS (Common Management Interface Specification) defines use of
- * considerably more pages (at least to page 0xAF), which this driver
- * supports.
- *
- * NOTE: This version of the driver ONLY SUPPORTS BANK 0 PAGES on CMIS
- * devices.
- *
- **/
-
-/* #define DEBUG 1 */
-
-#undef EEPROM_CLASS
-#ifdef CONFIG_EEPROM_CLASS
-#define EEPROM_CLASS
-#endif
-#ifdef CONFIG_EEPROM_CLASS_MODULE
-#define EEPROM_CLASS
-#endif
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/delay.h>
-#include <linux/mutex.h>
-#include <linux/sysfs.h>
-#include <linux/jiffies.h>
-#include <linux/i2c.h>
-#include <linux/string.h>
-
-#define mem_clear(data, size) memset((data), 0, (size))
-#ifdef EEPROM_CLASS
-#include <linux/eeprom_class.h>
-#endif
-
-#include <linux/types.h>
-
-/* The maximum length of a port name */
-#define MAX_PORT_NAME_LEN 20
-
-struct optoe_platform_data {
-	u32		byte_len;		/* size (sum of all addr) */
-	u16		page_size;		/* for writes */
-	u8		flags;
-	void		*dummy1;		/* backward compatibility */
-	void		*dummy2;		/* backward compatibility */
-
-#ifdef EEPROM_CLASS
-	struct eeprom_platform_data *eeprom_data;
-#endif
-	char port_name[MAX_PORT_NAME_LEN];
-};
-
-/* fundamental unit of addressing for EEPROM */
-#define OPTOE_PAGE_SIZE 128
-/*
- * Single address devices (eg QSFP) have 256 pages, plus the unpaged
- * low 128 bytes.  If the device does not support paging, it is
- * only 2 'pages' long.
- */
-#define OPTOE_ARCH_PAGES 256
-#define ONE_ADDR_EEPROM_SIZE ((1 + OPTOE_ARCH_PAGES) * OPTOE_PAGE_SIZE)
-#define ONE_ADDR_EEPROM_UNPAGED_SIZE (2 * OPTOE_PAGE_SIZE)
-/*
- * Dual address devices (eg SFP) have 256 pages, plus the unpaged
- * low 128 bytes, plus 256 bytes at 0x50.  If the device does not
- * support paging, it is 4 'pages' long.
- */
-#define TWO_ADDR_EEPROM_SIZE ((3 + OPTOE_ARCH_PAGES) * OPTOE_PAGE_SIZE)
-#define TWO_ADDR_EEPROM_UNPAGED_SIZE (4 * OPTOE_PAGE_SIZE)
-#define TWO_ADDR_NO_0X51_SIZE (2 * OPTOE_PAGE_SIZE)
-
-/* a few constants to find our way around the EEPROM */
-#define OPTOE_PAGE_SELECT_REG   0x7F
-#define ONE_ADDR_PAGEABLE_REG 0x02
-#define QSFP_NOT_PAGEABLE (1<<2)
-#define CMIS_NOT_PAGEABLE (1<<7)
-#define TWO_ADDR_PAGEABLE_REG 0x40
-#define TWO_ADDR_PAGEABLE (1<<4)
-#define TWO_ADDR_0X51_REG 92
-#define TWO_ADDR_0X51_SUPP (1<<6)
-#define OPTOE_ID_REG 0
-#define OPTOE_READ_OP 0
-#define OPTOE_WRITE_OP 1
-#define OPTOE_EOF 0  /* used for access beyond end of device */
-
-struct optoe_data {
-	struct optoe_platform_data chip;
-	int use_smbus;
-	char port_name[MAX_PORT_NAME_LEN];
-
-	/*
-	 * Lock protects against activities from other Linux tasks,
-	 * but not from changes by other I2C masters.
-	 */
-	struct mutex lock;
-	struct bin_attribute bin;
-	struct attribute_group attr_group;
-
-	u8 *writebuf;
-	unsigned int write_max;
-
-	unsigned int num_addresses;
-
-#ifdef EEPROM_CLASS
-	struct eeprom_device *eeprom_dev;
-#endif
-
-	/* dev_class: ONE_ADDR (QSFP) or TWO_ADDR (SFP) */
-	int dev_class;
-
-	struct i2c_client *client[];
-};
-
-/*
- * This parameter is to help this driver avoid blocking other drivers out
- * of I2C for potentially troublesome amounts of time. With a 100 kHz I2C
- * clock, one 256 byte read takes about 1/43 second which is excessive;
- * but the 1/170 second it takes at 400 kHz may be quite reasonable; and
- * at 1 MHz (Fm+) a 1/430 second delay could easily be invisible.
- *
- * This value is forced to be a power of two so that writes align on pages.
- */
-static unsigned int io_limit = OPTOE_PAGE_SIZE;
-
-/*
- * specs often allow 5 msec for a page write, sometimes 20 msec;
- * it's important to recover from write timeouts.
- */
-static unsigned int write_timeout = 50;
-
-/*
- * flags to distinguish one-address (QSFP family) from two-address (SFP family)
- * If the family is not known, figure it out when the device is accessed
- */
-#define ONE_ADDR 1
-#define TWO_ADDR 2
-#define CMIS_ADDR 3
-
-static const struct i2c_device_id optoe_ids[] = {
-	{ "wb_optoe1", ONE_ADDR },
-	{ "wb_optoe2", TWO_ADDR },
-	{ "wb_optoe3", CMIS_ADDR },
-	{ "wb_sff8436", ONE_ADDR },
-	{ "wb_24c04", TWO_ADDR },
-	{ /* END OF LIST */ }
-};
-MODULE_DEVICE_TABLE(i2c, optoe_ids);
-
-/*-------------------------------------------------------------------------*/
-/*
- * This routine computes the addressing information to be used for
- * a given r/w request.
- *
- * Task is to calculate the client (0 = i2c addr 50, 1 = i2c addr 51),
- * the page, and the offset.
- *
- * Handles both single address (eg QSFP) and two address (eg SFP).
- *     For SFP, offset 0-255 are on client[0], >255 is on client[1]
- *     Offset 256-383 are on the lower half of client[1]
- *     Pages are accessible on the upper half of client[1].
- *     Offset >383 are in 128 byte pages mapped into the upper half
- *
- *     For QSFP, all offsets are on client[0]
- *     offset 0-127 are on the lower half of client[0] (no paging)
- *     Pages are accessible on the upper half of client[1].
- *     Offset >127 are in 128 byte pages mapped into the upper half
- *
- *     Callers must not read/write beyond the end of a client or a page
- *     without recomputing the client/page.  Hence offset (within page)
- *     plus length must be less than or equal to 128.  (Note that this
- *     routine does not have access to the length of the call, hence
- *     cannot do the validity check.)
- *
- * Offset within Lower Page 00h and Upper Page 00h are not recomputed
- */
-
-static uint8_t optoe_translate_offset(struct optoe_data *optoe,
-		loff_t *offset, struct i2c_client **client)
-{
-	unsigned int page = 0;
-
-	*client = optoe->client[0];
-
-	/* if SFP style, offset > 255, shift to i2c addr 0x51 */
-	if (optoe->dev_class == TWO_ADDR) {
-		if (*offset > 255) {
-			/* like QSFP, but shifted to client[1] */
-			*client = optoe->client[1];
-			*offset -= 256;
-		}
-	}
-
-	/*
-	 * if offset is in the range 0-128...
-	 * page doesn't matter (using lower half), return 0.
-	 * offset is already correct (don't add 128 to get to paged area)
-	 */
-	if (*offset < OPTOE_PAGE_SIZE)
-		return page;
-
-	/* note, page will always be positive since *offset >= 128 */
-	page = (*offset >> 7)-1;
-	/* 0x80 places the offset in the top half, offset is last 7 bits */
-	*offset = OPTOE_PAGE_SIZE + (*offset & 0x7f);
-
-	return page;  /* note also returning client and offset */
-}
-
-static ssize_t optoe_eeprom_read(struct optoe_data *optoe,
-		    struct i2c_client *client,
-		    char *buf, unsigned int offset, size_t count)
-{
-	struct i2c_msg msg[2];
-	u8 msgbuf[2];
-	unsigned long timeout, read_time;
-	int status, i;
-
-	mem_clear(msg, sizeof(msg));
-
-	switch (optoe->use_smbus) {
-	case I2C_SMBUS_I2C_BLOCK_DATA:
-		/*smaller eeproms can work given some SMBus extension calls */
-		if (count > I2C_SMBUS_BLOCK_MAX)
-			count = I2C_SMBUS_BLOCK_MAX;
-		break;
-	case I2C_SMBUS_WORD_DATA:
-		/* Check for odd length transaction */
-		count = (count == 1) ? 1 : 2;
-		break;
-	case I2C_SMBUS_BYTE_DATA:
-		count = 1;
-		break;
-	default:
-		/*
-		 * When we have a better choice than SMBus calls, use a
-		 * combined I2C message. Write address; then read up to
-		 * io_limit data bytes.  msgbuf is u8 and will cast to our
-		 * needs.
-		 */
-		i = 0;
-		msgbuf[i++] = offset;
-
-		msg[0].addr = client->addr;
-		msg[0].buf = msgbuf;
-		msg[0].len = i;
-
-		msg[1].addr = client->addr;
-		msg[1].flags = I2C_M_RD;
-		msg[1].buf = buf;
-		msg[1].len = count;
-	}
-
-	/*
-	 * Reads fail if the previous write didn't complete yet. We may
-	 * loop a few times until this one succeeds, waiting at least
-	 * long enough for one entire page write to work.
-	 */
-	timeout = jiffies + msecs_to_jiffies(write_timeout);
-	do {
-		read_time = jiffies;
-
-		switch (optoe->use_smbus) {
-		case I2C_SMBUS_I2C_BLOCK_DATA:
-			status = i2c_smbus_read_i2c_block_data(client, offset,
-					count, buf);
-			break;
-		case I2C_SMBUS_WORD_DATA:
-			status = i2c_smbus_read_word_data(client, offset);
-			if (status >= 0) {
-				buf[0] = status & 0xff;
-				if (count == 2)
-					buf[1] = status >> 8;
-				status = count;
-			}
-			break;
-		case I2C_SMBUS_BYTE_DATA:
-			status = i2c_smbus_read_byte_data(client, offset);
-			if (status >= 0) {
-				buf[0] = status;
-				status = count;
-			}
-			break;
-		default:
-			status = i2c_transfer(client->adapter, msg, 2);
-			if (status == 2)
-				status = count;
-		}
-
-		dev_dbg(&client->dev, "eeprom read %zu@%d --> %d (%ld)\n",
-				count, offset, status, jiffies);
-
-		if (status == count)  /* happy path */
-			return count;
-
-		/* REVISIT: at HZ=100, this is sloooow */
-		usleep_range(1000, 2000);
-	} while (time_before(read_time, timeout));
-
-	return -ETIMEDOUT;
-}
-
-static ssize_t optoe_eeprom_write(struct optoe_data *optoe,
-				struct i2c_client *client,
-				const char *buf,
-				unsigned int offset, size_t count)
-{
-	struct i2c_msg msg;
-	ssize_t status;
-	unsigned long timeout, write_time;
-	unsigned int next_page_start;
-	int i = 0;
-
-	/* write max is at most a page
-	 * (In this driver, write_max is actually one byte!)
-	 */
-	if (count > optoe->write_max)
-		count = optoe->write_max;
-
-	/* shorten count if necessary to avoid crossing page boundary */
-	next_page_start = roundup(offset + 1, OPTOE_PAGE_SIZE);
-	if (offset + count > next_page_start)
-		count = next_page_start - offset;
-
-	switch (optoe->use_smbus) {
-	case I2C_SMBUS_I2C_BLOCK_DATA:
-		/*smaller eeproms can work given some SMBus extension calls */
-		if (count > I2C_SMBUS_BLOCK_MAX)
-			count = I2C_SMBUS_BLOCK_MAX;
-		break;
-	case I2C_SMBUS_WORD_DATA:
-		/* Check for odd length transaction */
-		count = (count == 1) ? 1 : 2;
-		break;
-	case I2C_SMBUS_BYTE_DATA:
-		count = 1;
-		break;
-	default:
-		/* If we'll use I2C calls for I/O, set up the message */
-		msg.addr = client->addr;
-		msg.flags = 0;
-
-		/* msg.buf is u8 and casts will mask the values */
-		msg.buf = optoe->writebuf;
-
-		msg.buf[i++] = offset;
-		memcpy(&msg.buf[i], buf, count);
-		msg.len = i + count;
-		break;
-	}
-
-	/*
-	 * Reads fail if the previous write didn't complete yet. We may
-	 * loop a few times until this one succeeds, waiting at least
-	 * long enough for one entire page write to work.
-	 */
-	timeout = jiffies + msecs_to_jiffies(write_timeout);
-	do {
-		write_time = jiffies;
-
-		switch (optoe->use_smbus) {
-		case I2C_SMBUS_I2C_BLOCK_DATA:
-			status = i2c_smbus_write_i2c_block_data(client,
-						offset, count, buf);
-			if (status == 0)
-				status = count;
-			break;
-		case I2C_SMBUS_WORD_DATA:
-			if (count == 2) {
-				status = i2c_smbus_write_word_data(client,
-					offset, (u16)((buf[0])|(buf[1] << 8)));
-			} else {
-				/* count = 1 */
-				status = i2c_smbus_write_byte_data(client,
-					offset, buf[0]);
-			}
-			if (status == 0)
-				status = count;
-			break;
-		case I2C_SMBUS_BYTE_DATA:
-			status = i2c_smbus_write_byte_data(client, offset,
-						buf[0]);
-			if (status == 0)
-				status = count;
-			break;
-		default:
-			status = i2c_transfer(client->adapter, &msg, 1);
-			if (status == 1)
-				status = count;
-			break;
-		}
-
-		dev_dbg(&client->dev, "eeprom write %zu@%d --> %ld (%lu)\n",
-				count, offset, (long int) status, jiffies);
-
-		if (status == count)
-			return count;
-
-		/* REVISIT: at HZ=100, this is sloooow */
-		usleep_range(1000, 2000);
-	} while (time_before(write_time, timeout));
-
-	return -ETIMEDOUT;
-}
-
-static ssize_t optoe_eeprom_update_client(struct optoe_data *optoe,
-				char *buf, loff_t off,
-				size_t count, int opcode)
-{
-	struct i2c_client *client;
-	ssize_t retval = 0;
-	uint8_t page = 0;
-    uint8_t loc;
-	loff_t phy_offset = off;
-	int ret = 0;
-
-	page = optoe_translate_offset(optoe, &phy_offset, &client);
-	dev_dbg(&client->dev,
-		"%s off %lld  page:%d phy_offset:%lld, count:%ld, opcode:%d\n",
-		__func__, off, page, phy_offset, (long int) count, opcode);
-
-    ret = optoe_eeprom_read(optoe, client, &loc, OPTOE_PAGE_SELECT_REG, 1);
-    if (ret < 0) {
-        dev_dbg(&client->dev, "Read page register for get now location page failed. ret:%d\n", ret);
-        return ret;
-    }
-
-    /* Only when read and now location page is inconsistent, will doing switch page */
-    if (loc != page) {
-        ret = optoe_eeprom_write(optoe, client, &page,
-            OPTOE_PAGE_SELECT_REG, 1);
-        if (ret < 0) {
-            dev_dbg(&client->dev,
-                "Write page register for page %d failed ret:%d!\n",
-                    page, ret);
-            return ret;
-        }
-    }
-
-	while (count) {
-		ssize_t	status;
-
-		if (opcode == OPTOE_READ_OP) {
-			status =  optoe_eeprom_read(optoe, client,
-				buf, phy_offset, count);
-		} else {
-			status =  optoe_eeprom_write(optoe, client,
-				buf, phy_offset, count);
-		}
-		if (status <= 0) {
-			if (retval == 0)
-				retval = status;
-			break;
-		}
-		buf += status;
-		phy_offset += status;
-		count -= status;
-		retval += status;
-	}
-
-	return retval;
-}
-
-/*
- * Figure out if this access is within the range of supported pages.
- * Note this is called on every access because we don't know if the
- * module has been replaced since the last call.
- * If/when modules support more pages, this is the routine to update
- * to validate and allow access to additional pages.
- *
- * Returns updated len for this access:
- *     - entire access is legal, original len is returned.
- *     - access begins legal but is too long, len is truncated to fit.
- *     - initial offset exceeds supported pages, return OPTOE_EOF (zero)
- */
-static ssize_t optoe_page_legal(struct optoe_data *optoe,
-		loff_t off, size_t len)
-{
-	struct i2c_client *client = optoe->client[0];
-	u8 regval;
-	int not_pageable;
-	int status;
-	size_t maxlen;
-
-	if (off < 0)
-		return -EINVAL;
-	if (optoe->dev_class == TWO_ADDR) {
-		/* SFP case */
-		/* if only using addr 0x50 (first 256 bytes) we're good */
-		if ((off + len) <= TWO_ADDR_NO_0X51_SIZE)
-			return len;
-		/* if offset exceeds possible pages, we're not good */
-		if (off >= TWO_ADDR_EEPROM_SIZE)
-			return OPTOE_EOF;
-		/* in between, are pages supported? */
-		status = optoe_eeprom_read(optoe, client, &regval,
-				TWO_ADDR_PAGEABLE_REG, 1);
-		if (status < 0)
-			return status;  /* error out (no module?) */
-		if (regval & TWO_ADDR_PAGEABLE) {
-			/* Pages supported, trim len to the end of pages */
-			maxlen = TWO_ADDR_EEPROM_SIZE - off;
-		} else {
-			/* pages not supported, trim len to unpaged size */
-			if (off >= TWO_ADDR_EEPROM_UNPAGED_SIZE)
-				return OPTOE_EOF;
-
-			/* will be accessing addr 0x51, is that supported? */
-			/* byte 92, bit 6 implies DDM support, 0x51 support */
-			status = optoe_eeprom_read(optoe, client, &regval,
-						TWO_ADDR_0X51_REG, 1);
-			if (status < 0)
-				return status;
-			if (regval & TWO_ADDR_0X51_SUPP) {
-				/* addr 0x51 is OK */
-				maxlen = TWO_ADDR_EEPROM_UNPAGED_SIZE - off;
-			} else {
-				/* addr 0x51 NOT supported, trim to 256 max */
-				if (off >= TWO_ADDR_NO_0X51_SIZE)
-					return OPTOE_EOF;
-				maxlen = TWO_ADDR_NO_0X51_SIZE - off;
-			}
-		}
-		len = (len > maxlen) ? maxlen : len;
-		dev_dbg(&client->dev,
-			"page_legal, SFP, off %lld len %ld\n",
-			off, (long int) len);
-	} else {
-		/* QSFP case, CMIS case */
-		/* if no pages needed, we're good */
-		if ((off + len) <= ONE_ADDR_EEPROM_UNPAGED_SIZE)
-			return len;
-		/* if offset exceeds possible pages, we're not good */
-		if (off >= ONE_ADDR_EEPROM_SIZE)
-			return OPTOE_EOF;
-		/* in between, are pages supported? */
-		status = optoe_eeprom_read(optoe, client, &regval,
-				ONE_ADDR_PAGEABLE_REG, 1);
-		if (status < 0)
-			return status;  /* error out (no module?) */
-
-		if (optoe->dev_class == ONE_ADDR) {
-			not_pageable = QSFP_NOT_PAGEABLE;
-		} else {
-			not_pageable = CMIS_NOT_PAGEABLE;
-		}
-		dev_dbg(&client->dev,
-			"Paging Register: 0x%x; not_pageable mask: 0x%x\n",
-			regval, not_pageable);
-
-		if (regval & not_pageable) {
-			/* pages not supported, trim len to unpaged size */
-			if (off >= ONE_ADDR_EEPROM_UNPAGED_SIZE)
-				return OPTOE_EOF;
-			maxlen = ONE_ADDR_EEPROM_UNPAGED_SIZE - off;
-		} else {
-			/* Pages supported, trim len to the end of pages */
-			maxlen = ONE_ADDR_EEPROM_SIZE - off;
-		}
-		len = (len > maxlen) ? maxlen : len;
-		dev_dbg(&client->dev,
-			"page_legal, QSFP, off %lld len %ld\n",
-			off, (long int) len);
-	}
-	return len;
-}
-
-static ssize_t optoe_read_write(struct optoe_data *optoe,
-		char *buf, loff_t off, size_t len, int opcode)
-{
-	struct i2c_client *client = optoe->client[0];
-	int chunk;
-	int status = 0;
-	ssize_t retval;
-	size_t pending_len = 0, chunk_len = 0;
-	loff_t chunk_offset = 0, chunk_start_offset = 0;
-	loff_t chunk_end_offset = 0;
-
-	dev_dbg(&client->dev,
-		"%s: off %lld  len:%ld, opcode:%s\n",
-		__func__, off, (long int) len,
-		(opcode == OPTOE_READ_OP) ? "r" : "w");
-	if (unlikely(!len))
-		return len;
-
-	/*
-	 * Read data from chip, protecting against concurrent updates
-	 * from this host, but not from other I2C masters.
-	 */
-	mutex_lock(&optoe->lock);
-
-	/*
-	 * Confirm this access fits within the device suppored addr range
-	 */
-	status = optoe_page_legal(optoe, off, len);
-	if ((status == OPTOE_EOF) || (status < 0)) {
-		mutex_unlock(&optoe->lock);
-		return status;
-	}
-	len = status;
-
-	/*
-	 * For each (128 byte) chunk involved in this request, issue a
-	 * separate call to sff_eeprom_update_client(), to
-	 * ensure that each access recalculates the client/page
-	 * and writes the page register as needed.
-	 * Note that chunk to page mapping is confusing, is different for
-	 * QSFP and SFP, and never needs to be done.  Don't try!
-	 */
-	pending_len = len; /* amount remaining to transfer */
-	retval = 0;  /* amount transferred */
-	for (chunk = off >> 7; chunk <= (off + len - 1) >> 7; chunk++) {
-
-		/*
-		 * Compute the offset and number of bytes to be read/write
-		 *
-		 * 1. start at an offset not equal to 0 (within the chunk)
-		 *    and read/write less than the rest of the chunk
-		 * 2. start at an offset not equal to 0 and read/write the rest
-		 *    of the chunk
-		 * 3. start at offset 0 (within the chunk) and read/write less
-		 *    than entire chunk
-		 * 4. start at offset 0 (within the chunk), and read/write
-		 *    the entire chunk
-		 */
-		chunk_start_offset = chunk * OPTOE_PAGE_SIZE;
-		chunk_end_offset = chunk_start_offset + OPTOE_PAGE_SIZE;
-
-		if (chunk_start_offset < off) {
-			chunk_offset = off;
-			if ((off + pending_len) < chunk_end_offset)
-				chunk_len = pending_len;
-			else
-				chunk_len = chunk_end_offset - off;
-		} else {
-			chunk_offset = chunk_start_offset;
-			if (pending_len < OPTOE_PAGE_SIZE)
-				chunk_len = pending_len;
-			else
-				chunk_len = OPTOE_PAGE_SIZE;
-		}
-
-		dev_dbg(&client->dev,
-			"sff_r/w: off %lld, len %ld, chunk_start_offset %lld, chunk_offset %lld, chunk_len %ld, pending_len %ld\n",
-			off, (long int) len, chunk_start_offset, chunk_offset,
-			(long int) chunk_len, (long int) pending_len);
-
-		/*
-		 * note: chunk_offset is from the start of the EEPROM,
-		 * not the start of the chunk
-		 */
-		status = optoe_eeprom_update_client(optoe, buf,
-				chunk_offset, chunk_len, opcode);
-		if (status != chunk_len) {
-			/* This is another 'no device present' path */
-			dev_dbg(&client->dev,
-			"o_u_c: chunk %d c_offset %lld c_len %ld failed %d!\n",
-			chunk, chunk_offset, (long int) chunk_len, status);
-			if (status > 0)
-				retval += status;
-			if (retval == 0)
-				retval = status;
-			break;
-		}
-		buf += status;
-		pending_len -= status;
-		retval += status;
-	}
-	mutex_unlock(&optoe->lock);
-
-	return retval;
-}
-
-static ssize_t optoe_bin_read(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *attr,
-		char *buf, loff_t off, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(container_of(kobj,
-				struct device, kobj));
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-
-	return optoe_read_write(optoe, buf, off, count, OPTOE_READ_OP);
-}
-
-static ssize_t optoe_bin_write(struct file *filp, struct kobject *kobj,
-		struct bin_attribute *attr,
-		char *buf, loff_t off, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(container_of(kobj,
-				struct device, kobj));
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-
-	return optoe_read_write(optoe, buf, off, count, OPTOE_WRITE_OP);
-}
-
-static void optoe_remove(struct i2c_client *client)
-{
-	struct optoe_data *optoe;
-	int i;
-
-	optoe = i2c_get_clientdata(client);
-	sysfs_remove_group(&client->dev.kobj, &optoe->attr_group);
-	sysfs_remove_bin_file(&client->dev.kobj, &optoe->bin);
-
-	for (i = 1; i < optoe->num_addresses; i++)
-		i2c_unregister_device(optoe->client[i]);
-
-#ifdef EEPROM_CLASS
-	eeprom_device_unregister(optoe->eeprom_dev);
-#endif
-
-	kfree(optoe->writebuf);
-	kfree(optoe);
-	return;
-}
-
-static ssize_t show_dev_class(struct device *dev,
-			struct device_attribute *dattr, char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-	ssize_t count;
-
-	mutex_lock(&optoe->lock);
-	count = sprintf(buf, "%d\n", optoe->dev_class);
-	mutex_unlock(&optoe->lock);
-
-	return count;
-}
-
-static ssize_t set_dev_class(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-	int dev_class;
-
-	/*
-	 * dev_class is actually the number of i2c addresses used, thus
-	 * legal values are "1" (QSFP class) and "2" (SFP class)
-	 * And...  CMIS spec is 1 i2c address, but puts the pageable
-	 * bit in a different location, so CMIS devices are "3"
-	 */
-
-	if (kstrtoint(buf, 0, &dev_class) != 0 ||
-		dev_class < 1 || dev_class > 3)
-		return -EINVAL;
-
-	mutex_lock(&optoe->lock);
-	if (dev_class == TWO_ADDR) {
-		/* SFP family */
-		/* if it doesn't exist, create 0x51 i2c address */
-		if (!optoe->client[1]) {
-			optoe->client[1] = i2c_new_dummy_device(client->adapter, 0x51);
-			if (!optoe->client[1]) {
-				dev_err(&client->dev,
-					"address 0x51 unavailable\n");
-				mutex_unlock(&optoe->lock);
-				return -EADDRINUSE;
-			}
-		}
-		optoe->bin.size = TWO_ADDR_EEPROM_SIZE;
-		optoe->num_addresses = 2;
-	} else {
-		/* one-address (eg QSFP) and CMIS family */
-		/* if it exists, remove 0x51 i2c address */
-		if (optoe->client[1]) {
-			i2c_unregister_device(optoe->client[1]);
-			optoe->client[1] = NULL;
-		}
-		optoe->bin.size = ONE_ADDR_EEPROM_SIZE;
-		optoe->num_addresses = 1;
-	}
-	optoe->dev_class = dev_class;
-	mutex_unlock(&optoe->lock);
-
-	return count;
-}
-
-/*
- * if using the EEPROM CLASS driver, we don't report a port_name,
- * the EEPROM CLASS drive handles that.  Hence all this code is
- * only compiled if we are NOT using the EEPROM CLASS driver.
- */
-#ifndef EEPROM_CLASS
-
-static ssize_t show_port_name(struct device *dev,
-			struct device_attribute *dattr, char *buf)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-	ssize_t count;
-
-	mutex_lock(&optoe->lock);
-	count = sprintf(buf, "%s\n", optoe->port_name);
-	mutex_unlock(&optoe->lock);
-
-	return count;
-}
-
-static ssize_t set_port_name(struct device *dev,
-			struct device_attribute *attr,
-			const char *buf, size_t count)
-{
-	struct i2c_client *client = to_i2c_client(dev);
-	struct optoe_data *optoe = i2c_get_clientdata(client);
-	char port_name[MAX_PORT_NAME_LEN];
-
-	/* no checking, this value is not used except by show_port_name */
-
-	if (sscanf(buf, "%19s", port_name) != 1)
-		return -EINVAL;
-
-	mutex_lock(&optoe->lock);
-	strcpy(optoe->port_name, port_name);
-	mutex_unlock(&optoe->lock);
-
-	return count;
-}
-
-static DEVICE_ATTR(port_name,  0644, show_port_name, set_port_name);
-#endif  /* if NOT defined EEPROM_CLASS, the common case */
-
-static DEVICE_ATTR(dev_class,  0644, show_dev_class, set_dev_class);
-
-static struct attribute *optoe_attrs[] = {
-#ifndef EEPROM_CLASS
-	&dev_attr_port_name.attr,
-#endif
-	&dev_attr_dev_class.attr,
-	NULL,
-};
-
-static struct attribute_group optoe_attr_group = {
-	.attrs = optoe_attrs,
-};
-
-static int optoe_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
-{
-	int err;
-	int use_smbus = 0;
-	struct optoe_platform_data chip;
-	struct optoe_data *optoe;
-	int num_addresses = 0;
-	char port_name[MAX_PORT_NAME_LEN];
-
-	if (client->addr != 0x50) {
-		dev_dbg(&client->dev, "probe, bad i2c addr: 0x%x\n",
-				      client->addr);
-		err = -EINVAL;
-		goto exit;
-	}
-
-	if (client->dev.platform_data) {
-		chip = *(struct optoe_platform_data *)client->dev.platform_data;
-		/* take the port name from the supplied platform data */
-#ifdef EEPROM_CLASS
-		strncpy(port_name, chip.eeprom_data->label, MAX_PORT_NAME_LEN);
-#else
-		memcpy(port_name, chip.port_name, MAX_PORT_NAME_LEN);
-#endif
-		dev_dbg(&client->dev,
-			"probe, chip provided, flags:0x%x; name: %s\n",
-			chip.flags, client->name);
-	} else {
-		if (!id->driver_data) {
-			err = -ENODEV;
-			goto exit;
-		}
-		dev_dbg(&client->dev, "probe, building chip\n");
-		strcpy(port_name, "unitialized");
-		chip.flags = 0;
-#ifdef EEPROM_CLASS
-		chip.eeprom_data = NULL;
-#endif
-	}
-
-	/* Use I2C operations unless we're stuck with SMBus extensions. */
-	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
-		if (i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_READ_I2C_BLOCK)) {
-			use_smbus = I2C_SMBUS_I2C_BLOCK_DATA;
-		} else if (i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_READ_WORD_DATA)) {
-			use_smbus = I2C_SMBUS_WORD_DATA;
-		} else if (i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_READ_BYTE_DATA)) {
-			use_smbus = I2C_SMBUS_BYTE_DATA;
-		} else {
-			err = -EPFNOSUPPORT;
-			goto exit;
-		}
-	}
-
-	/*
-	 * Make room for two i2c clients
-	 */
-	num_addresses = 2;
-
-	optoe = kzalloc(sizeof(struct optoe_data) +
-			num_addresses * sizeof(struct i2c_client *),
-			GFP_KERNEL);
-	if (!optoe) {
-		err = -ENOMEM;
-		goto exit;
-	}
-
-	mutex_init(&optoe->lock);
-
-	/* determine whether this is a one-address or two-address module */
-	if ((strcmp(client->name, "wb_optoe1") == 0) ||
-	    (strcmp(client->name, "wb_sff8436") == 0)) {
-		/* one-address (eg QSFP) family */
-		optoe->dev_class = ONE_ADDR;
-		chip.byte_len = ONE_ADDR_EEPROM_SIZE;
-		num_addresses = 1;
-	} else if ((strcmp(client->name, "wb_optoe2") == 0) ||
-		   (strcmp(client->name, "wb_24c04") == 0)) {
-		/* SFP family */
-		optoe->dev_class = TWO_ADDR;
-		chip.byte_len = TWO_ADDR_EEPROM_SIZE;
-		num_addresses = 2;
-	} else if (strcmp(client->name, "wb_optoe3") == 0) {
-		/* CMIS spec */
-		optoe->dev_class = CMIS_ADDR;
-		chip.byte_len = ONE_ADDR_EEPROM_SIZE;
-		num_addresses = 1;
-	} else {     /* those were the only choices */
-		err = -EINVAL;
-		goto exit;
-	}
-
-	dev_dbg(&client->dev, "dev_class: %d\n", optoe->dev_class);
-	optoe->use_smbus = use_smbus;
-	optoe->chip = chip;
-	optoe->num_addresses = num_addresses;
-	memcpy(optoe->port_name, port_name, MAX_PORT_NAME_LEN);
-
-	/*
-	 * Export the EEPROM bytes through sysfs, since that's convenient.
-	 * By default, only root should see the data (maybe passwords etc)
-	 */
-	sysfs_bin_attr_init(&optoe->bin);
-	optoe->bin.attr.name = "eeprom";
-	optoe->bin.attr.mode = 0444;
-	optoe->bin.read = optoe_bin_read;
-	optoe->bin.size = chip.byte_len;
-
-	if (!use_smbus ||
-			(i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_WRITE_I2C_BLOCK)) ||
-			i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_WRITE_WORD_DATA) ||
-			i2c_check_functionality(client->adapter,
-				I2C_FUNC_SMBUS_WRITE_BYTE_DATA)) {
-		/*
-		 * NOTE: AN-2079
-		 * Finisar recommends that the host implement 1 byte writes
-		 * only since this module only supports 32 byte page boundaries.
-		 * 2 byte writes are acceptable for PE and Vout changes per
-		 * Application Note AN-2071.
-		 */
-		unsigned int write_max = 1;
-
-		optoe->bin.write = optoe_bin_write;
-		optoe->bin.attr.mode |= 0200;
-
-		if (write_max > io_limit)
-			write_max = io_limit;
-		if (use_smbus && write_max > I2C_SMBUS_BLOCK_MAX)
-			write_max = I2C_SMBUS_BLOCK_MAX;
-		optoe->write_max = write_max;
-
-		/* buffer (data + address at the beginning) */
-		optoe->writebuf = kmalloc(write_max + 2, GFP_KERNEL);
-		if (!optoe->writebuf) {
-			err = -ENOMEM;
-			goto exit_kfree;
-		}
-	} else {
-		dev_warn(&client->dev,
-			"cannot write due to controller restrictions.");
-	}
-
-	optoe->client[0] = client;
-
-	/* SFF-8472 spec requires that the second I2C address be 0x51 */
-	if (num_addresses == 2) {
-		optoe->client[1] = i2c_new_dummy_device(client->adapter, 0x51);
-		if (!optoe->client[1]) {
-			dev_err(&client->dev, "address 0x51 unavailable\n");
-			err = -EADDRINUSE;
-			goto err_struct;
-		}
-	}
-
-	/* create the sysfs eeprom file */
-	err = sysfs_create_bin_file(&client->dev.kobj, &optoe->bin);
-	if (err)
-		goto err_struct;
-
-	optoe->attr_group = optoe_attr_group;
-
-	err = sysfs_create_group(&client->dev.kobj, &optoe->attr_group);
-	if (err) {
-		dev_err(&client->dev, "failed to create sysfs attribute group.\n");
-		goto err_struct;
-	}
-
-#ifdef EEPROM_CLASS
-	optoe->eeprom_dev = eeprom_device_register(&client->dev,
-							chip.eeprom_data);
-	if (IS_ERR(optoe->eeprom_dev)) {
-		dev_err(&client->dev, "error registering eeprom device.\n");
-		err = PTR_ERR(optoe->eeprom_dev);
-		goto err_sysfs_cleanup;
-	}
-#endif
-
-	i2c_set_clientdata(client, optoe);
-
-	dev_info(&client->dev, "%zu byte %s EEPROM, %s\n",
-		optoe->bin.size, client->name,
-		optoe->bin.write ? "read/write" : "read-only");
-
-	if (use_smbus == I2C_SMBUS_WORD_DATA ||
-	    use_smbus == I2C_SMBUS_BYTE_DATA) {
-		dev_notice(&client->dev,
-			"Falling back to %s reads, performance will suffer\n",
-			use_smbus == I2C_SMBUS_WORD_DATA ? "word" : "byte");
-	}
-
-	return 0;
-
-#ifdef EEPROM_CLASS
-err_sysfs_cleanup:
-	sysfs_remove_group(&client->dev.kobj, &optoe->attr_group);
-	sysfs_remove_bin_file(&client->dev.kobj, &optoe->bin);
-#endif
-
-err_struct:
-	if (num_addresses == 2) {
-		if (optoe->client[1]) {
-			i2c_unregister_device(optoe->client[1]);
-			optoe->client[1] = NULL;
-		}
-	}
-
-	kfree(optoe->writebuf);
-exit_kfree:
-	kfree(optoe);
-exit:
-	dev_dbg(&client->dev, "probe error %d\n", err);
-
-	return err;
-}
-
-/*-------------------------------------------------------------------------*/
-
-static struct i2c_driver optoe_driver = {
-	.driver = {
-		.name = "wb_optoe",
-		.owner = THIS_MODULE,
-	},
-	.probe = optoe_probe,
-	.remove = optoe_remove,
-	.id_table = optoe_ids,
-};
-
-static int __init optoe_init(void)
-{
-
-	if (!io_limit) {
-		pr_err("optoe: io_limit must not be 0!\n");
-		return -EINVAL;
-	}
-
-	io_limit = rounddown_pow_of_two(io_limit);
-	return i2c_add_driver(&optoe_driver);
-}
-module_init(optoe_init);
-
-static void __exit optoe_exit(void)
-{
-	i2c_del_driver(&optoe_driver);
-}
-module_exit(optoe_exit);
-
-MODULE_DESCRIPTION("Driver for optical transceiver (SFP, QSFP, ...) EEPROMs");
-MODULE_AUTHOR("support");
-MODULE_LICENSE("GPL");
diff --git a/common/script/dev_monitor.py b/common/script/dev_monitor.py
index e13377b80..8ce06db06 100755
--- a/common/script/dev_monitor.py
+++ b/common/script/dev_monitor.py
@@ -6,7 +6,7 @@ import syslog
 import traceback
 import click
 from platform_config import DEV_MONITOR_PARAM
-from platform_util import io_rd, wbi2cget
+from platform_util import io_rd, wbi2cget, exec_os_cmd
 
 
 CONTEXT_SETTINGS = {"help_option_names": ['-h', '--help']}
@@ -111,7 +111,7 @@ class DevMonitor():
         cmd = "echo  0x%02x > /sys/bus/i2c/devices/i2c-%d/delete_device" % (loc, bus)
         devpath = "/sys/bus/i2c/devices/%d-%04x" % (bus, loc)
         if os.path.exists(devpath):
-            os.system(cmd)
+            exec_os_cmd(cmd)
 
     def addDev(self, name, bus, loc):
         if name == "lm75":
@@ -119,7 +119,7 @@ class DevMonitor():
         cmd = "echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device" % (name, loc, bus)
         devpath = "/sys/bus/i2c/devices/%d-%04x" % (bus, loc)
         if os.path.exists(devpath) is False:
-            os.system(cmd)
+            exec_os_cmd(cmd)
 
     def checkattr(self, bus, loc, attr):
         try:
diff --git a/common/script/drv_update.py b/common/script/drv_update.py
index 9de4911e8..ac7c189f1 100755
--- a/common/script/drv_update.py
+++ b/common/script/drv_update.py
@@ -135,16 +135,16 @@ def doDrvUpdate():
 
     if update_initramfs_flag == 1:
         drv_update_debug("starting to update initramfs")
-        os.system("update-initramfs -u")
+        exec_os_cmd("update-initramfs -u")
         drv_update_debug("update initramfs finish")
 
-    os.system("sync")
+    exec_os_cmd("sync")
     if update_initramfs_flag == 1 and err_cnt == 0 and reboot_flag == 1:
         reboot_log = "%DRV_UPDATE-5-REBOOT: Update initramfs is completed, restarting the system to take effect."
         reboot_log_cmd = "echo '%s' > /dev/ttyS0" % reboot_log
         exec_os_cmd(reboot_log_cmd)
         drv_update_info(reboot_log)
-        os.system("/sbin/reboot")
+        exec_os_cmd("/sbin/reboot")
     return
 
 if __name__ == '__main__':
diff --git a/common/script/generate_airflow.py b/common/script/generate_airflow.py
index 89d3e7233..ff4fed46f 100755
--- a/common/script/generate_airflow.py
+++ b/common/script/generate_airflow.py
@@ -19,7 +19,7 @@ import os
 import syslog
 import json
 from platform_config import AIR_FLOW_CONF, AIRFLOW_RESULT_FILE
-from platform_util import dev_file_read, byteTostr
+from platform_util import dev_file_read, byteTostr, exec_os_cmd
 from eepromutil.fru import ipmifru
 from eepromutil.cust_fru import CustFru
 from eepromutil.fantlv import fan_tlv
@@ -241,11 +241,11 @@ def generate_airflow():
     out_file_dir = os.path.dirname(AIRFLOW_RESULT_FILE)
     if len(out_file_dir) != 0:
         cmd = "mkdir -p %s" % out_file_dir
-        os.system(cmd)
-        os.system("sync")
+        exec_os_cmd(cmd)
+        exec_os_cmd("sync")
     with open(AIRFLOW_RESULT_FILE, "w") as fd:
         fd.write(ret_json)
-    os.system("sync")
+    exec_os_cmd("sync")
 
 
 if __name__ == '__main__':
diff --git a/common/script/hal_fanctrl.py b/common/script/hal_fanctrl.py
index 63acf84b7..5a12b88ac 100755
--- a/common/script/hal_fanctrl.py
+++ b/common/script/hal_fanctrl.py
@@ -525,7 +525,7 @@ class fancontrol(object):
                     exec_os_cmd(create_judge_file)
                     exec_os_cmd("sync")
                     time.sleep(3)
-                    os.system("/sbin/reboot")
+                    exec_os_cmd("/sbin/reboot")
         except Exception as e:
             fancontrol_error("%%policy: checkCritReboot failed")
             fancontrol_error(str(e))
@@ -577,7 +577,7 @@ class fancontrol(object):
                     exec_os_cmd(create_judge_file)
                     exec_os_cmd("sync")
                     time.sleep(3)
-                    os.system("/sbin/reboot")
+                    exec_os_cmd("/sbin/reboot")
         except Exception as e:
             fancontrol_error("%%policy: checkEmergReboot failed")
             fancontrol_error(str(e))
diff --git a/common/script/intelligent_monitor/monitor_fan.py b/common/script/intelligent_monitor/monitor_fan.py
index c84319f3b..bb596a94c 100755
--- a/common/script/intelligent_monitor/monitor_fan.py
+++ b/common/script/intelligent_monitor/monitor_fan.py
@@ -8,6 +8,7 @@ from logging.handlers import RotatingFileHandler
 
 from plat_hal.interface import interface
 from plat_hal.baseutil import baseutil
+from platform_util import exec_os_cmd
 
 
 DEBUG_FILE = "/etc/.monitor_fan_debug_flag"
@@ -19,8 +20,8 @@ E2_NAME = "ONIE_E2"
 
 def _init_logger():
     if not os.path.exists(LOG_FILE):
-        os.system("mkdir -p %s" % os.path.dirname(LOG_FILE))
-        os.system("sync")
+        exec_os_cmd("mkdir -p %s" % os.path.dirname(LOG_FILE))
+        exec_os_cmd("sync")
     handler = RotatingFileHandler(filename=LOG_FILE, maxBytes=5 * 1024 * 1024, backupCount=1)
     formatter = logging.Formatter("%(asctime)s %(levelname)s %(filename)s[%(funcName)s][%(lineno)s]: %(message)s")
     handler.setFormatter(formatter)
diff --git a/common/script/platform_driver.py b/common/script/platform_driver.py
index 9796367f7..88fb3ef69 100755
--- a/common/script/platform_driver.py
+++ b/common/script/platform_driver.py
@@ -79,7 +79,7 @@ def addDev(name, bus, loc):
     cmd = "echo  %s 0x%02x > /sys/bus/i2c/devices/i2c-%d/new_device" % (name, loc, bus)
     devpath = "/sys/bus/i2c/devices/%d-%04x" % (bus, loc)
     if os.path.exists(devpath) is False:
-        os.system(cmd)
+        log_os_system(cmd)
 
 
 def removeOPTOE(startbus, endbus):
diff --git a/common/script/platform_e2.py b/common/script/platform_e2.py
index 152dd16a2..4dafde270 100755
--- a/common/script/platform_e2.py
+++ b/common/script/platform_e2.py
@@ -1,6 +1,8 @@
 #!/usr/bin/env python3
 # -*- coding: UTF-8 -*-
 import click
+import os
+import sys
 
 from eepromutil.fru import ipmifru
 from eepromutil.cust_fru import CustFru
@@ -436,4 +438,7 @@ def onie_tlv(e2_path, e2_size):
 
 
 if __name__ == '__main__':
+    if os.geteuid() != 0:
+        print("Root privileges are required for this operation")
+        sys.exit(1)
     main()
diff --git a/common/script/platform_intf.py b/common/script/platform_intf.py
index 43f36f040..ef27c2392 100755
--- a/common/script/platform_intf.py
+++ b/common/script/platform_intf.py
@@ -1,6 +1,7 @@
 #!/usr/bin/env python3
 import os
 import syslog
+import glob
 import importlib.machinery
 from platform_util import getplatform_name, dev_file_read, dev_file_write, write_sysfs, read_sysfs
 
@@ -29,9 +30,8 @@ PLATFORM_INTF_DEBUG_FILE = "/etc/.platform_intf_debug_flag"
 
 CONFIG_FILE_LIST = [
     "/usr/local/bin/",
-    "/usr/local/lib/python3/dist-packages/config/",
-    "/usr/local/lib/python3.7/dist-packages/config/",
-    "/usr/local/lib/python3.9/dist-packages/config/"]
+    "/usr/local/lib/*/dist-packages/config/"
+]
 
 
 def platform_intf_debug(s):
@@ -54,6 +54,11 @@ class IntfPlatform:
         real_path = None
         platform_name = (getplatform_name()).replace("-", "_")
         for configfile_path in CONFIG_FILE_LIST:
+            if "/*/" in configfile_path:
+                filepath = glob.glob(configfile_path)
+                if len(filepath) == 0:
+                    continue
+                configfile_path = filepath[0]
             configfile = configfile_path + platform_name + "_port_config.py"
             if os.path.exists(configfile):
                 real_path = configfile
diff --git a/common/script/platform_process.py b/common/script/platform_process.py
index f19231bba..6013c5d65 100755
--- a/common/script/platform_process.py
+++ b/common/script/platform_process.py
@@ -70,7 +70,7 @@ def startAvscontrol():
         cmd = "nohup avscontrol.py start >/dev/null 2>&1 &"
         rets = getPid("avscontrol.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startFanctrol():
@@ -78,7 +78,7 @@ def startFanctrol():
         cmd = "nohup fancontrol.py start >/dev/null 2>&1 &"
         rets = getPid("fancontrol.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def starthal_fanctrl():
@@ -86,7 +86,7 @@ def starthal_fanctrl():
         cmd = "nohup hal_fanctrl.py start >/dev/null 2>&1 &"
         rets = getPid("hal_fanctrl.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def starthal_ledctrl():
@@ -94,7 +94,7 @@ def starthal_ledctrl():
         cmd = "nohup hal_ledctrl.py start >/dev/null 2>&1 &"
         rets = getPid("hal_ledctrl.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startDevmonitor():
@@ -102,7 +102,7 @@ def startDevmonitor():
         cmd = "nohup dev_monitor.py start >/dev/null 2>&1 &"
         rets = getPid("dev_monitor.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startSlotmonitor():
@@ -110,7 +110,7 @@ def startSlotmonitor():
         cmd = "nohup slot_monitor.py start >/dev/null 2>&1 &"
         rets = getPid("slot_monitor.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startIntelligentmonitor():
@@ -118,7 +118,7 @@ def startIntelligentmonitor():
         cmd = "nohup intelligent_monitor.py >/dev/null 2>&1 &"
         rets = getPid("intelligent_monitor.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startSignalmonitor():
@@ -126,7 +126,7 @@ def startSignalmonitor():
         cmd = "nohup signal_monitor.py start >/dev/null 2>&1 &"
         rets = getPid("signal_monitor.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startSff_temp_polling():
@@ -134,7 +134,7 @@ def startSff_temp_polling():
         cmd = "nohup sfp_highest_temperatue.py >/dev/null 2>&1 &"
         rets = getPid("sfp_highest_temperatue.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startRebootCause():
@@ -142,7 +142,7 @@ def startRebootCause():
         cmd = "nohup reboot_cause.py >/dev/null 2>&1 &"
         rets = getPid("reboot_cause.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startPMON_sys():
@@ -150,7 +150,7 @@ def startPMON_sys():
         cmd = "nohup pmon_syslog.py >/dev/null 2>&1 &"
         rets = getPid("pmon_syslog.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def startSff_polling():
@@ -158,14 +158,14 @@ def startSff_polling():
         cmd = "nohup sff_polling.py start > /dev/null 2>&1 &"
         rets = getPid("sff_polling.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def generate_air_flow():
     cmd = "nohup generate_airflow.py > /dev/null 2>&1 &"
     rets = getPid("generate_airflow.py")
     if len(rets) == 0:
-        os.system(cmd)
+        log_os_system(cmd)
         time.sleep(1)
 
 
@@ -186,14 +186,14 @@ def start_tty_console():
         cmd = "nohup tty_console.py > /dev/null 2>&1 &"
         rets = getPid("tty_console.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 def startDrvUpdate():
     if STARTMODULE.get('drv_update', 0) == 1:
         cmd = "nohup drv_update.py >/dev/null 2>&1 &"
         rets = getPid("drv_update.py")
         if len(rets) == 0:
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopAvscontrol():
@@ -201,7 +201,7 @@ def stopAvscontrol():
         rets = getPid("avscontrol.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopFanctrol():
@@ -209,7 +209,7 @@ def stopFanctrol():
         rets = getPid("fancontrol.py")  #
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stophal_fanctrl():
@@ -217,7 +217,7 @@ def stophal_fanctrl():
         rets = getPid("hal_fanctrl.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stophal_ledctrl():
@@ -225,7 +225,7 @@ def stophal_ledctrl():
         rets = getPid("hal_ledctrl.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopDevmonitor():
@@ -233,7 +233,7 @@ def stopDevmonitor():
         rets = getPid("dev_monitor.py")  #
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopSlotmonitor():
@@ -241,7 +241,7 @@ def stopSlotmonitor():
         rets = getPid("slot_monitor.py")  #
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopIntelligentmonitor():
@@ -249,7 +249,7 @@ def stopIntelligentmonitor():
         rets = getPid("intelligent_monitor.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopSignalmonitor():
@@ -257,7 +257,7 @@ def stopSignalmonitor():
         rets = getPid("signal_monitor.py")  #
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopSff_temp_polling():
@@ -265,7 +265,7 @@ def stopSff_temp_polling():
         rets = getPid("sfp_highest_temperatue.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopPMON_sys():
@@ -273,7 +273,7 @@ def stopPMON_sys():
         rets = getPid("pmon_syslog.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopRebootCause():
@@ -281,7 +281,7 @@ def stopRebootCause():
         rets = getPid("reboot_cause.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopSff_polling():
@@ -289,7 +289,7 @@ def stopSff_polling():
         rets = getPid("sff_polling.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stopGenerate_air_flow():
@@ -297,7 +297,7 @@ def stopGenerate_air_flow():
         rets = getPid("generate_airflow.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def stop_tty_console():
@@ -305,7 +305,7 @@ def stop_tty_console():
         rets = getPid("tty_console.py")
         for ret in rets:
             cmd = "kill " + ret
-            os.system(cmd)
+            log_os_system(cmd)
 
 
 def otherinit():
diff --git a/common/script/platform_sensors.py b/common/script/platform_sensors.py
index 4f400ca39..cea203931 100755
--- a/common/script/platform_sensors.py
+++ b/common/script/platform_sensors.py
@@ -277,4 +277,7 @@ def getsensors():
 
 
 if __name__ == "__main__":
+    if os.geteuid() != 0:
+        print("Root privileges are required for this operation")
+        sys.exit(1)
     getsensors()
diff --git a/common/script/platform_util.py b/common/script/platform_util.py
index 85b15601f..7364ea508 100755
--- a/common/script/platform_util.py
+++ b/common/script/platform_util.py
@@ -229,7 +229,7 @@ def getonieplatform(path):
 def getplatform_config_db():
     if not os.path.isfile(CONFIG_DB_PATH):
         return ""
-    val = os.popen("sonic-cfggen -j %s -v DEVICE_METADATA.localhost.platform" % CONFIG_DB_PATH).read().strip()
+    val = subprocess.check_output(["sonic-cfggen", "-j", CONFIG_DB_PATH, "-v", "DEVICE_METADATA.localhost.platform"]).decode().strip()
     if len(val) <= 0:
         return ""
     return val
diff --git a/common/script/set_eth_mac.py b/common/script/set_eth_mac.py
index 3e445a3ac..f4727d802 100755
--- a/common/script/set_eth_mac.py
+++ b/common/script/set_eth_mac.py
@@ -185,13 +185,13 @@ def set_e2_mac_to_config_file(eth_name, mac, ifcfg):
         if not os.path.exists(cfg_file_dir):
             cmd = "mkdir -p %s" % cfg_file_dir
             setmac_info("Create interfaces config directory: %s" % cfg_file_dir)
-            os.system(cmd)
-            os.system("sync")
+            exec_os_cmd(cmd)
+            exec_os_cmd("sync")
         wr_val = cfg_prefix + " %s\n" % eth_name
         wr_val += "    %s %s\n" % (mac_prefix, mac)
         with open(ifcfg_file_path, "w") as fd:
             fd.write(wr_val)
-        os.system("sync")
+        exec_os_cmd("sync")
         setmac_info("Create interfaces config: %s with mac address: %s" % (ifcfg_file_path, mac))
         return True
     except Exception as e:
diff --git a/common/sonic_platform/psu.py b/common/sonic_platform/psu.py
index 0812e8529..6b1583faf 100644
--- a/common/sonic_platform/psu.py
+++ b/common/sonic_platform/psu.py
@@ -360,3 +360,32 @@ class Psu(PsuBase):
             An object dervied from ThermalBase representing the specified thermal
         """
         return False
+
+    def get_psu_power_warning_suppress_threshold(self):
+        """
+        Retrieve the warning suppress threshold of the power on this PSU
+        The value can be volatile, so the caller should call the API each time it is used.
+    
+        Returns:
+            A float number, the warning suppress threshold of the PSU in watts.
+        """
+        self.psu_power_dict_update()
+        value = self.psu_power_dict["Outputs"]["Power"]["HighAlarm"]
+        if value is None:
+            return None
+        return round(float(value), 1)
+    
+    def get_psu_power_critical_threshold(self):
+        """
+        Retrieve the critical threshold of the power on this PSU
+        The value can be volatile, so the caller should call the API each time it is used.
+    
+        Returns:
+            A float number, the critical threshold of the PSU in watts.
+        """
+        self.psu_power_dict_update()
+        value = self.psu_power_dict["Outputs"]["Power"]["HighAlarm"]
+        if value is None:
+            return None
+        return round(float(value), 1)
+
diff --git a/m2-w6510-48v8c/config/x86_64_micas_m2_w6510_48v8c_r0_config.py b/m2-w6510-48v8c/config/x86_64_micas_m2_w6510_48v8c_r0_config.py
index d8569ea1d..933722387 100755
--- a/m2-w6510-48v8c/config/x86_64_micas_m2_w6510_48v8c_r0_config.py
+++ b/m2-w6510-48v8c/config/x86_64_micas_m2_w6510_48v8c_r0_config.py
@@ -738,8 +738,8 @@ DRIVERLISTS = [
     {"name": "wb_i2c_mux_pca954x_device", "delay": 0},
     {"name": "wb_i2c_dev_device", "delay": 0},
     {"name": "wb_lm75", "delay": 0},
-    {"name": "wb_optoe", "delay": 0},
-    {"name": "wb_at24", "delay": 0},
+    {"name": "optoe", "delay": 0},
+    {"name": "at24", "delay": 0},
     {"name": "wb_mac_bsc", "delay": 0},
     {"name": "wb_pmbus_core", "delay": 0},
     {"name": "wb_isl68137", "delay": 0},
@@ -758,17 +758,17 @@ DRIVERLISTS = [
 ]
 
 DEVICE = [
-    {"name": "wb_24c02", "bus": 0, "loc": 0x56},
+    {"name": "24c02", "bus": 0, "loc": 0x56},
     {"name": "wb_mac_bsc_td3", "bus": 3, "loc": 0x44},
     # fan
-    {"name": "wb_24c02", "bus": 16, "loc": 0x50},
-    {"name": "wb_24c02", "bus": 17, "loc": 0x50},
-    {"name": "wb_24c02", "bus": 18, "loc": 0x50},
-    {"name": "wb_24c02", "bus": 19, "loc": 0x50},
+    {"name": "24c02", "bus": 16, "loc": 0x50},
+    {"name": "24c02", "bus": 17, "loc": 0x50},
+    {"name": "24c02", "bus": 18, "loc": 0x50},
+    {"name": "24c02", "bus": 19, "loc": 0x50},
     # psu
-    {"name": "wb_24c02", "bus": 24, "loc": 0x50},
+    {"name": "24c02", "bus": 24, "loc": 0x50},
     {"name": "wb_dps550", "bus": 24, "loc": 0x58},
-    {"name": "wb_24c02", "bus": 25, "loc": 0x50},
+    {"name": "24c02", "bus": 25, "loc": 0x50},
     {"name": "wb_dps550", "bus": 25, "loc": 0x58},
     # temp
     {"name": "wb_lm75", "bus": 3, "loc": 0x48},
@@ -787,8 +787,8 @@ DEVICE = [
 ]
 
 OPTOE = [
-    {"name": "wb_optoe2", "startbus": 32, "endbus": 79},
-    {"name": "wb_optoe1", "startbus": 80, "endbus": 87},
+    {"name": "optoe2", "startbus": 32, "endbus": 79},
+    {"name": "optoe1", "startbus": 80, "endbus": 87},
 ]
 
 DEV_MONITOR_PARAM = {
@@ -799,7 +799,7 @@ DEV_MONITOR_PARAM = {
             "present": {"gettype": "i2c", "bus": 6, "loc": 0x0d, "offset": 0x51, "presentbit": 0, "okval": 0},
             "device": [
                 {"id": "psu1pmbus", "name": "wb_dps550", "bus": 24, "loc": 0x58, "attr": "hwmon"},
-                {"id": "psu1frue2", "name": "wb_24c02", "bus": 24, "loc": 0x50, "attr": "eeprom"},
+                {"id": "psu1frue2", "name": "24c02", "bus": 24, "loc": 0x50, "attr": "eeprom"},
             ],
         },
         {
@@ -807,7 +807,7 @@ DEV_MONITOR_PARAM = {
             "present": {"gettype": "i2c", "bus": 6, "loc": 0x0d, "offset": 0x51, "presentbit": 4, "okval": 0},
             "device": [
                 {"id": "psu2pmbus", "name": "wb_dps550", "bus": 25, "loc": 0x58, "attr": "hwmon"},
-                {"id": "psu2frue2", "name": "wb_24c02", "bus": 25, "loc": 0x50, "attr": "eeprom"},
+                {"id": "psu2frue2", "name": "24c02", "bus": 25, "loc": 0x50, "attr": "eeprom"},
             ],
         },
     ],
@@ -845,7 +845,7 @@ DEV_MONITOR_PARAM = {
         {
             "name": "eeprom",
             "device": [
-                {"id": "eeprom_1", "name": "wb_24c02", "bus": 0, "loc": 0x56, "attr": "eeprom"},
+                {"id": "eeprom_1", "name": "24c02", "bus": 0, "loc": 0x56, "attr": "eeprom"},
             ],
         },
         {
-- 
2.25.1

