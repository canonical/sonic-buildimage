#!/usr/bin/python -u
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
from subprocess import Popen, PIPE
import shlex
import time
import syslog
import copy
import jinja2
from swsssdk import ConfigDBConnector


class VrfCfg(object):
    def __init__(self):
        self.vrfconfig = {
            'mgmtVrfEnabled': 'false',
        }
        self.debug = False
        self.mgmt_vrfname = "mgmt"


    # Delete preexisting namespace during reboot/init. It will be created when the configuration from configDB is played.
    def delete_preexisting_mgmt_namespace(self):
        cmd = "ip netns list"
        out2 = subprocess.Popen(cmd, shell=True, stdout = subprocess.PIPE)
        for line in out2.stdout:
            namespace=line.split()[0]
            syslog.syslog (syslog.LOG_INFO, 'VrfCfg: INIT: Deleting pre-existing namespace = {0} after killing all processes running inside it'.format(namespace))
            # Kill running processes before deleting NS. Otherwise, eth0 wont go back to default VRF. 
            # kill will succeed if any process is running. Or else kill will fail which means that there is no process to kill; 
            # this is not an error and hence silently ignore the error output.
            cmd = "ip netns pids {0} | xargs kill".format (namespace)
            with open(os.devnull, 'w') as shutup:    
                 return_code = subprocess.call (cmd, stdout=shutup, stderr=shutup, shell=True)
            # Delete the namespace now.
            cmd = "ip netns del {0}".format (namespace)
            return_code = subprocess.call (cmd, shell=True)



    # Load conf from ConfigDb
    def load(self, vrf_conf):
        syslog.syslog(syslog.LOG_INFO, 'VrfCfg:INIT: Loading config from ConfigDb')
        for row in vrf_conf:
            syslog.syslog(syslog.LOG_INFO, 'VrfCfg:INIT: Calling config update with key as: {0}: Data={1}'.format(row, vrf_conf[row]))
            self.vrf_config_update(row, vrf_conf[row], modify_conf=False)

    def vrf_config_update(self, key, data, modify_conf=True):
        if data.has_key('mgmtVrfEnabled'):
            syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: ConfigUpdate: data has the mgmtVrfEnabled key. Check the value.')
            if (self.vrfconfig['mgmtVrfEnabled'] != data['mgmtVrfEnabled']):
                syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: ConfigUpdate: Current value of mgmtVrfEnabled:{0} is not same as user configured value:{1}. Take action.'.format(self.vrfconfig['mgmtVrfEnabled'], data['mgmtVrfEnabled']))

                # Check if management vrf is currently enabled. If so, explicitly remove the namespace.
                if (self.vrfconfig['mgmtVrfEnabled'] == "true"):
                        # User is disabling the already enabled management VRF.
                        #Check if management namespace is already running and delete all processes running in it.
                        syslog.syslog(syslog.LOG_INFO, 'VrfCfg: ConfigUpdate: User is disabling the currently enabled management VRF.')
                        cmd = "ip netns list | grep -w {0}".format (self.mgmt_vrfname)
                        return_code = subprocess.call (cmd, shell=True)
                        if (return_code ==0):
                            syslog.syslog (syslog.LOG_DEBUG, 'VrfCfgd: management vrf is running. Delete the processes running in it')
                            # Kill running processes before deleting NS. Otherwise, eth0 wont go back to default VRF. 
                            # kill will succeed if any process is running. Or else kill will fail which means that there is no 
                            # process to kill; this is not an error and hence silently ignore the error output.
                            with open(os.devnull, 'w') as shutup:    
                                 return_code = subprocess.call (cmd, stdout=shutup, stderr=shutup, shell=True)
                            # Delete the namespace now.
                            #cmd = "ip netns del {0}".format (self.mgmt_vrfname)
                            #return_code = subprocess.call (cmd, shell=True)
                            # Deletion of namespace is done in interfaces-config.sh script and hence it is commented here.

                else:
                    syslog.syslog(syslog.LOG_INFO, 'VrfCfg: ConfigUpdate: User is enabling the management VRF that is currently  disabled')
                    # User is enabling the management VRF that is currently disabled.
                    # Kill if any dhcp client is already running in eth0 and kill it.
                    cmd = "cat /var/run/dhclient.eth0.pid"
                    return_code = subprocess.call (cmd, shell=True)
                    if return_code == 0 :
                        syslog.syslog (syslog.LOG_DEBUG, 'VrfCfgd: dhclient is running in default VRF. command to be executed to kill it = {0}'.format(cmd))
                        cmd = "kill -9 $(cat /var/run/dhclient.eth0.pid)"
                        return_code = subprocess.call (cmd, shell=True)
                    else:
                        syslog.syslog (syslog.LOG_DEBUG, 'VrfCfgd: dhclient is not running in default VRF. Nothing to kill')


                # In both cases, set the local database with new value 
                self.vrfconfig['mgmtVrfEnabled'] = data['mgmtVrfEnabled']
                
                syslog.syslog(syslog.LOG_INFO, 'VrfCfg: ConfigUpdate: Restarting the interfaces-config  service')
                #Restart the "interfaces-config" service that creates the /etc/network/interfaces based on enable flag value.
                # If it is restarted for enabling management vrf, the service 
                # will place eth0 in /etc/network/interfaces.management and 
                # triggers the interface configurion on management namespace
                # using "ip netns exec management" using the script from
                # /etc/network/if-pre-up.d/netns and /etc/network/if-up.d/netns.
                # If it is restarted with enable flag as false, the service
                # places the eth0 in /etc/network/interfaces and triggers the
                # interface configuration on default VRF.
                return_code = subprocess.call ("systemctl restart interfaces-config", shell=True)
            else:
                syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: ConfigUpdate: Current value is same as user configured value. No action')
        else:
            syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: ConfigUpdate: mgmtVrfEnabled key itself not available. No action for enabling/disabling management VRF.')



class VrfConfigDaemon:
    def __init__(self):
        self.config_db = ConfigDBConnector()
        self.config_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'VrfCfg:INIT: ConfigDB connect success from VRF config manager')
        vc1 = self.config_db.get_table('MGMT_VRF_CONFIG')
        self.vrfconfig = VrfCfg()
        syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg:INIT: Calling Load Config')
        # Clear preexisting management namespace that linux might have created  as part of regular boot process. 
        # After deleting, "load" will take care of creating the management namespace if user has enabled it in ConfigDB.
	    # If user has not enabled management namespace, everything will come up without namespace.
        self.vrfconfig.delete_preexisting_mgmt_namespace()
        self.vrfconfig.load(vc1)

    def vrf_config_handler(self, key, data):
        syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: vrf_config_handler calling with key as:{} and data as: {}'.format(key, data))
        self.vrfconfig.vrf_config_update(key, data)


    def start(self):
        syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: START.')
        self.config_db.subscribe('MGMT_VRF_CONFIG', lambda table, key, data: self.vrf_config_handler(key, data))
        self.config_db.listen()


def main():
    daemon = VrfConfigDaemon()
    syslog.syslog(syslog.LOG_DEBUG, 'VrfCfg: MAIN: VrfConfigDaemon completed. Calling Start.')
    daemon.start()


if __name__ == "__main__":
    main()

