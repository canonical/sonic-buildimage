#!/usr/bin/python -u
# -*- coding: utf-8 -*-

import os
import socket 
import subprocess
import syslog
import inspect
from swsssdk import ConfigDBConnector

KUBESERVER_PORT = 6443

# DB field names
SERVER_TABLE = "KUBERNETES_MASTER"
SERVER_KEY = "SERVER"
CONFIG_IP = "ip"
CONFIG_DISABLE = "disable"

SERVER_IP = "server_ip"
SERVER_CONNECTED = "connected"
SERVER_REACHABILITY = "server_reachability"
SERVER_UPDATE_TS = "last_update_ts"
SERVER_CONFIG_UPDATE_TS = "config_update_ts"

SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "docker_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
DEPLOY_ID = "rolling_deploy_id"
SYSTEM_STATE = "system_state"

kube_server_state = {
        SERVER_IP: "",
        SERVER_CONNECTED: "false",
        SERVER_REACHABILITY: "false",
        SERVER_UPDATE_TS: "",
        SERVER_CONFIG_UPDATE_TS: ""
        }

state_db = None
cfg_db = None


def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)
    

def port_check(ip):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1) #Timeout in case of port not open
    r = s.connect_ex((ip, KUBESERVER_PORT))
    s.close()
    return r == 0


def checkout_reachable():
    global kube_server_state, state_db

    server_ip = kube_server_state[SERVER_IP]
    connected = kube_server_state[SERVER_CONNECTED].lower() == "true"
    server_reachable = kube_server_state[SERVER_REACHABILITY].lower() == "true"

    if not server_ip or not connected:
        return False

    state_reachable = port_check(server_ip)
    if not state_reachable:
        # Fire timer to check again
        threading.Timer(10, state_reachable).start()

    if server_reachable != state_reachable:
        debug_msg("server {} marked reachable={}".format(server_ip, state_reachable))
        state_db.mod_entry(SERVER_TABLE, SERVER_KEY, {
            SERVER_UPDATE_TS: str(datetime.datetime.now()),
            SERVER_REACHABILITY: "true" if state_reachable else "false" })

    return state_reachable 


class feature_manager:
    def __init__(self):
        global state_db, cfg_db

        self.state_data = state_db.get_table('FEATURE')

        cfg_table = cfg_db.get_table('FEATURE')
        for feat in cfg_table:
            self.handle_state_on_load(feat)


    def handle_state_on_load(self, feat):
        debug_msg("handle_state_on_load")
        self.process(feat)


    def on_update(self, feat, data):
        # Handle only remote_state == pending
        #
        debug_msg("handle_state_on_update old:{} new:{}".format(
            self.state_data[feat] if feat in self.state_data else {}, data))

        _, old_state = self.read_state(feat)
        self.state_data[feat] = data
        self.process(feat, old_state)


    def process(self, feat, old_state = "none"):
        if not self.validate_state(feat):
            return

        set_owner, _ = self.read_config(feat)
        current_owner, remote_state = self.read_state(feat)

        debug_msg("{} state(old: {} new:{}) owner=(set:{} current:{})".format(
            feat, old_state, remote_state, set_owner, current_owner))

        if ((set_owner == "kube") and (current_owner != "none") and
                (old_state != remote_state) and (remote_state == "pending")):
            # Kube is pending, call restart to stop current, so new can take over.
            self.restart_service(feat, set_owner)


    def on_server_update(self, old_data, ct_data):
        # Not used for now
        # TODO: ENsure config & state are in sync w.r.t set_owner & current_owner
        # Restart in local mode, with remote_state cleared to none on disconnect
        # 
        return


    # Helper methods
    #
    def validate_state(self, feat):
        status = os.system('systemctl is-active --quiet {}'.format(feat))
        if status != 0:
            debug_msg("{} systemctl not active for {}".format(inspect.stack()[1][3], feat))
        return status == 0


    def read_config(self, feat):
        global cfg_db

        cfg_data = cfg_db.get_table('FEATURE')
        cfg = cfg_data[feat] if feat in cfg_data else {}
        set_owner = cfg[SET_OWNER] if SET_OWNER in cfg else "local"
        fallback = not(cfg[NO_FALLBACK] if NO_FALLBACK in cfg else False)
        return(set_owner, fallback)

    def read_state(self, feat):
        stat = self.state_data[feat] if feat in self.state_data else {}
        current_owner = stat[CURRENT_OWNER] if CURRENT_OWNER in stat else "none"
        mode = stat[REMOTE_STATE] if REMOTE_STATE in stat else "none"
        return (current_owner, mode)


    def restart_service(self, feat, owner):
        debug_msg("Restart service {} to owner:{}".format(feat, owner))
        status = os.system("systemctl restart {}".format(feat))
        if status != 0:
            syslog.syslog(syslog.LOG_ERR,
                    "Failed to restart {} to switch to {}".format(feat, owner))
        else:
            syslog.syslog(syslog.LOG_INFO,
                    "Restarted {} to switch to {}".format(feat, owner))


class label_manager:
    # Watch for pending labels ("KUBE_LABELS|PENDING") and try reachability
    # Any time reachable call, kube_label to update pending labels.
    #

    def __init__(self):
        self.check_pending()


    def check_pending(self):
        pending = state_db.get_entry("KUBE_LABELS", "PENDING")
        if pending and checkout_reachable():
            proc = subprocess.Popen("/usr/bin/kube_label", shell=True)
            proc.wait()


    def on_update(self, key, data):
        if key == "PENDING":
            self.check_pending()


    def on_server_update(self, old_data, ct_data):
        if (old_data[SERVER_UPDATE_TS] != ct_data[SERVER_UPDATE_TS]):
            self.check_pending()


def check_server_connection():
    global state_db, cfg_db, kube_server_state

    tbl = cfg_db.get_table(SERVER_TABLE)
    cfg_data = tbl[SERVER_KEY]

    cfg_ip = cfg_data[CONFIG_IP] if CONFIG_IP in cfg_data else ""
    cfg_disable = ((cfg_data[CONFIG_DISABLE] if CONFIG_DISABLE in cfg_data else "false").
            lower() == "true")

    if cfg_disable or not cfg_ip:
        debug_msg("cfg_disable:{} cfg_ip:{} call kube_reset".format(cfg_disable, cfg_ip))
        # kube_reset()
    else:
        debug_msg("cfg_disable:{} cfg_ip:{} call kube_join".format(cfg_disable, cfg_ip))
        # kube_join()


class StateDBDeamon:
    def __init__(self):
        global state_db, cfg_db, kube_server_state

        cfg_db = ConfigDBConnector()
        cfg_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')

        state_db = ConfigDBConnector()
        state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'StateDB connect success')

        master = state_db.get_table(SERVER_TABLE)
        if SERVER_KEY in master:
            kube_server_state.update(master[SERVER_KEY])

        self.feature_handler = feature_manager()
        self.label_handler = label_manager()

        check_server_connection()


    def feature_update(self, key, data):
        self.feature_handler.on_update(key, data)

    def label_update(self, key, data):
        self.label_handler.on_update(key, data)

    def server_update(self, key, data):
        if key == SERVER_KEY:
            old_state = dict(kube_server_state)
            kube_server_state.update(data)
            self.label_handler.on_server_update(old_state, kube_server_state)
            self.feature_handler.on_server_update(old_state, kube_server_state)
            check_server_connection()

    def start(self):
        global state_db

        # Update all feature states once upon starting

        state_db.subscribe('FEATURE', lambda table, key, data: self.feature_update(key, data))
        state_db.subscribe('KUBE_LABELS', lambda table, key, data: self.label_update(key, data))
        state_db.subscribe(SERVER_TABLE, lambda table, key, data: self.server_update(key, data))
        state_db.listen()


def main():
    daemon = StateDBDeamon()
    daemon.start()


if __name__ == "__main__":
    main()
