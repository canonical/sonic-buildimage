#!/usr/bin/python -u
# -*- coding: utf-8 -*-

import os
import socket 
import subprocess
import syslog
import inspect
import threading
import datetime
from swsssdk import ConfigDBConnector
from config.kube import kube_join, kube_reset

KUBESERVER_PORT = 6443

# DB field names
SERVER_TABLE = "KUBERNETES_MASTER"
SERVER_KEY = "SERVER"
CONFIG_IP = "ip"
CONFIG_DISABLE = "disable"

SERVER_IP = "server_ip"
SERVER_CONNECTED = "connected"
SERVER_REACHABILITY = "server_reachability"
SERVER_UPDATE_TS = "last_update_ts"
SERVER_CONFIG_UPDATE_TS = "config_update_ts"

FEATURE_TABLE = "FEATURE"
SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"
CONFIG_STATE = "state"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "docker_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
DEPLOY_ID = "rolling_deploy_id"
SYSTEM_STATE = "system_state"

KUBE_LABEL_TABLE = "KUBE_LABELS"
KUBE_PENDING_KEY = "PENDING"


def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)
    

def port_check(ip):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1) #Timeout in case of port not open
    r = s.connect_ex((ip, KUBESERVER_PORT))
    s.close()
    return r == 0


def is_systemd_active(feat):
    status = os.system('systemctl is-active --quiet {}'.format(feat))
    if status != 0:
        debug_msg("{} systemctl not active for {}".format(inspect.stack()[1][3], feat))
    return status == 0


def restart_systemd_service(feat, owner):
    debug_msg("Restart service {} to owner:{}".format(feat, owner))
    status = os.system("systemctl restart {}".format(feat))
    if status != 0:
        syslog.syslog(syslog.LOG_ERR,
                "Failed to restart {} to switch to {}".format(feat, owner))
    else:
        syslog.syslog(syslog.LOG_INFO,
                "Restarted {} to switch to {}".format(feat, owner))


class feature_manager:
    # Helps with service restart, when kube deployed container is pending to run.
    #
    def __init__(self, cfg_db, tbl):
        self.cfg_db = cfg_db
        self.state_table = tbl

        cfg_table = self.cfg_db.get_table(FEATURE_TABLE)
        for feat in cfg_table:
            self.process(feat)


    def on_update(self, feat, data):
        # Handle only remote_state == pending
        #
        debug_msg("handle_state_on_update old:{} new:{}".format(
            str(self.state_table.get(feat, {})), str(data)))

        _, old_state = self.read_state(feat)
        self.state_table[feat] = data
        self.process(feat, old_state)


    def process(self, feat, old_state = "none"):
        if not is_systemd_active(feat):
            return

        set_owner = self.read_config(feat)
        current_owner, remote_state = self.read_state(feat)

        debug_msg("{} state(old: {} new:{}) owner=(set:{} current:{})".format(
            feat, old_state, remote_state, set_owner, current_owner))

        if ((set_owner == "kube") and (current_owner != "none") and
                (old_state != remote_state) and (remote_state == "pending")):
            # Kube is pending, call restart to stop current, so new can take over.
            restart_systemd_service(feat, set_owner)


    def on_server_update(self, old_data, ct_data):
        # Not used for now
        # TODO: ENsure config & state are in sync w.r.t set_owner & current_owner
        # Restart in local mode, with remote_state cleared to none on disconnect
        # 
        return


    # Helper methods
    #
    def read_config(self, feat):
        cfg_data = self.cfg_db.get_table(FEATURE_TABLE)
        cfg = cfg_data[feat] if feat in cfg_data else {}
        set_owner = cfg.get(SET_OWNER, "local")
        return set_owner

    def read_state(self, feat):
        stat = self.state_table[feat] if feat in self.state_table else {}
        current_owner = stat.get(CURRENT_OWNER, "none")
        mode = stat.get(REMOTE_STATE, "none")
        return (current_owner, mode)


class label_manager:
    # Watch for pending labels ("KUBE_LABELS|PENDING") and try reachability
    # Any time reachable call, kube_label to update pending labels.
    #

    def __init__(self, state_db, kube_server_state):
        self.state_db = state_db
        self.kube_server_state = kube_server_state
        self.check_pending()


    def checkout_reachable(self):
        server_ip = self.kube_server_state[SERVER_IP]
        connected = self.kube_server_state[SERVER_CONNECTED].lower() == "true"
        server_reachable = self.kube_server_state[SERVER_REACHABILITY].lower() == "true"

        if not server_ip or not connected:
            return False

        state_reachable = port_check(server_ip)
        if not state_reachable:
            # Fire timer to check again
            threading.Timer(10, self.checkout_reachable).start()

        if server_reachable != state_reachable:
            debug_msg("server {} marked reachable={}".format(server_ip, state_reachable))
            self.state_db.mod_entry(SERVER_TABLE, SERVER_KEY, {
                SERVER_UPDATE_TS: str(datetime.datetime.now()),
                SERVER_REACHABILITY: "true" if state_reachable else "false" })
            # Do not call check_pending as this call could be from timer thread.
            # Update the timestamp, which will alert the main thread and it 
            # would call check_pending.

        return state_reachable 

    def check_pending(self):
        pending = self.state_db.get_entry(KUBE_LABEL_TABLE, KUBE_PENDING_KEY)
        if pending and self.checkout_reachable():
            proc = subprocess.Popen("/usr/bin/kube_label", shell=True)
            proc.wait()


    def on_update(self, key, data):
        if key == KUBE_PENDING_KEY:
            self.check_pending()


    def on_server_update(self, old_data, ct_data):
        self.kube_server_state = ct_data
        if (old_data[SERVER_UPDATE_TS] != ct_data[SERVER_UPDATE_TS]):
            self.check_pending()


class kube_connection_handler:
    # Whenever kube server config changes, hostcfgd updates config-timestamp
    # in state-db KUBERNETES_MASTER|SERVER.
    # If connection reset required, it gets initiated immediately
    # Else, it may do additional checks before join
    #   a)  Ensure kubelet service is running
    #       kubelet service start is delayed with an associated timer service.
    #
    def __init__(self, cfg_db, state_db):
        self.cfg_db = cfg_db
        self.state_db = state_db

        self.join_or_reset()


    def check_kubelet_service(self, from_main_thread=False):
        ret = is_systemd_active("kubelet.service")
        debug_msg("kubelet service is{} running".format("" if ret else " not"))
        if not ret:
            debug_msg("Fire timer to check kubelet service")
            threading.Timer(10, self.check_kubelet_service).start()
        elif not from_main_thread:
            # Called by a different thread, so just update DB, which would trigger
            # main thread and call into on_server_update, which will do join/reset
            #
            self.state_db.mod_entry(SERVER_TABLE, SERVER_KEY,
                    { SERVER_UPDATE_TS: str(datetime.datetime.now()) })

        return ret


    def join_or_reset(self):
        # Join master or reset the connection with master per config.
        if self.check_kubelet_service(from_main_thread=True):
            tbl = self.cfg_db.get_table(SERVER_TABLE)
            cfg_data = tbl.get(SERVER_KEY, {})
            cfg_ip = cfg_data.get(CONFIG_IP, "")
            cfg_disable = cfg_data.get(CONFIG_DISABLE, "").lower() == "true"

            if cfg_disable or not cfg_ip:
                debug_msg("cfg_disable:{} cfg_ip:{} call kube_reset".format(cfg_disable, cfg_ip))
                kube_reset()
            else:
                debug_msg("cfg_disable:{} cfg_ip:{} call kube_join".format(cfg_disable, cfg_ip))
                kube_join()


    def on_server_update(self, old_date, ct_data):
        self.join_or_reset()

           
class StateDBDeamon:
    def __init__(self):
        self.cfg_db = ConfigDBConnector()
        self.cfg_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')

        self.state_db = ConfigDBConnector()
        self.state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'StateDB connect success')

        self.kube_server_state = {
                SERVER_IP: "",
                SERVER_CONNECTED: "false",
                SERVER_REACHABILITY: "false",
                SERVER_UPDATE_TS: "",
                SERVER_CONFIG_UPDATE_TS: ""
                }
        master = self.state_db.get_table(SERVER_TABLE)
        if SERVER_KEY in master:
            self.kube_server_state.update(master[SERVER_KEY])

        self.feature_handler = feature_manager(self.cfg_db, self.state_db.get_table(FEATURE_TABLE))
        self.label_handler = label_manager(self.state_db, self.kube_server_state)
        self.kube_connection_handler = kube_connection_handler(self.cfg_db, self.state_db)


    def feature_update(self, key, data):
        self.feature_handler.on_update(key, data)

    def label_update(self, key, data):
        self.label_handler.on_update(key, data)

    def server_update(self, key, data):
        if key == SERVER_KEY:
            old_state = dict(self.kube_server_state)
            self.kube_server_state.update(data)
            self.label_handler.on_server_update(old_state, self.kube_server_state)
            self.feature_handler.on_server_update(old_state, self.kube_server_state)
            self.kube_connection_handler.on_server_update(old_state, self.kube_server_state)
        else:
            debug_msg("key={} is not {}".format(key, SERVER_KEY))
        debug_msg("key={} data={} kube_server_state={}".format(key, str(data), str(self.kube_server_state)))


    def start(self):
        # Update all feature states once upon starting

        self.state_db.subscribe('FEATURE', lambda table, key, data: self.feature_update(key, data))
        self.state_db.subscribe('KUBE_LABELS', lambda table, key, data: self.label_update(key, data))
        self.state_db.subscribe(SERVER_TABLE, lambda table, key, data: self.server_update(key, data))
        self.state_db.listen()


def main():
    daemon = StateDBDeamon()
    daemon.start()


if __name__ == "__main__":
    main()
