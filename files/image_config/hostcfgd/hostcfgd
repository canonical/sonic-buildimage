#!/usr/bin/python -u
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
import syslog
import copy
import jinja2
import ipaddr as ipaddress
import netaddr
from swsssdk import ConfigDBConnector

# FILE
PAM_AUTH_CONF = "/etc/pam.d/common-auth-sonic"
PAM_AUTH_CONF_TEMPLATE = "/usr/share/sonic/templates/common-auth-sonic.j2"
NSS_TACPLUS_CONF = "/etc/tacplus_nss.conf"
NSS_TACPLUS_CONF_TEMPLATE = "/usr/share/sonic/templates/tacplus_nss.conf.j2"
NSS_CONF = "/etc/nsswitch.conf"

# TACACS+
TACPLUS_SERVER_PASSKEY_DEFAULT = ""
TACPLUS_SERVER_TIMEOUT_DEFAULT = "5"
TACPLUS_SERVER_AUTH_TYPE_DEFAULT = "pap"


def is_true(val):
    if val == 'True' or val == 'true':
        return True
    else:
        return False


def sub(l, start, end):
    return l[start:end]


def obfuscate(data):
    if data:
        return data[0] + '*****'
    else:
        return data

class Iptables(object):
    def __init__(self):
        '''
        Default MSS to 1460 - (MTU 1500 - 40 (TCP/IP Overhead))
        For IPv6, it would be 1440 - (MTU 1500 - 60 octects)
        '''
        self.tcpmss = 1460
        self.tcp6mss = 1440

    def is_ip_prefix_in_key(self, key):
        '''
        Function to check if IP address is present in the key. If it
        is present, then the key would be a tuple or else, it shall be
        be string
        '''
        return (isinstance(key, tuple))

    def load(self, lpbk_table):
        for row in lpbk_table:
            self.iptables_handler(row, lpbk_table[row])

    def command(self, chain, ip, ver, op):
        cmd = 'iptables' if ver == '4' else 'ip6tables'
        cmd += ' -t mangle --{} {} -p tcp --tcp-flags SYN SYN'.format(op, chain)
        cmd += ' -d' if chain == 'PREROUTING' else ' -s'
        mss = self.tcpmss if ver == '4' else self.tcp6mss
        cmd += ' {} -j TCPMSS --set-mss {}'.format(ip, mss)

        return cmd

    def iptables_handler(self, key, data, add=True):
        if not self.is_ip_prefix_in_key(key):
            return

        iface, ip = key
        ip_str = ip.split("/")[0]
        ip_addr = ipaddress.IPAddress(ip_str)
        if isinstance(ip_addr, ipaddress.IPv6Address):
            ver = '6'
        else:
            ver = '4'

        self.mangle_handler(ip_str, ver, add)

    def mangle_handler(self, ip, ver, add):
        if not add:
            op = 'delete'
        else:
            op = 'check'

        iptables_cmds = []
        chains = ['PREROUTING', 'POSTROUTING']
        for chain in chains:
            cmd = self.command(chain, ip, ver, op)
            if not add:
                iptables_cmds.append(cmd)
            else:
                '''
                For add case, first check if rule exists. Iptables just appends to the chain
                as a new rule even if it is the same as an existing one. Check this and
                do nothing if rule exists
                '''
                ret = subprocess.call(cmd, shell=True)
                if ret == 0:
                    syslog.syslog(syslog.LOG_INFO, "{} rule exists in {}".format(ip, chain))
                else:
                    # Modify command from Check to Append
                    iptables_cmds.append(cmd.replace("check", "append"))

        for cmd in iptables_cmds:
            syslog.syslog(syslog.LOG_INFO, "Running cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                              .format(err.cmd, err.returncode, err.output))

class AaaCfg(object):
    def __init__(self):
        self.auth_default = {
            'login': 'local',
        }
        self.tacplus_global_default = {
            'auth_type': TACPLUS_SERVER_AUTH_TYPE_DEFAULT,
            'timeout': TACPLUS_SERVER_TIMEOUT_DEFAULT,
            'passkey': TACPLUS_SERVER_PASSKEY_DEFAULT
        }
        self.auth = {}
        self.tacplus_global = {}
        self.tacplus_servers = {}
        self.debug = False

    # Load conf from ConfigDb
    def load(self, aaa_conf, tac_global_conf, tacplus_conf):
        for row in aaa_conf:
            self.aaa_update(row, aaa_conf[row], modify_conf=False)
        for row in tac_global_conf:
            self.tacacs_global_update(row, tac_global_conf[row], modify_conf=False)
        for row in tacplus_conf:
            self.tacacs_server_update(row, tacplus_conf[row], modify_conf=False)
        self.modify_conf_file()

    def aaa_update(self, key, data, modify_conf=True):
        if key == 'authentication':
            self.auth = data
            if 'failthrough' in data:
                self.auth['failthrough'] = is_true(data['failthrough'])
            if 'debug' in data:
                self.debug = is_true(data['debug'])
        if modify_conf:
            self.modify_conf_file()

    def tacacs_global_update(self, key, data, modify_conf=True):
        if key == 'global':
            self.tacplus_global = data
            if modify_conf:
                self.modify_conf_file()

    def tacacs_server_update(self, key, data, modify_conf=True):
        if data == {}:
            if key in self.tacplus_servers:
                del self.tacplus_servers[key]
        else:
            self.tacplus_servers[key] = data

        if modify_conf:
            self.modify_conf_file()

    def modify_single_file(self, filename, operations=None):
        if operations:
            cmd = "sed -e {0} {1} > {1}.new; mv -f {1} {1}.old; mv -f {1}.new {1}".format(' -e '.join(operations), filename)
            os.system(cmd)

    def modify_conf_file(self):
        auth = self.auth_default.copy()
        auth.update(self.auth)
        tacplus_global = self.tacplus_global_default.copy()
        tacplus_global.update(self.tacplus_global)

        servers_conf = []
        if self.tacplus_servers:
            for addr in self.tacplus_servers:
                server = tacplus_global.copy()
                server['ip'] = addr
                server.update(self.tacplus_servers[addr])
                servers_conf.append(server)
            servers_conf = sorted(servers_conf, key=lambda t: int(t['priority']), reverse=True)

        template_file = os.path.abspath(PAM_AUTH_CONF_TEMPLATE)
        env = jinja2.Environment(loader=jinja2.FileSystemLoader('/'), trim_blocks=True)
        env.filters['sub'] = sub
        template = env.get_template(template_file)
        pam_conf = template.render(auth=auth, servers=servers_conf)
        with open(PAM_AUTH_CONF, 'w') as f:
            f.write(pam_conf)

        # Modify common-auth include file in /etc/pam.d/login and sshd
        if os.path.isfile(PAM_AUTH_CONF):
            self.modify_single_file('/etc/pam.d/sshd',  [ "'/^@include/s/common-auth$/common-auth-sonic/'" ])
            self.modify_single_file('/etc/pam.d/login', [ "'/^@include/s/common-auth$/common-auth-sonic/'" ])
        else:
            self.modify_single_file('/etc/pam.d/sshd',  [ "'/^@include/s/common-auth-sonic$/common-auth/'" ])
            self.modify_single_file('/etc/pam.d/login', [ "'/^@include/s/common-auth-sonic$/common-auth/'" ])

        # Add tacplus in nsswitch.conf if TACACS+ enable
        if 'tacacs+' in auth['login']:
            if os.path.isfile(NSS_CONF):
                self.modify_single_file(NSS_CONF, [ "'/tacplus/b'", "'/^passwd/s/compat/tacplus &/'"])
        else:
            if os.path.isfile(NSS_CONF):
                self.modify_single_file(NSS_CONF, [ "'/^passwd/s/tacplus //'" ])

        # Set tacacs+ server in nss-tacplus conf
        template_file = os.path.abspath(NSS_TACPLUS_CONF_TEMPLATE)
        template = env.get_template(template_file)
        nss_tacplus_conf = template.render(debug=self.debug, servers=servers_conf)
        with open(NSS_TACPLUS_CONF, 'w') as f:
            f.write(nss_tacplus_conf)

#Management interface and Management VRF config handling

MGMT_INTF_ADMIN_STATUS_DEFAULT = "up"
CFG_MGMT_PORT_TABLE = "MGMT_PORT"
CFG_MGMT_INTF_TABLE = "MGMT_INTERFACE"
APP_MGMT_PORT_TABLE = "MGMT_PORT_TABLE"
APP_MGMT_INTF_TABLE = "MGMT_INTF_TABLE"
CFG_MGMT_VRF      = "MGMT_VRF_CONFIG"
CFG_MGMT_VRF_KEY  = "vrf_global"
MGMT_VRF_TABLE_ID = 5000

class MgmtVrfCfg:
    def __init__(self, config_db):
        syslog.syslog(syslog.LOG_INFO, 'Initializing MGMT VRF handler')
        self.config_db = config_db
        self.mgmt_vrf_table_created = False

    def create_mgmt_vrf_table(self):
        if self.mgmt_vrf_table_created == False:
            syslog.syslog(syslog.LOG_INFO, "Create MGMT VRF table:")
            cmd = 'ip link add name mgmt type vrf table {}'.format(MGMT_VRF_TABLE_ID)
            syslog.syslog(syslog.LOG_INFO, "Create MGMT VRF table, cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
                self.mgmt_vrf_table_created = True
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

    def delete_mgmt_vrf_table(self):
        if self.mgmt_vrf_table_created == True:
            syslog.syslog(syslog.LOG_INFO, "Delete MGMT VRF table:")
            cmd = 'ip link delete mgmt'
            syslog.syslog(syslog.LOG_INFO, "Delete MGMT VRF table, cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
                self.mgmt_vrf_table_created = False
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                        .format(err.cmd, err.returncode, err.output))

    def configure_mgmt_vrf(self):
        syslog.syslog(syslog.LOG_INFO, "Configure MGMT VRF:")

        self.create_mgmt_vrf_table()

        cmd = 'ip link set dev mgmt up'
        syslog.syslog(syslog.LOG_INFO, "Set MGMT VRF up, cmd - {}".format(cmd))

        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        syslog.syslog(syslog.LOG_INFO, "Add lo intf:")
        cmd = 'ip link add lo-m type dummy'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip addr add 127.0.0.1/8 dev lo-m'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip link set lo-m up'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        cmd = 'ip link set dev lo-m master mgmt'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))
            return

        self.bind_mgmt_intf()

    def bind_mgmt_intf(self):
        syslog.syslog(syslog.LOG_INFO, "Handle MGMT intf:")
        keys = self.config_db.get_keys(CFG_MGMT_INTF_TABLE)
        syslog.syslog(syslog.LOG_INFO, "MGMT interfaces keys: {}".format(str(keys)))

        mgmt_intf_bound = False
        for it in keys:
            if type(it) is unicode:
                mgmt_intf_name = it

                cmd = 'ip link set dev {} master mgmt'.format(mgmt_intf_name)
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                            .format(err.cmd, err.returncode, err.output))
                    return

                cmd = 'sysctl -w net.ipv4.tcp_l3mdev_accept=1'
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                            .format(err.cmd, err.returncode, err.output))
                    return

                mgmt_intf_bound = True
                break
        if not mgmt_intf_bound:
            syslog.syslog(syslog.LOG_ERR, "MGMT VRF: MGMT interface not bound")
        else:
            for it in keys:
                if type(it) is unicode:
                    key = it
                else:
                    key = it[0] + "|" + it[1]

                entry = self.config_db.get_entry(CFG_MGMT_INTF_TABLE, key)
                if 'gwaddr' in entry:
                    mgmt_intf_gwaddr = entry['gwaddr']
                    cmd = 'ip route add table {} 0.0.0.0/0 via {}'.format(MGMT_VRF_TABLE_ID, mgmt_intf_gwaddr)
                    syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                    try:
                        subprocess.check_call(cmd, shell=True)
                    except subprocess.CalledProcessError as err:
                        syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                                .format(err.cmd, err.returncode, err.output))
                        return

    def unconfigure_mgmt_vrf(self):
        syslog.syslog(syslog.LOG_INFO, "Unconfigure MGMT VRF:")

        cmd = 'ip link delete lo-m'
        syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

        self.delete_mgmt_vrf_table()
        return

    def handle_mgmt_intf_gwaddr_cfg(self, op, ifname, gwaddr):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT Intf gwaddr config, op: {}, ifname: {}, gwaddr: {}".format(op, ifname, gwaddr))
        keys = self.config_db.get_keys(CFG_MGMT_VRF)
        if keys:
            syslog.syslog(syslog.LOG_INFO, "MGMT VRF created")
            cmd = 'ip route del table {} 0.0.0.0/0'.format(MGMT_VRF_TABLE_ID)
            syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
            try:
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                pass
            
            if op == "ADD":
                cmd = 'ip route add table {} 0.0.0.0/0 via {}'.format(MGMT_VRF_TABLE_ID, gwaddr)
                syslog.syslog(syslog.LOG_INFO, "cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                    pass

        return True

    def handle_mgmt_intf_creation(self, mgmt_intf_key):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT Intf creation, key: {}".format(mgmt_intf_key))
        keys = self.config_db.get_keys(CFG_MGMT_VRF)
        if keys:
            syslog.syslog(syslog.LOG_INFO, "MGMT VRF created")
            self.bind_mgmt_intf()

    def handle_mgmt_vrf_cfg(self, key, data):
        syslog.syslog(syslog.LOG_INFO, "Received MGMT VRF config, key: {}, data: {}".format(key, data))
        try:
            if data:
                if data['mgmtVrfEnabled'] == 'true':
                    self.configure_mgmt_vrf()
                else:
                    self.unconfigure_mgmt_vrf()
            else:
                self.unconfigure_mgmt_vrf()
        except:
            syslog.syslog(syslog.LOG_ERR, "{} MGMT VRF Configuration failed.".format(key))



class MgmtIntfCfg:
    def __init__(self, cfg_db, mgmt_vrf_cfg):
        self.app_db = ConfigDBConnector()
        self.app_db.db_connect('APPL_DB', wait_for_init=False, retry_on=True)
        self.config_db = cfg_db
        self.mgmt_vrf_cfg = mgmt_vrf_cfg
        syslog.syslog(syslog.LOG_INFO, 'AppDB connect success')

        self.mgmt_intf_handle_default_cfg("eth0")

    def mgmt_intf_handle_default_cfg (self, ifname):
        mgmt_intf = self.config_db.get_entry(CFG_MGMT_PORT_TABLE, ifname)
        if mgmt_intf == {}:
            mgmt_intf['mtu'] = "1500"
            mgmt_intf['speed'] = "1000"
            mgmt_intf['admin_status'] = MGMT_INTF_ADMIN_STATUS_DEFAULT
            mgmt_intf['autoneg'] = "true"
            mgmt_intf['description'] = "Management0"
            syslog.syslog(syslog.LOG_INFO, "Default config populated for {}".format(ifname))
            self.config_db.set_entry(CFG_MGMT_PORT_TABLE, ifname, mgmt_intf)

        self.handle_mgmt_port_cfg(ifname, mgmt_intf)

        mgmt_intf = self.config_db.get_entry(CFG_MGMT_INTF_TABLE, ifname)
        if mgmt_intf == {}:
            mgmt_intf['ipv4_dhcp_client'] = "true"
            mgmt_intf['ipv6_dhcp_client'] = "true"
            self.config_db.set_entry(CFG_MGMT_INTF_TABLE, ifname, mgmt_intf)
            self.app_db.set_entry(APP_MGMT_INTF_TABLE, ifname, mgmt_intf)

    def mgmt_intf_mtu_set (self, ifname, mtu, appIntf):
        cmd = 'ifconfig {} mtu {}'.format(ifname, mtu)
        syslog.syslog(syslog.LOG_INFO, "Configure MTU, cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['mtu'] = mtu
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_admin_status_set (self, ifname, admin_status, appIntf):
        cmd = 'ifconfig {} {}'.format(ifname, admin_status)
        syslog.syslog(syslog.LOG_INFO, "Configure admin_status, cmd - {}".format(cmd))
        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['admin_status'] = admin_status
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_description_set (self, ifname, description, appIntf):
        syslog.syslog(syslog.LOG_INFO, "Configure description, cmd - {}".format(description))
        appIntf['description'] = description

    def mgmt_intf_speed_set (self, ifname, speed, autoneg, appIntf):
        duplex = "full"
        cmd = 'ethtool -s {} speed {} duplex {} autoneg {}; ifup {}'.format(ifname, speed, duplex, autoneg, ifname)
        syslog.syslog(syslog.LOG_INFO, "Configure SPEED, cmd - {}".format(cmd))

        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['speed'] = speed
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                    .format(err.cmd, err.returncode, err.output))

    def mgmt_intf_autoneg_set (self, ifname, autoneg, appIntf):
        an = "on"
        if autoneg == "true":
            an = "on"
        elif autoneg == "false":
            an = "off"

        cmd = "ethtool -s {} autoneg {}".format(ifname, an)
        syslog.syslog(syslog.LOG_INFO, "Configure autoneg, cmd - {}".format(cmd))

        try:
            subprocess.check_call(cmd, shell=True)
            appIntf['autoneg'] = autoneg
        except subprocess.CalledProcessError as err:
             syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))

    def mgmt_intf_gwaddr_set(self, ifname, ip_prefix, gwaddr, op):
        if not self.mgmt_vrf_cfg.handle_mgmt_intf_gwaddr_cfg(op, ifname, gwaddr):
            try:
                ip_conf = netaddr.IPNetwork(ip_prefix)
                if op == "DELETE":
                    cmd = "ip route del {}/{} via {} dev {}".format(ip_conf.network, ip_conf.prefixlen, gwaddr, ifname)
                else:
                    cmd = "ip route add {}/{} via {} dev {}".format(ip_conf.network, ip_conf.prefixlen, gwaddr, ifname)

                syslog.syslog(syslog.LOG_INFO, "Configure gwaddr , cmd : {}".format(cmd))
                subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
                pass

    def mgmt_intf_default_gwaddr_set (self, ifname, default_gw, op):
        try:
            if op == "DELETE":
                cmd = "ip route del default via {} dev {}".format(default_gw, ifname)
            else:
                cmd = "ip route add default via {} dev {}".format(default_gw, ifname)

            syslog.syslog(syslog.LOG_INFO, "Configure Default Gateway, cmd : {}".format(cmd))

            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
            pass

    def mgmt_intf_dhclient_set (self, ifname, attr, enable):
        version  = ""
        file_ext = ""
        cmd_opt  = ""

        if attr == "ipv6_dhcp_client":
            version = "-6"
            file_ext = "6"
            cmd_opt = "-D LL"

        if enable == True:
            try:
                path = "/var/run/dhclient{}.{}.pid".format(file_ext, ifname)
                if os.path.exists(path):
                    cmd = "[ -f /var/run/dhclient{}.{}.pid ] && kill `cat /var/run/dhclient{}.{}.pid` && rm -f /var/run/dhclient{}.{}.pid".format(file_ext, ifname, file_ext, ifname, file_ext, ifname)
                    subprocess.check_call(cmd, shell=True)
            except subprocess.CalledProcessError as err:
                pass

        try:
            if enable == True:
                cmd = "/sbin/dhclient {} -pf /run/dhclient{}.{}.pid -lf /var/lib/dhcp/dhclient{}.{}.leases {} -nw {} ".format(version, file_ext, ifname, file_ext, ifname, ifname, cmd_opt)
            else:
                cmd = "/sbin/dhclient {} -r {} && [ -f /var/run/dhclient{}.{}.pid ] && kill `cat /var/run/dhclient{}.{}.pid` && rm -f /var/run/dhclient{}.{}.pid".format(version, ifname, file_ext, ifname, file_ext, ifname, file_ext, ifname)

            syslog.syslog(syslog.LOG_INFO, "Configure dhclient , cmd : {}".format(cmd))

            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
            pass

    def mgmt_intf_ip_prefix_set (self, ifname, ip_prefix, op):
        try:
            if op == "DELETE":
                reset_prefix = "0.0.0.0"
                mgmt_conf = netaddr.IPNetwork(reset_prefix)
                cmd = "ip addr del {} dev {}".format(ip_prefix, ifname)
            else:
                mgmt_conf = netaddr.IPNetwork(ip_prefix)
                cmd = "ip addr add {} dev {}".format(ip_prefix, ifname)

            syslog.syslog(syslog.LOG_INFO, "Configure ip_prefix, op : {}, ip_prefix: {}, cmd : {}, mgmt_conf: {}".format(op, ip_prefix, cmd, mgmt_conf))
            subprocess.check_call(cmd, shell=True)
            cmd = "ip rule add from {} table default".format(str(mgmt_conf.ip))
            subprocess.check_call(cmd, shell=True)
        except subprocess.CalledProcessError as err:
            syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}".format(err.cmd, err.returncode, err.output))
            pass

    def handle_mgmt_port_cfg(self, key, data):
        mgmt_intf =  self.app_db.get_entry(APP_MGMT_PORT_TABLE, key)
        is_all = False
        if mgmt_intf == {}:
            is_all = True

        try:
            if (('mtu' in data) and ((is_all == True) or (mgmt_intf == {}) or ('mtu' not in mgmt_intf) or (data['mtu'] != mgmt_intf['mtu']))):
                self.mgmt_intf_mtu_set(key, data['mtu'], mgmt_intf)

            if (('description' in data) and ((is_all == True) or (mgmt_intf == {}) or ('description' not in mgmt_intf) or (data['description'] != mgmt_intf['description']))):
                self.mgmt_intf_description_set(key, data['description'], mgmt_intf)

            if (('admin_status' in data) and ((is_all == True) or (mgmt_intf == {}) or ('admin_status' not in mgmt_intf) or (data['admin_status'] != mgmt_intf['admin_status']))):
                self.mgmt_intf_admin_status_set(key, data['admin_status'], mgmt_intf)

            if (('autoneg' in data) and ((is_all == True) or (mgmt_intf == {}) or ('autoneg' not in mgmt_intf) or (data['autoneg'] != mgmt_intf['autoneg']))):
                self.mgmt_intf_autoneg_set(key, data['autoneg'], mgmt_intf)

            if (('speed' in data) and ((is_all == True) or (mgmt_intf == {}) or ('speed' not in mgmt_intf) or (data['speed'] != mgmt_intf['speed']))):
                autoneg = "on"
                if 'autoneg' in data:
                    if data['autoneg'] == "false":
                        autoneg = "off"
                self.mgmt_intf_speed_set(key, data['speed'], autoneg, mgmt_intf)
        except:
            syslog.syslog(syslog.LOG_ERR, "{} MGMT Port Config set failed.".format(key))

        self.app_db.set_entry(APP_MGMT_PORT_TABLE, key, mgmt_intf)


    def handle_mgmt_intf_cfg(self, key, data):
        cur_appdb_key = key.replace('|', ':')
        intf_keys = key.split("|")
        cfgdb_entry = self.config_db.get_entry(CFG_MGMT_INTF_TABLE, key)
        appdb_entry = self.app_db.get_entry(APP_MGMT_INTF_TABLE, cur_appdb_key)
        op = "DELETE"
        keys = self.config_db.get_keys(CFG_MGMT_INTF_TABLE)

        for it in keys:
            if len(it) != 2:
                it = (it, )
                it_key = it[0]
            else:
                it_key = it[0] + "|" + it[1]

            if it_key == key:
                op = "CREATE"
                break

        if op == "CREATE":
            if cfgdb_entry != {} and appdb_entry != {}:
                op = "UPDATE"


        if (len(intf_keys) < 2):
            if op == "DELETE":
                cfgdb_entry['ipv4_dhcp_client'] = "true"
                cfgdb_entry['ipv6_dhcp_client'] = "true"

                if (('ipv4_dhcp_client' not in appdb_entry) or (appdb_entry['ipv4_dhcp_client'] != cfgdb_entry['ipv4_dhcp_client'])):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv4_dhcp_client", True)
                    appdb_entry['ipv4_dhcp_client'] = cfgdb_entry['ipv4_dhcp_client']

                if (('ipv6_dhcp_client' not in appdb_entry) or (appdb_entry['ipv6_dhcp_client'] != cfgdb_entry['ipv6_dhcp_client'])):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv6_dhcp_client", True)
                    appdb_entry['ipv6_dhcp_client'] = cfgdb_entry['ipv6_dhcp_client']

                if ('ipv4_default_gwaddr' in appdb_entry):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv4_default_gwaddr'], "DELETE")
                    del appdb_entry['ipv4_default_gwaddr']

                if ('ipv6_default_gwaddr' in appdb_entry):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv6_default_gwaddr'], "DELETE")
                    del appdb_entry['ipv6_default_gwaddr']

                self.app_db.set_entry(APP_MGMT_INTF_TABLE, cur_appdb_key, appdb_entry)
                self.config_db.set_entry(CFG_MGMT_INTF_TABLE, key, cfgdb_entry)

            elif op == "CREATE":
                syslog.syslog(syslog.LOG_ERR, "handle_mgmt_intf_cfg: operation is CREATE, return after vrf create handling")
                self.mgmt_vrf_cfg.handle_mgmt_intf_creation(key)

                if ('ipv4_dhcp_client' in cfgdb_entry):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv4_dhcp_client", cfgdb_entry['ipv4_dhcp_client'] == "true")
                    appdb_entry['ipv4_dhcp_client'] = cfgdb_entry['ipv4_dhcp_client']

                if ('ipv6_dhcp_client' in cfgdb_entry):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv6_dhcp_client", cfgdb_entry['ipv6_dhcp_client'] == "true")
                    appdb_entry['ipv6_dhcp_client'] = cfgdb_entry['ipv6_dhcp_client']

                if ('ipv4_default_gwaddr' in cfgdb_entry):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv4_default_gwaddr'], "ADD")
                    appdb_entry['ipv4_default_gwaddr'] = cfgdb_entry['ipv4_default_gwaddr']

                if ('ipv6_default_gwaddr' in cfgdb_entry):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv6_default_gwaddr'], "ADD")
                    appdb_entry['ipv6_default_gwaddr'] = cfgdb_entry['ipv6_default_gwaddr']

                self.app_db.set_entry(APP_MGMT_INTF_TABLE, cur_appdb_key, appdb_entry)

            elif op == "UPDATE":
                if (('ipv4_dhcp_client' in cfgdb_entry) and ('ipv4_dhcp_client' not in appdb_entry)):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv4_dhcp_client", cfgdb_entry['ipv4_dhcp_client'] == "true")
                    appdb_entry['ipv4_dhcp_client'] = cfgdb_entry['ipv4_dhcp_client']
                elif (('ipv4_dhcp_client' in cfgdb_entry) and (cfgdb_entry['ipv4_dhcp_client'] != appdb_entry['ipv4_dhcp_client'])):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv4_dhcp_client", cfgdb_entry['ipv4_dhcp_client'] == "true")
                    appdb_entry['ipv4_dhcp_client'] = cfgdb_entry['ipv4_dhcp_client']

                if (('ipv6_dhcp_client' in cfgdb_entry) and ('ipv6_dhcp_client' not in appdb_entry)):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv6_dhcp_client", cfgdb_entry['ipv6_dhcp_client'] == "true")
                    appdb_entry['ipv6_dhcp_client'] = cfgdb_entry['ipv6_dhcp_client']
                elif (('ipv6_dhcp_client' in cfgdb_entry) and (cfgdb_entry['ipv6_dhcp_client'] != appdb_entry['ipv6_dhcp_client'])):
                    self.mgmt_intf_dhclient_set(intf_keys[0], "ipv6_dhcp_client", cfgdb_entry['ipv6_dhcp_client'] == "true")
                    appdb_entry['ipv6_dhcp_client'] = cfgdb_entry['ipv6_dhcp_client']

                if (('ipv4_default_gwaddr' in cfgdb_entry) and ('ipv4_default_gwaddr' not in appdb_entry)):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv4_default_gwaddr'], "ADD")
                    appdb_entry['ipv4_default_gwaddr'] = cfgdb_entry['ipv4_default_gwaddr']
                elif (('ipv4_default_gwaddr' in cfgdb_entry) and (cfgdb_entry['ipv4_default_gwaddr'] != appdb_entry['ipv4_default_gwaddr'])):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv4_default_gwaddr'], "DELETE")
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv4_default_gwaddr'], "ADD")
                    appdb_entry['ipv4_default_gwaddr'] = cfgdb_entry['ipv4_default_gwaddr']
                elif (('ipv4_default_gwaddr' not in cfgdb_entry) and ('ipv4_default_gwaddr' in appdb_entry)):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv4_default_gwaddr'], "DELETE")
                    del appdb_entry['ipv4_default_gwaddr']

                if (('ipv6_default_gwaddr' in cfgdb_entry) and ('ipv6_default_gwaddr' not in appdb_entry)):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv6_default_gwaddr'], "ADD")
                    appdb_entry['ipv6_default_gwaddr'] = cfgdb_entry['ipv6_default_gwaddr']
                elif (('ipv6_default_gwaddr' in cfgdb_entry) and (cfgdb_entry['ipv6_default_gwaddr'] != appdb_entry['ipv6_default_gwaddr'])):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv6_default_gwaddr'], "DELETE")
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], cfgdb_entry['ipv6_default_gwaddr'], "ADD")
                    appdb_entry['ipv6_default_gwaddr'] = cfgdb_entry['ipv6_default_gwaddr']
                elif (('ipv6_default_gwaddr' not in cfgdb_entry) and ('ipv6_default_gwaddr' in appdb_entry)):
                    self.mgmt_intf_default_gwaddr_set(intf_keys[0], appdb_entry['ipv6_default_gwaddr'], "DELETE")
                    del appdb_entry['ipv6_default_gwaddr']

                self.app_db.set_entry(APP_MGMT_INTF_TABLE, cur_appdb_key, appdb_entry)
        else:
            input_ip = ipaddress.IPNetwork(intf_keys[1])
            if op == "CREATE" or op == "UPDATE" :
                self.mgmt_intf_ip_prefix_set(intf_keys[0], intf_keys[1], "ADD")
                if (('gwaddr' in data) and ((appdb_entry == {}) or ('gwaddr' not in appdb_entry))):
                    self.mgmt_intf_gwaddr_set(intf_keys[0], intf_keys[1], data['gwaddr'], "ADD")
                    appdb_entry['gwaddr'] = data['gwaddr']
                elif (('gwaddr' in data) and ('gwaddr' not in cfgdb_entry) and ('gwaddr' in appdb_entry)):
                    self.mgmt_intf_gwaddr_set(intf_keys[0], intf_keys[1], data['gwaddr'],"DELETE")
                    del appdb_entry['gwaddr']
                elif (('gwaddr' in data) and (data['gwaddr'] != appdb_entry['gwaddr'])):
                    self.mgmt_intf_gwaddr_set(intf_keys[0], intf_keys[1], appdb_entry['gwaddr'],"DELETE")
                    self.mgmt_intf_gwaddr_set(intf_keys[0], intf_keys[1], data['gwaddr'], "ADD")
                    appdb_entry['gwaddr'] = data['gwaddr']

                if appdb_entry == {}:
                    appdb_entry["NULL"] = "NULL"

                self.app_db.set_entry(APP_MGMT_INTF_TABLE, cur_appdb_key, appdb_entry)

            else:
                self.mgmt_intf_ip_prefix_set(intf_keys[0], intf_keys[1], "DELETE")
                if ('gwaddr' in data):
                    self.mgmt_intf_gwaddr_set(intf_keys[0], intf_keys[1], data['gwaddr'], "DELETE")
                self.app_db.delete_entry(APP_MGMT_INTF_TABLE, cur_appdb_key)



class HostConfigDaemon:
    def __init__(self):
        self.config_db = ConfigDBConnector()
        self.config_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')
        aaa = self.config_db.get_table('AAA')
        tacacs_global = self.config_db.get_table('TACPLUS')
        tacacs_server = self.config_db.get_table('TACPLUS_SERVER')
        self.aaacfg = AaaCfg()
        self.aaacfg.load(aaa, tacacs_global, tacacs_server)
        self.mgmtvrfcfg = MgmtVrfCfg(self.config_db)
        self.mgmtcfg = MgmtIntfCfg(self.config_db, self.mgmtvrfcfg)
        lpbk_table = self.config_db.get_table('LOOPBACK_INTERFACE')
        self.iptables = Iptables()
        self.iptables.load(lpbk_table)

    def aaa_handler(self, key, data):
        self.aaacfg.aaa_update(key, data)

    def tacacs_server_handler(self, key, data):
        self.aaacfg.tacacs_server_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def tacacs_global_handler(self, key, data):
        self.aaacfg.tacacs_global_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_INFO, 'value of {} changed to {}'.format(key, log_data))

    def lpbk_handler(self, key, data):
        key = ConfigDBConnector.deserialize_key(key)
        #Check if delete operation by fetch existing keys
        keys = self.config_db.get_keys('LOOPBACK_INTERFACE')
        if key in keys:
            add = True
        else:
            add = False

        self.iptables.iptables_handler(key, data, add)

    def mgmt_vrf_handler(self, key, data):
        self.mgmtvrfcfg.handle_mgmt_vrf_cfg(key, data)

    def mgmt_port_handler(self, key, data):
        self.mgmtcfg.handle_mgmt_port_cfg(key, data)

    def mgmt_intf_handler(self, key, data):
        self.mgmtcfg.handle_mgmt_intf_cfg(key, data)

    def feature_status_handler(self, key, data):
        status_data = self.config_db.get_table('FEATURE')
        for key in status_data.keys():
            if not key:
                syslog.syslog(syslog.LOG_WARNING, "FEATURE key is missing")
                return
        status = status_data[key]['status']
        if not status:
            syslog.syslog(syslog.LOG_WARNING, "status is missing for {}".format(key))
            return
        if status == "enabled":
            start_cmds=[]
            start_cmds.append("sudo systemctl enable {}".format(key))
            start_cmds.append("sudo systemctl start {}".format(key))
            for cmd in start_cmds:
                syslog.syslog(syslog.LOG_INFO, "Running cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                              .format(err.cmd, err.returncode, err.output))
                    return
            syslog.syslog(syslog.LOG_INFO, "Feature '{}' is enabled and started".format(key))
        elif status == "disabled":
            stop_cmds=[]
            stop_cmds.append("sudo systemctl stop {}".format(key))
            stop_cmds.append("sudo systemctl disable {}".format(key))
            for cmd in stop_cmds:
                syslog.syslog(syslog.LOG_INFO, "Running cmd - {}".format(cmd))
                try:
                    subprocess.check_call(cmd, shell=True)
                except subprocess.CalledProcessError as err:
                    syslog.syslog(syslog.LOG_ERR, "{} - failed: return code - {}, output:\n{}"
                              .format(err.cmd, err.returncode, err.output))
                    return
            syslog.syslog(syslog.LOG_INFO, "Feature '{}' is stopped and disabled".format(key))
        else:
            syslog.syslog(syslog.LOG_ERR, "Unexpected status value '{}' for '{}'".format(status, key))

    def start(self):
        self.config_db.subscribe('AAA', lambda table, key, data: self.aaa_handler(key, data))
        self.config_db.subscribe('TACPLUS_SERVER', lambda table, key, data: self.tacacs_server_handler(key, data))
        self.config_db.subscribe('TACPLUS', lambda table, key, data: self.tacacs_global_handler(key, data))
        self.config_db.subscribe('LOOPBACK_INTERFACE', lambda table, key, data: self.lpbk_handler(key, data))
        self.config_db.subscribe('FEATURE', lambda table, key, data: self.feature_status_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_VRF, lambda table, key, data: self.mgmt_vrf_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_PORT_TABLE, lambda table, key, data: self.mgmt_port_handler(key, data))
        self.config_db.subscribe(CFG_MGMT_INTF_TABLE, lambda table, key, data: self.mgmt_intf_handler(key, data))
        self.config_db.listen()


def main():
    daemon = HostConfigDaemon()
    daemon.start()


if __name__ == "__main__":
    main()
