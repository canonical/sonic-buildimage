#!/usr/bin/python -u
# -*- coding: utf-8 -*-

import os
import sys
import subprocess
import syslog
import copy
import jinja2
from swsssdk import ConfigDBConnector

# FILE
PAM_AUTH_CONF = "/etc/pam.d/common-auth-sonic"
PAM_AUTH_CONF_TEMPLATE = "/usr/share/sonic/templates/common-auth-sonic.j2"
NSS_TACPLUS_CONF = "/etc/tacplus_nss.conf"
NSS_TACPLUS_CONF_TEMPLATE = "/usr/share/sonic/templates/tacplus_nss.conf.j2"
NSS_CONF = "/etc/nsswitch.conf"

# TACACS+
TACPLUS_SERVER_PASSKEY_DEFAULT = ""
TACPLUS_SERVER_TIMEOUT_DEFAULT = "5"
TACPLUS_SERVER_AUTH_TYPE_DEFAULT = "pap"

MAX_TACPLUS_SERVERS=10
TACPLUS_SERVER_LOCAL_IP="127.100.100.1"
TACPLUS_LOCAL_PORT_START=62000


def is_true(val):
    if val == 'True' or val == 'true':
        return True
    else:
        return False


def sub(l, start, end):
    return l[start:end]


def obfuscate(data):
    if data:
        return data[0] + '*****'
    else:
        return data


class AaaCfg(object):
    def __init__(self):
        self.auth_default = {
            'login': 'local',
            'failthrough': True,
            'fallback': True
        }
        self.tacplus_global_default = {
            'auth_type': TACPLUS_SERVER_AUTH_TYPE_DEFAULT,
            'timeout': TACPLUS_SERVER_TIMEOUT_DEFAULT,
            'passkey': TACPLUS_SERVER_PASSKEY_DEFAULT
        }
        self.auth = {}
        self.tacplus_global = {}
        self.tacplus_servers = {}
        # Maintain the mapping between user configured tacacs server publicIP to localport
        self.localport_for_server_publicip = {}
        # Maintain the mapping between user configured tacacs server publicPort for the serverIP
        self.publicport_for_server_publicip = {}
        # Maintain the local_port_status for all 10 servers as either "free" or "used"
        self.local_port_status = {}
        self.debug = False
        # next_free_local_port shows the next least numbered free port between 62000 and 62009
        #Initializing next_free_PORT as 62000
        self.next_free_local_port = TACPLUS_LOCAL_PORT_START
        for x in range (MAX_TACPLUS_SERVERS):
            #Initializing all the available 10 ports as "free"
            self.local_port_status[x]="free"


    def update_next_free_local_port(self):
        # Check all the status of 10 ports and find the next available free port
        for x in range (MAX_TACPLUS_SERVERS):
            local_port = TACPLUS_LOCAL_PORT_START + x
            if self.local_port_status[x]=='free':
                #Chaning the next free port to this free local port
                self.next_free_local_port = local_port
                break


    # Load conf from ConfigDb
    def load(self, aaa_conf, tac_global_conf, tacplus_conf):
        for row in aaa_conf:
            self.aaa_update(row, aaa_conf[row], modify_conf=False)
        for row in tac_global_conf:
            self.tacacs_global_update(row, tac_global_conf[row], modify_conf=False)
        for row in tacplus_conf:
            self.tacacs_server_update(row, tacplus_conf[row], modify_conf=False)
        self.modify_conf_file()

    def aaa_update(self, key, data, modify_conf=True):
        if key == 'authentication':
            self.auth = data
            if 'failthrough' in data:
                self.auth['failthrough'] = is_true(data['failthrough'])
            if 'debug' in data:
                self.debug = is_true(data['debug'])
        if modify_conf:
            self.modify_conf_file()

    def tacacs_global_update(self, key, data, modify_conf=True):
        if key == 'global':
            self.tacplus_global = data
            if modify_conf:
                self.modify_conf_file()

    def tacacs_server_update(self, key, data, modify_conf=True):
        if data == {}:
            if key in self.tacplus_servers:
                #Deleting tacplus_server
                if (self.tacplus_servers[key]['vrf'] == "mgmt"):
                    #Tacacs Server in Management VRF has to be deleted
                    local_port_used = self.localport_for_server_publicip[key]
                    user_configured_port = self.publicport_for_server_publicip[key]
                    # Compose the ip netns command to remove the previously created DNAT rule from management VRF iptables.
                    cmd2 = "ip netns exec mgmt iptables -t nat -D PREROUTING -i if1 -p tcp -d {0} --dport {1} -j DNAT --to-destination {2}:{3}".format(TACPLUS_SERVER_LOCAL_IP, local_port_used, key, user_configured_port)
                    os.system(cmd2) 
                    # Marking local_port as free
                    self.local_port_status[local_port_used-TACPLUS_LOCAL_PORT_START] = "free"
                    # If the self.next_free_local_port is greater than the currently freed port, update it with this least port number
                    if (self.next_free_local_port > local_port_used):
                        #Changing next free from old value to new value
                        self.next_free_local_port = self.localport_for_server_publicip[key]

                # Irrespectie of server in management VRF or default VRF, delete it from our tacplus_server list.
                del self.tacplus_servers[key]

        else:
            if (data['vrf'] == "mgmt") :
                # tacplus_server need to be added in management VRF.
                # Save the user configured publicPort that is required later while adding DNAT rule.
                data['user_configured_server_port'] = data['tcp_port']
                # set the tcp_port in data to the local port to be used in the tacacs config file.
                data['tcp_port'] = str(self.next_free_local_port)

                # Compose the iptables rule to be added to in management namespace.
                cmd = "ip netns exec mgmt iptables -t nat -A PREROUTING -i if1 -p tcp -d {0} --dport {1} -j DNAT --to-destination {2}:{3}".format(TACPLUS_SERVER_LOCAL_IP, self.next_free_local_port, key, data['user_configured_server_port'])
                os.system(cmd)

                #Update the mapping table with the local port that is used and the actual publicIP configured by user.
                # mapping table is index using the tacplus server publicIP (which is the "key").
                self.localport_for_server_publicip[key] = self.next_free_local_port
                self.publicport_for_server_publicip[key] = data['user_configured_server_port']

                # Mark the local_port array element as "used"
                self.local_port_status[self.next_free_local_port-TACPLUS_LOCAL_PORT_START]="used"
                # Call the function to update the next available free port.
                self.update_next_free_local_port()

            # Update internal data structure tacplus_servers with the data.
            self.tacplus_servers[key] = data

        if modify_conf:
            self.modify_conf_file()

    def modify_conf_file(self):
        auth = self.auth_default.copy()
        auth.update(self.auth)
        tacplus_global = self.tacplus_global_default.copy()
        tacplus_global.update(self.tacplus_global)

        servers_conf = []
        if self.tacplus_servers:
            for addr in self.tacplus_servers:
                server = tacplus_global.copy()
                # It is expected that user configured ports are less than 62000. Value about 62000 until 62009 are local ports
                # used for NAT that is requried for supporting management VRF.
                # If localport has been assigned as part of NAT, use that local IP & local port instead of publicIP and publicPort.
                # This will update the tacplus server configuration file with local IP and local port if the server is reachable via the management VRF.
                if (int(self.tacplus_servers[addr]['tcp_port']) >= TACPLUS_LOCAL_PORT_START):
                    if (int(self.tacplus_servers[addr]['tcp_port']) < TACPLUS_LOCAL_PORT_START+MAX_TACPLUS_SERVERS):
                        # This means that the publicIP is already mapped to local IP and local port
                        server['ip'] = TACPLUS_SERVER_LOCAL_IP
                else :
                    server['ip'] = addr
                server.update(self.tacplus_servers[addr])
                servers_conf.append(server)
            sorted(servers_conf, key=lambda t: t['priority'], reverse=True)

        template_file = os.path.abspath(PAM_AUTH_CONF_TEMPLATE)
        env = jinja2.Environment(loader=jinja2.FileSystemLoader('/'), trim_blocks=True)
        env.filters['sub'] = sub
        template = env.get_template(template_file)
        pam_conf = template.render(auth=auth, servers=servers_conf)
        with open(PAM_AUTH_CONF, 'w') as f:
            f.write(pam_conf)

        # Modify common-auth include file in /etc/pam.d/login and sshd
        if os.path.isfile(PAM_AUTH_CONF):
            os.system("sed -i -e '/^@include/s/common-auth$/common-auth-sonic/' /etc/pam.d/sshd")
            os.system("sed -i -e '/^@include/s/common-auth$/common-auth-sonic/' /etc/pam.d/login")
        else:
            os.system("sed -i -e '/^@include/s/common-auth-sonic$/common-auth/' /etc/pam.d/sshd")
            os.system("sed -i -e '/^@include/s/common-auth-sonic$/common-auth/' /etc/pam.d/login")

        # Add tacplus in nsswitch.conf if TACACS+ enable
        if 'tacacs+' in auth['login']:
            if os.path.isfile(NSS_CONF):
                os.system("sed -i -e '/tacplus/b' -e '/^passwd/s/compat/tacplus &/' /etc/nsswitch.conf")
        else:
            if os.path.isfile(NSS_CONF):
                os.system("sed -i -e '/^passwd/s/tacplus //' /etc/nsswitch.conf")

        # Set tacacs+ server in nss-tacplus conf
        template_file = os.path.abspath(NSS_TACPLUS_CONF_TEMPLATE)
        template = env.get_template(template_file)
        nss_tacplus_conf = template.render(debug=self.debug, servers=servers_conf)
        with open(NSS_TACPLUS_CONF, 'w') as f:
            f.write(nss_tacplus_conf)


class HostConfigDaemon:
    def __init__(self):
        self.config_db = ConfigDBConnector()
        self.config_db.connect(wait_for_init=True, retry_on=True)
        syslog.syslog(syslog.LOG_INFO, 'ConfigDB connect success')
        aaa = self.config_db.get_table('AAA')
        tacacs_global = self.config_db.get_table('TACPLUS')
        tacacs_server = self.config_db.get_table('TACPLUS_SERVER')
        self.aaacfg = AaaCfg()
        self.aaacfg.load(aaa, tacacs_global, tacacs_server)

    def aaa_handler(self, key, data):
        self.aaacfg.aaa_update(key, data)

    def tacacs_server_handler(self, key, data):
        self.aaacfg.tacacs_server_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_DEBUG, 'value of {} changed to {}'.format(key, log_data))

    def tacacs_global_handler(self, key, data):
        self.aaacfg.tacacs_global_update(key, data)
        log_data = copy.deepcopy(data)
        if log_data.has_key('passkey'):
            log_data['passkey'] = obfuscate(log_data['passkey'])
        syslog.syslog(syslog.LOG_DEBUG, 'value of {} changed to {}'.format(key, log_data))

    def start(self):
        self.config_db.subscribe('AAA', lambda table, key, data: self.aaa_handler(key, data))
        self.config_db.subscribe('TACPLUS_SERVER', lambda table, key, data: self.tacacs_server_handler(key, data))
        self.config_db.subscribe('TACPLUS', lambda table, key, data: self.tacacs_global_handler(key, data))
        self.config_db.listen()


def main():
    daemon = HostConfigDaemon()
    daemon.start()


if __name__ == "__main__":
    main()

