#!/usr/bin/env python

"""
    docker-wait-any
    This script takes one or more Docker container names as arguments,
    and it will block indefinitely while all of the specified containers
    are running. If any of the specified containers stop, the script will
    exit.
    This script was created because the 'docker wait' command is lacking
    this functionality. It will block until ALL specified containers have
    stopped running. Here, we spawn multiple threads and wait on one
    container per thread. If any of the threads exit, the entire
    application will exit.
    NOTE: This script is written against docker Python package 4.1.0. Newer
    versions of docker may have a different API.
"""
import argparse
import subprocess
import sys
import threading
import time

from docker import APIClient
from sonic_py_common import logger
from swsssdk import SonicV2Connector

SYSLOG_IDENTIFIER = 'docker-wait-any'

# Global logger instance
log = logger.Logger(SYSLOG_IDENTIFIER)

# Instantiate a global event to share among our threads
g_thread_exit_event = threading.Event()
g_service = []
g_dep_services = []

# Check if System warm reboot, or Container warm restart is enabled.
def is_warm_restart_enabled(container_name):
    state_db = SonicV2Connector(host='127.0.0.1')
    state_db.connect(state_db.STATE_DB, False)

    TABLE_NAME_SEPARATOR = '|'
    prefix = 'WARM_RESTART_ENABLE_TABLE' + TABLE_NAME_SEPARATOR

    # Get the system warm reboot enable state
    _hash = '{}{}'.format(prefix, 'system')
    wr_system_state = state_db.get(state_db.STATE_DB, _hash, "enable")
    wr_enable_state = True if wr_system_state == "true" else False

    # Get the container warm reboot enable state
    _hash = '{}{}'.format(prefix, container_name)
    wr_container_state = state_db.get(state_db.STATE_DB, _hash, "enable")
    wr_enable_state |= True if wr_container_state == "true" else False

    state_db.close(state_db.STATE_DB)
    return wr_enable_state

# Check if System fast reboot is enabled.
def is_fast_reboot_enabled():
    fb_system_state = 0
    cmd = 'sonic-db-cli STATE_DB get "FAST_REBOOT|system"'
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    (stdout, stderr) = proc.communicate()

    if proc.returncode != 0:
        log.log_error("Error running command '{}'".format(cmd))
    elif stdout:
        fb_system_state = stdout.rstrip('\n')

    return fb_system_state

def wait_for_container(docker_client, container_name):
    while True:
        while docker_client.inspect_container(container_name)['State']['Status'] != "running":
            time.sleep(1)

        docker_client.wait(container_name)

        log.log_info("No longer waiting on container '{}'".format(container_name))

        # If this is a dependent service and warm restart is enabled for the system/container,
        # OR if the system is going through a fast-reboot, DON'T signal main thread to exit
        if container_name in g_dep_services and (is_warm_restart_enabled(container_name) or is_fast_reboot_enabled()):
            continue

        # Signal the main thread to exit
        g_thread_exit_event.set()

def main():
    thread_list = []

    docker_client = APIClient(base_url='unix://var/run/docker.sock')

    parser  = argparse.ArgumentParser(description='Wait for dependent docker services',
                                      version='1.0.0',
                                      formatter_class=argparse.RawTextHelpFormatter,
                                      epilog="""
Examples:
  docker-wait-any -s swss -d syncd teamd
""")

    parser.add_argument('-s','--service', nargs='+', default=None, help='name of the service')
    parser.add_argument('-d','--dependent', nargs='*', default=None, help='other dependent services')
    args = parser.parse_args()

    global g_service
    global g_dep_services

    if args.service is not None:
        g_service = args.service
    if args.dependent is not None:
        g_dep_services = args.dependent

    container_names = g_service + g_dep_services

    # If the service and dependents passed as args is empty, then exit
    if container_names == []:
        sys.exit(0)

    for container_name in container_names:
        t = threading.Thread(target=wait_for_container, args=[docker_client, container_name])
        t.daemon = True
        t.start()
        thread_list.append(t)

    # Wait until we receive an event signifying one of the containers has stopped
    g_thread_exit_event.wait()
    sys.exit(0)

if __name__ == '__main__':
    main()
