#!/usr/bin/env python3

import getopt
import os
import select
import signal
import sys
import syslog
import time

import swsssdk

from supervisor import childutils

# Each line of this file should specify either one critical process or one
# critical process group, (as defined in supervisord.conf file), in the
# following format:
#
# program:<process_name>
# group:<group_name>
CRITICAL_PROCESSES_FILE = '/etc/supervisor/critical_processes'

# The FEATURE table in config db contains auto-restart field
FEATURE_TABLE_NAME = 'FEATURE'

# Value of parameter 'timeout' in select(...) method
SELECT_TIMEOUT_SECS = 1.0

# Alerting message will be written into syslog in the following interval
ALERTING_INTERVAL_SECS = 60


def get_critical_group_and_process_list():
    """
    @summary: Read the critical processes/group names from CRITICAL_PROCESSES_FILE.
    @return: Two lists which contain critical processes and group names respectively.
    """
    critical_group_list = []
    critical_process_list = []

    with open(CRITICAL_PROCESSES_FILE, 'r') as file:
        for line in file:
            line_info = line.strip(' \n').split(':')
            if len(line_info) != 2:
                syslog.syslog(syslog.LOG_ERR,
                              "Syntax of the line {} in critical_processes file is incorrect. Exiting...".format(line))
                sys.exit(5)

            identifier_key = line_info[0].strip()
            identifier_value = line_info[1].strip()
            if identifier_key == "group" and identifier_value:
                critical_group_list.append(identifier_value)
            elif identifier_key == "program" and identifier_value:
                critical_process_list.append(identifier_value)
            else:
                syslog.syslog(syslog.LOG_ERR,
                              "Syntax of the line {} in critical_processes file is incorrect. Exiting...".format(line))
                sys.exit(6)

    return critical_group_list, critical_process_list


def get_command_result(command):
    """
    @summary: Execute the command and return the resulting output.
    @return: A string which contains the execution result.
    """
    command_stdout = ""

    try:
        proc_instance = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                         shell=True, universal_newlines=True)
        command_stdout, command_stderr = proc_instance.communicate()
        if proc_instance.returncode != 0:
            syslog.syslog(syslog.LOG_ERR, "Failed to execute the command '{}'. Return code: '{}'".format(
                command, proc_instance.returncode))
            sys.exit(7)
    except (OSError, ValueError) as err:
        syslog.syslog(syslog.LOG_ERR, "Failed to execute the command '{}'. Error: '{}'".format(command, err))
        sys.exit(8)

    return command_stdout


def process_running(process_name):
    """
    @summary: Determine whether a critical process was running or not.
    @return: Return 'True' if process was runnning. Otherwise return 'False'.
    """
    supervisorctl_status_command = "supervisorctl status"
    command_stdout = ""
    is_running = False

    command_stdout = get_command_result(supervisorctl_status_command)

    for line in command_stdout.split("\n"):
        if process_name in line:
            status = line.split()[1].strip()
            if status == "RUNNING":
                is_running = True
            break

    return is_running


def generate_alerting_message(process_name):
    """
    @summary: If a critical process was not running, this function will determine it resides in host
              or in a specific namespace. Then an alerting message will be written into syslog.
    """
    namespace_prefix = os.environ.get("NAMESPACE_PREFIX")
    namespace_id = os.environ.get("NAMESPACE_ID")

    if not namespace_prefix or not namespace_id:
        syslog.syslog(syslog.LOG_ERR, "Process '{}' is not running in 'host'.".format(process_name))
    else:
        namespace = namespace_prefix + namespace_id
        syslog.syslog(
            syslog.LOG_ERR, "Process '{}' is not running in namespace '{}'.".format(process_name, namespace))


def get_autorestart_state(container_name):
    """
    @summary: Read the status of auto-restart feature from Config_DB.
    @return: Return the status of auto-restart feature.
    """
    config_db = swsssdk.ConfigDBConnector()
    config_db.connect()
    features_table = config_db.get_table(FEATURE_TABLE_NAME)
    if not features_table:
        syslog.syslog(syslog.LOG_ERR, "Unable to retrieve features table from Config DB. Exiting...")
        sys.exit(2)

    if container_name not in features_table:
        syslog.syslog(syslog.LOG_ERR, "Unable to retrieve feature '{}'. Exiting...".format(container_name))
        sys.exit(3)

    restart_feature = features_table[container_name].get('auto_restart')
    if not restart_feature:
        syslog.syslog(
            syslog.LOG_ERR, "Unable to determine auto-restart feature status for '{}'. Exiting...".format(container_name))
        sys.exit(4)

    return restart_feature


def main(argv):
    container_name = None
    opts, args = getopt.getopt(argv, "c:", ["container-name="])
    for opt, arg in opts:
        if opt in ("-c", "--container-name"):
            container_name = arg

    if not container_name:
        syslog.syslog(syslog.LOG_ERR, "Container name not specified. Exiting...")
        sys.exit(1)

    critical_group_list, critical_process_list = get_critical_group_and_process_list()

    process_under_alerting = {}
    # Transition from ACKNOWLEDGED to READY
    childutils.listener.ready()

    while True:
        file_descriptor_list = select.select([sys.stdin], [], [], SELECT_TIMEOUT_SECS)[0]
        if len(file_descriptor_list) > 0:
            line = file_descriptor_list[0].readline()
            headers = childutils.get_headers(line)
            payload = sys.stdin.read(int(headers['len']))

            # We only care about PROCESS_STATE_EXITED events
            if headers['eventname'] == 'PROCESS_STATE_EXITED':
                payload_headers, payload_data = childutils.eventdata(payload + '\n')

                expected = int(payload_headers['expected'])
                processname = payload_headers['processname']
                groupname = payload_headers['groupname']

                if ((processname in critical_process_list or groupname in critical_group_list)
                        and expected == 0):
                    if container_name != "database":
                        restart_feature = get_autorestart_state(container_name)

                    if container_name == "database" or restart_feature != "disabled":
                        MSG_FORMAT_STR = "Process '{}' exited unexpectedly. Terminating supervisor '{}'"
                        msg = MSG_FORMAT_STR.format(payload_headers['processname'], container_name)
                        syslog.syslog(syslog.LOG_INFO, msg)
                        os.kill(os.getppid(), signal.SIGTERM)
                    else:
                        process_under_alerting[processname] = time.time()

            # Transition from BUSY to ACKNOWLEDGED
            childutils.listener.ok()

            # Transition from ACKNOWLEDGED to READY
            childutils.listener.ready()

        # Check whether we need write alerting messages into syslog
        for process in process_under_alerting.keys():
            epoch_time = time.time()
            if process_running(process):
                process_under_alerting.pop(process)
            elif epoch_time - process_under_alerting[process] >= ALERTING_INTERVAL_SECS:
                process_under_alerting[process] = epoch_time
                generate_alerting_message(process)


if __name__ == "__main__":
    main(sys.argv[1:])
