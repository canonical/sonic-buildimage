#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import socket 
import subprocess
import syslog
import inspect
import argparse
import datetime
import sys

sys.path.append("/usr/local/lib/python2.7/dist-packages/")
sys.path.append("/usr/lib/python2.7/dist-packages/")

from swsssdk import ConfigDBConnector

KUBESERVER_PORT = 6443

# DB field names
SERVER_KEY = "server"
SERVER_IP = "server_ip"
SERVER_CONNECTED = "connected"
SERVER_REACHABILITY = "server_reachability"
SERVER_UPDATE_TS = "last_update_ts"

KUBE_ADMIN_CONF = "/etc/sonic/kube_admin.conf"
# kubectl --kubeconfig <KUBE_ADMIN_CONF> label nodes <socket.hostname()> <label to be added>
KUBECTL_LABEL_CMD = "kubectl --kubeconfig {} label --overwrite nodes {} {}"


def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)
    


def port_check(ip):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(1) #Timeout in case of port not open
    r = s.connect_ex((ip, KUBESERVER_PORT))
    s.close()
    return r == 0


def run_command(cmd):
    try:
        proc = subprocess.Popen(cmd.split(' '))
        proc.wait(timeout=2)
        ret = proc.returncode
    except subprocess.TimeoutExpired as error:
        proc.kill()
        ret = -1

    return ret


def write_labels(labels):

    ret = run_command(KUBECTL_LABEL_CMD.format(
        KUBE_ADMIN_CONF, socket.gethostname(), labels))

    debug_msg("{} kube labels {} ret={}".format(
        "Applied" if ret == 0 else "Failed to apply", labels, ret))
    return ret

 
def drain_pending(pending):
    # e.g. pending = { <name>:<val>, ...}
    # Empty string for val implies label remove else create
    #
    labels = ""
    for name in pending.keys():
        val = pending[name]
        labels += "{}={} ".format(name, val) if val else "{}-".format(name)

    return write_labels(labels.strip())


def write_label(name, val):

    state_db = ConfigDBConnector()
    state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)
    syslog.syslog(syslog.LOG_INFO, 'StateDB connect success')

    server_data = state_db.get_entry("KUBERNETES_MASTER", "SERVER")

    server_ip = server_data[SERVER_IP] if SERVER_IP in server_data else ""
    server_connected = ((server_data[SERVER_CONNECTED].lower()
            if SERVER_CONNECTED  in server_data else "false")).lower() == "true"

    server_reachability = ((server_data[SERVER_REACHABILITY].lower()
            if SERVER_REACHABILITY  in server_data else "false")).lower() == "true"

    if server_ip and server_connected:
        connect_status = port_check(server_ip)
    else:
        connect_status = False

    if server_reachability != connect_status:
        ts = datetime.datetime.now()
        state_db.mod_entry("KUBERNETES_MASTER", "SERVER",
                { SERVER_CONNECT_STATUS: "true" if connect_status else "false",
                    SERVER_UPDATE_TS: ts })

    pending = state_db.get_entry("KUBE_LABELS", "PENDING")

    if name:
        pending[name] = val if val else ""

    if pending:
        if connect_status:
            ret = drain_pending(pending)
        else: 
            ret = -1

        if ret == 0:
            state_db.mod_entry("KUBE_LABELS", "PENDING", None)
        elif name:
            state_db.mod_entry("KUBE_LABELS", "PENDING", {name: val})

    return 0


def main():
    parser=argparse.ArgumentParser(description="Update labels")
    parser.add_argument("-n", "--name", help="Name of the label", default="")
    parser.add_argument("-v", "--value", help="value of the label", default="")

    args = parser.parse_args()

    ret = write_label(args.name, args.value)
    return ret

if __name__ == "__main__":
    ret = main()
    sys.exit(ret)

