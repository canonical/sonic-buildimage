#!/usr/bin/env python

import syslog
import subprocess
import argparse
import inspect
import time
from swsssdk import ConfigDBConnector

remote_features = ("snmp", "telemetry", "pmon", "lldp", "radv", "dhcp_relay")

state_db = None

# DB field names
FEATURE_TABLE = "FEATURE"
SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "container_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
SYSTEM_STATE = "system_state"

def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)


def init():
    global state_db, cfg_db

    cfg_db = ConfigDBConnector()
    cfg_db.connect(wait_for_init=True, retry_on=True)

    state_db = ConfigDBConnector()
    state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)


def read_data(is_config, feature, fields, defaults):
    ret = []

    db = cfg_db if is_config else state_db

    tbl = db.get_table(FEATURE_TABLE)

    data = tbl[feature] if feature in tbl else {}
    i = 0
    for field in fields:
        val = data.get(field, defaults[i])
        i += 1
        ret += [val]

    debug_msg("config:{} feature:{} fields:{} val:{}".format(
        is_config, feature, str(fields), str(ret)))

    return tuple(ret)


def read_config(feature):

    set_owner, no_fallback  = read_data(True, feature, 
            (SET_OWNER, NO_FALLBACK), ("local", False))

    return (set_owner, not no_fallback)


def read_state(feature):

    return read_data(False, feature,
            (CURRENT_OWNER, REMOTE_STATE, DOCKER_ID), ("none", "none", ""))


def docker_action(action, feature):
    cmd = "docker {} {}".format(action, feature)
    proc = subprocess.Popen(cmd, shell=True)
    proc.wait()
    debug_msg("docker cmd: {}".format(cmd))
    return proc.returncode


def set_label(feature, create):
    cmd = "/usr/bin/kube_label -n {}_enabled".format(feature)
    if create:
        cmd += " -v true"
    debug_msg("run command for label: {}".format(cmd))
    try:
        subprocess.check_call(cmd, shell=True)
        return 0
    except subprocess.CalledProcessError as err:
        syslog.syslog(syslog.LOG_ERR, "'{}' failed. RC: {}, output: {}".
                format(err.cmd, err.returncode, err.output))
        return -1


def update_data(feature, data):
    debug_msg("feature:{} data:{}".format(feature, str(data)))
    state_db.mod_entry(FEATURE_TABLE, feature, data)


def container_start(feature):
    ret = 0
    debug_msg("BEGIN")
    set_owner, fallback = read_config(feature)
    _, remote_state, _ = read_state(feature)

    debug_msg("{}: set_owner:{} fallback:{} remote_state:{}".format(
        feature, set_owner, fallback, remote_state))

    update_data(feature, {SYSTEM_STATE: "up"})

    if set_owner == "local":
        # Ensure label is not there.
        set_label(feature, False)
        if remote_state.lower() != "none":
            update_data(feature, {REMOTE_STATE: "none"})
        ret = docker_action("start", feature)

    else:
        if fallback and (remote_state == "none"):
            # Start local as fallback enabled & no transition occuring.
            ret = docker_action("start", feature)
        set_label(feature, True)

    debug_msg("END")
    return ret


def container_stop(feature):
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (remote_state != "pending") or (set_owner == "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if not docker_id:
        docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("stop", docker_id)

    current_owner, remote_state, docker_id = read_state(feature)
    if ((current_owner != "none") or docker_id):
        # container did not clear data upon termination; Possibly killed
        # This could also happen when kubelet forcefully terminate
        # Forceful termination is possible when master connection is reset.
        #
        debug_msg("Force resetting feature:{} status to none".format(feature))
        update_data(feature, {
            CURRENT_OWNER: "none",
            REMOTE_STATE: "none",
            DOCKER_ID: ""})

    debug_msg("END")


def container_kill(feature):
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (set_owner != "local") or (current_owner != "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if not docker_id:
        docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("kill", docker_id)

    proc = subprocess.Popen("container_state.py down -f {}".format(feature))
    proc.wait()

    debug_msg("END")


def container_wait(feature):
    debug_msg("BEGIN")

    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)

    if ((not docker_id) and (
        (set_owner == "local") or (current_owner == "local"))):
        docker_id = feature

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    while not docker_id:
        time.sleep(2)

        current_owner, remote_state, docker_id = read_state(feature)

        debug_msg("wait_loop: {} = {} {} {}".format(feature, current_owner, remote_state, docker_id))

        if (remote_state == "pending"):
            update_data(feature, {REMOTE_STATE: "ready"})


    debug_msg("END -- transitioning to docker wait")
    docker_action("wait", docker_id)


def container_id(feature):
    current_owner, _, docker_id = read_state(feature)
    if ((not docker_id) and (
            (set_owner == "local") or (current_owner == "local"))):
        docker_id = feature
    print(docker_id)


def main():
    parser=argparse.ArgumentParser(description="container commands for start/stop/wait/kill/id")
    parser.add_argument("action", choices=["start", "stop", "wait", "kill", "id"])
    parser.add_argument("name")

    args = parser.parse_args()

    init()

    if args.name not in remote_features:
        docker_action(args.action, args.name)

    elif args.action == "start":
        container_start(args.name)

    elif args.action == "stop":
        container_stop(args.name)

    elif args.action == "kill":
        container_kill(args.name)

    elif args.action == "wait":
        container_wait(args.name)

    elif args.action == "id":
        container_id(args.name)

    else:
        print("Unknown action {} for name {}".format(action, name))


if __name__ == "__main__":
    main()

