#!/usr/bin/env python

import os
import sys
import syslog
import subprocess
import argparse
import inspect
import time
from swsssdk import ConfigDBConnector

local_only = ("database", "syncd", "swss")

global state_db
state_db = None

# DB field names
SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "docker_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
DEPLOY_ID = "rolling_deploy_id"
SYSTEM_STATE = "system_state"

def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)


def init():
    global state_db, cfg_db

    cfg_db = ConfigDBConnector()
    cfg_db.connect(wait_for_init=True, retry_on=True)

    state_db = ConfigDBConnector()
    state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)


def read_data(is_config, feature, fields, defaults):
    ret = ()

    db = cfg_db if is_config else state_db

    tbl = db.get_table('FEATURE')

    data = tbl[feature] if feature in tbl else {}
    i = 0
    for field in fields:
        val = data[field] if field in data else defaults[i]
        i += 1
        ret += (val, )

    debug_msg("config:{} feature:{} fields:{} val:{}".format(
        is_config, feature, str(fields), str(ret)))

    return ret


def read_config(feature):

    set_owner, no_fallback  = read_data(True, feature, 
            (SET_OWNER, NO_FALLBACK), ("local", False))

    return (set_owner, not no_fallback)


def read_state(feature):

    return read_data(False, feature,
            (CURRENT_OWNER, REMOTE_STATE, DOCKER_ID), ("none", "none", ""))


def docker_action(action, feature):
    cmd = ["docker", action, feature]
    proc = subprocess.Popen(cmd)
    proc.wait()
    debug_msg("docker cmd: {}".format(" ".join(cmd)))
    return proc.returncode


def set_label(feature, create):
    cmd = "/usr/bin/kube_label -n {}_enabled".format(feature)
    if create:
        cmd += " -v true"
    debug_msg("run command for label: {}".format(cmd))
    try:
        subprocess.check_call(cmd, shell=True)
        return 0
    except subprocess.CalledProcessError as err:
        syslog.syslog(syslog.LOG_ERR, "'{}' failed. RC: {}, output: {}".
                format(err.cmd, err.returncode, err.output))
        return -1


def update_field(feature, field, val):
    debug_msg("feature:{} field:{} val:{}".format(feature, field, val))
    state_db.mod_entry('FEATURE', feature, { field: val })


def container_start(feature):
    ret = 0
    debug_msg("BEGIN")
    set_owner, fallback = read_config(feature)
    _, remote_state, _ = read_state(feature)

    debug_msg("{}: set_owner:{} fallback:{} remote_state:{}".format(
        feature, set_owner, fallback, remote_state))

    update_field(feature, SYSTEM_STATE, "up")

    if set_owner == "local":
        if remote_state.lower() != "none":
            update_field(feature, REMOTE_STATE, "none")
            remote_state = "none"
        ret = docker_action("start", feature)

    else:
        if fallback and (remote_state == "none"):
            # Start local as fallback enabled & no transition occuring.
            ret = docker_action("start", feature)

        set_label(feature, True)
    debug_msg("END")
    return ret


def container_stop(feature):
    ret = 0
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (remote_state != "pending") or (set_owner == "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_field(feature, SYSTEM_STATE, "down")

    if not docker_id:
        if current_owner == "local":
            docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        ret = docker_action("stop", docker_id)

    debug_msg("END")


def container_kill(feature):
    ret = 0
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (set_owner != "local") or (current_owner != "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_field(feature, SYSTEM_STATE, "down")

    if not docker_id:
        if current_owner == "local":
            docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        ret = docker_action("kill", docker_id)

    proc = subprocess.Popen("container_state.py down -f {}".format(feature))
    proc.wait()

    debug_msg("END")


def container_wait(feature):
    ret = 0
    debug_msg("BEGIN")

    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    is_local = False

    if ((not docker_id) and (
        (set_owner == "local") or (current_owner == "local"))):
        docker_id = feature

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    while not docker_id:
        time.sleep(2)

        current_owner, remote_state, docker_id = read_state(feature)

        debug_msg("wait_loop: {} = {} {} {}".format(feature, current_owner, remote_state, docker_id))

        if (remote_state == "pending"):
            update_field(feature, REMOTE_STATE, "ready")


    debug_msg("END -- transitioning to docker wait")
    return docker_action("wait", docker_id)


def container_id(feature):
    current_owner, _, docker_id = read_state(feature)
    if ((not docker_id) and (
            (set_owner == "local") or (current_owner == "local"))):
        docker_id = feature
    print(docker_id)
    return docker_id


def main():
    parser=argparse.ArgumentParser(description="container commands for start/stop/wait/kill/id")
    parser.add_argument("action", choices=["start", "stop", "wait", "kill", "id"])
    parser.add_argument("name")

    args = parser.parse_args()

    init()

    if args.name in local_only:
        docker_action(args.action, args.name)

    elif args.action == "start":
        container_start(args.name)

    elif args.action == "stop":
        container_stop(args.name)

    elif args.action == "kill":
        container_kill(args.name)

    elif args.action == "wait":
        container_wait(args.name)

    elif args.action == "id":
        container_id(args.name)

    else:
        print("Unknown action {} for name {}".format(action, name))


if __name__ == "__main__":
    main()

