#!/usr/bin/env python

import sys
import datetime
import time
import syslog
import signal
import traceback
import os

import yaml
from swsscommon import swsscommon

from app.directory import Directory
from app.managers_setsrc import ZebraSetSrc
from app.managers_bgp import BGPPeerMgrBase
from app.managers_intf import InterfaceMgr
from app.managers_db import BGPDataBaseMgr
from app.runner import Runner
from app.vars import g_debug
from app.log import log_notice, log_info, log_warn, log_crit
from app.template import TemplateFabric
from app.config import ConfigMgr
from app.managers_allow_list import BGPAllowListMgr
from app.util import run_command

g_run = True


def wait_for_daemons(daemons, seconds):
    """
    Wait until FRR daemons are ready for requests
    :param daemons: list of FRR daemons to wait
    :param seconds: number of seconds to wait, until raise an error
    """
    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
    log_info("Start waiting for FRR daemons: %s" % str(datetime.datetime.now()))
    while datetime.datetime.now() < stop_time:
        ret_code, out, err = run_command(["vtysh", "-c", "show daemons"], hide_errors=True)
        if ret_code == 0 and all(daemon in out for daemon in daemons):
            log_info("All required daemons have connected to vtysh: %s" % str(datetime.datetime.now()))
            return
        else:
            log_warn("Can't read daemon status from FRR: %s" % str(err))
        time.sleep(0.1)  # sleep 100 ms
    raise RuntimeError("FRR daemons hasn't been started in %d seconds" % seconds)


def read_constants():
    """ Read file with constants values from /etc/sonic/constants.yml """
    with open('/etc/sonic/constants.yml') as fp:
        content = yaml.load(fp) # FIXME: , Loader=yaml.FullLoader)
        if "constants" not in content:
            log_crit("/etc/sonic/constants.yml doesn't have 'constants' key")
            raise Exception("/etc/sonic/constants.yml doesn't have 'constants' key")
        return content["constants"]


def main():
    """ Main function """
    wait_for_daemons(["bgpd", "zebra", "staticd"], seconds=20)
    #
    common_objs = {
        'directory': Directory(),
        'cfg_mgr':   ConfigMgr(),
        'tf':        TemplateFabric(),
        'constants': read_constants(),
    }
    managers = [
        # Config DB managers
        BGPDataBaseMgr(common_objs, "CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME),
        BGPDataBaseMgr(common_objs, "CONFIG_DB", swsscommon.CFG_DEVICE_NEIGHBOR_METADATA_TABLE_NAME),
        # Interface managers
        InterfaceMgr(common_objs, "CONFIG_DB", swsscommon.CFG_INTF_TABLE_NAME),
        InterfaceMgr(common_objs, "CONFIG_DB", swsscommon.CFG_LOOPBACK_INTERFACE_TABLE_NAME),
        InterfaceMgr(common_objs, "CONFIG_DB", swsscommon.CFG_VLAN_INTF_TABLE_NAME),
        InterfaceMgr(common_objs, "CONFIG_DB", swsscommon.CFG_LAG_INTF_TABLE_NAME),
        # State DB managers
        ZebraSetSrc(common_objs, "STATE_DB", swsscommon.STATE_INTERFACE_TABLE_NAME),
        # Peer Managers
        BGPPeerMgrBase(common_objs, "CONFIG_DB", swsscommon.CFG_BGP_NEIGHBOR_TABLE_NAME, "general", True),
        BGPPeerMgrBase(common_objs, "CONFIG_DB", "BGP_MONITORS", "monitors", True),
        BGPPeerMgrBase(common_objs, "CONFIG_DB", "BGP_PEER_RANGE", "dynamic", False),
        # AllowList Managers
        BGPAllowListMgr(common_objs, "CONFIG_DB", "BGP_ALLOWED_PREFIXES"),
    ]
    runner = Runner()
    for mgr in managers:
        runner.add_manager(mgr)
    runner.run()


def signal_handler(_, __):  # signal_handler(signum, frame)
    """ signal handler """
    global g_run
    g_run = False


if __name__ == '__main__':
    rc = 0
    try:
        syslog.openlog('bgpcfgd')
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)
        main()
    except KeyboardInterrupt:
        log_notice("Keyboard interrupt")
    except RuntimeError as exc:
        log_crit(str(exc))
        rc = -2
        if g_debug:
            raise
    except Exception as exc:
        log_crit("Got an exception %s: Traceback: %s" % (str(exc), traceback.format_exc()))
        rc = -1
        if g_debug:
            raise
    finally:
        syslog.closelog()
    try:
        sys.exit(rc)
    except SystemExit:
        os._exit(rc)
