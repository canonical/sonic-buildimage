#!/usr/bin/python3 -u

import argparse
import docker
import inspect
import json
import os
import sys
import syslog
import time

from swsscommon import swsscommon

sys.path.append('/usr/share/sonic/scripts/')
import container_state

state_db = None

# DB field names
FEATURE_TABLE = "FEATURE"
SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "container_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
SYSTEM_STATE = "system_state"

KUBE_LABEL_TABLE = "KUBE_LABELS"
KUBE_LABEL_SET_KEY = "SET"
KUBE_LABEL_UNSET_KEY = "UNSET"

# Get seconds to wait for remote docker to start.
# If not, revert to local
#
SONIC_CTR_CONFIG = "/etc/sonic/remote_ctr.config.json"
SONIC_CTR_CONFIG_PEND_SECS = "revert_to_local_on_wait_seconds"
DEFAULT_PEND_SECS = ( 5 * 60 )
WAIT_POLL_SECS = 2

def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)


def init():
    """ Get DB connections """
    global state_db, cfg_db

    cfg_db = swsscommon.DBConnector("CONFIG_DB", 0)
    state_db = swsscommon.DBConnector("STATE_DB", 0)


def get_config_data(fld, dflt):
    """ Read entry from kube config file """
    if os.path.exists(SONIC_CTR_CONFIG):
         with open(SONIC_CTR_CONFIG, "r") as s:
            d = json.load(s)
            if fld in d:
                return d[fld]
    return dflt


def read_data(is_config, feature, fields):
    """ Read data from DB for desired fields using given defaults"""
    ret = []

    db = cfg_db if is_config else state_db

    tbl = swsscommon.Table(db, FEATURE_TABLE)

    data = dict(tbl.get(feature)[1])
    for (field, default) in fields:
        val = data.get(field, default)
        ret += [val]

    debug_msg("config:{} feature:{} fields:{} val:{}".format(
        is_config, feature, str(fields), str(ret)))

    return tuple(ret)


def read_config(feature):
    """ Read requried feature config """
    set_owner, no_fallback  = read_data(True, feature, 
            [(SET_OWNER, "local"), (NO_FALLBACK, False)])

    return (set_owner, not no_fallback)


def read_state(feature):
    """ Read requried feature state """

    return read_data(False, feature,
            [(CURRENT_OWNER, "none"), (REMOTE_STATE, "none"), (DOCKER_ID, "")])


def docker_action(action, feature):
    """ Execute docker action """
    try:
        client = docker.from_env()
        container = client.containers.get(feature)
        getattr(container, action)()
        debug_msg("docker cmd: {} for {}".format(action, feature))
        return 0

    except (docker.errors.NotFound, docker.errors.APIError) as err:
        syslog.syslog(syslog.LOG_ERR, "docker cmd: {} for {} failed with {}".
                format(action, feature, str(err)))
        return -1


def set_label(feature, create):
    """ Set/drop label as required
        Update is done in state-db.
        ctrmgrd sets it with kube API server as required
    """
    tbl = swsscommon.Table(state_db, KUBE_LABEL_TABLE)
    fld = "{}_enabled".format(feature)

    # redundant set (data already exist) can still raise subscriber
    # notification. So check & set.
    # Redundant delete (data doesn't exist) does not raise any 
    # subscriber notification. So no need to pre-check for delete.
    #
    if create:
        tbl.set(KUBE_LABEL_SET_KEY, [(fld, "true")])
        tbl.hdel(KUBE_LABEL_UNSET_KEY, fld)
    else:
        tbl.set(KUBE_LABEL_UNSET_KEY, [(fld, "")])
        tbl.hdel(KUBE_LABEL_SET_KEY, fld)
        

def update_data(feature, data):
    debug_msg("feature:{} data:{}".format(feature, str(data)))
    tbl = swsscommon.Table(state_db, FEATURE_TABLE)
    tbl.set(feature, list(data.items()))


def container_id(feature):
    """
    Return the container ID for the feature.
    
    For features that support remote container management, get it
    from FEATURE table in STATE-DB.
    For the rest, return feature name as container id.

    :param feature: Name of the feature to start.
    
    """
    tbl = swsscommon.Table(state_db, "FEATURE")
    data = dict(tbl.get(feature)[1])

    # Features that support remote container mgmt has docker-id field
    # mandatorily in FEATURE table, irrespective of being run local
    # or remote. So return what is there in DB, if this field is
    # present, else return the feature name, as those are not
    # manageable as remote.
    #
    return data[DOCKER_ID] if DOCKER_ID in data else feature


def container_start(feature):
    """
    Starts a container for given feature.
    
    Starts from local image and/or trigger kubernetes to deploy the image
    for this feature. Marks the feature state up in STATE-DB FEATURE table.

    If feature's set_owner is local, invoke docker start.
    If feature's set_owner is kube, it creates a node label that
    would trigger kubernetes to start the container. With kube as 
    owner, if fallback is enabled and remote_state==none, it starts
    the local image using docker, which will run until kube
    deployment occurs.

    :param feature: Name of the feature to start.
    
    """
    ret = 0
    debug_msg("BEGIN")
    set_owner, fallback = read_config(feature)
    _, remote_state, _ = read_state(feature)

    debug_msg("{}: set_owner:{} fallback:{} remote_state:{}".format(
        feature, set_owner, fallback, remote_state))

    update_data(feature, {SYSTEM_STATE: "up"})

    if set_owner == "local":
        # Ensure label is not there.
        set_label(feature, False)
        if remote_state.lower() != "none":
            update_data(feature, {REMOTE_STATE: "none"})
        ret = docker_action("start", feature)

    else:
        if fallback and (remote_state == "none"):
            # Start local as fallback enabled & no transition occuring.
            ret = docker_action("start", feature)
        set_label(feature, True)

    debug_msg("END")
    return ret


def container_stop(feature):
    """
    Stops the running container for this feature.

    Instruct/ensure kube terminates, by removing label, unless
    an kube upgrade is happening.

    Gets the container ID for this feature and call docker stop.

    Marks the feature state down in STATE-DB FEATURE table.

    :param feature: Name of the feature to stop.
    
    """
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, _ = read_state(feature)
    docker_id = container_id(feature)
    remove_label = (remote_state != "pending") or (set_owner == "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("stop", docker_id)

    debug_msg("END")


def container_kill(feature):
    """
    Kills the running container for this feature.

    Instruct/ensure kube terminates, by removing label.

    Gets the container ID for this feature and call docker kill.

    Marks the feature state down in STATE-DB FEATURE table.

    :param feature: Name of the feature to kill.
    
    """
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, _ = read_state(feature)
    docker_id = container_id(feature)
    remove_label = (set_owner != "local") or (current_owner != "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("kill", docker_id)

    # As container gettting killed, it may not have chance to update
    # state-db. So call here.
    #
    container_state.down(feature)

    debug_msg("END")


def container_wait(feature):
    """
    Waits on the running container for this feature.

    Get the container-id and call docker wait.

    If docker-id can't be obtained for a configurable fail-duration
    the wait clears the feature's remote-state in STATE-DB FEATURE
    table and exit.

    :param feature: Name of the feature to wait.
    
    """
    debug_msg("BEGIN")

    set_owner, fallback = read_config(feature)
    current_owner, remote_state, _ = read_state(feature)
    docker_id = container_id(feature)
    pend_wait_secs = 0

    if not docker_id and fallback:
        pend_wait_secs = get_config_data(
                SONIC_CTR_CONFIG_PEND_SECS, DEFAULT_PEND_SECS)

    debug_msg("{}: set_owner:{} ct_owner:{} state:{} id:{} pend={}".format(
        feature, set_owner, current_owner, remote_state, docker_id,
        pend_wait_secs))

    while not docker_id:
        if fallback:
            pend_wait_secs = pend_wait_secs - WAIT_POLL_SECS
            if pend_wait_secs < 0:
                break

        time.sleep(WAIT_POLL_SECS)

        current_owner, remote_state, docker_id = read_state(feature)

        debug_msg("wait_loop: {} = {} {} {}".format(feature, current_owner, remote_state, docker_id))

        if (remote_state == "pending"):
            update_data(feature, {REMOTE_STATE: "ready"})

    if not docker_id:
        # Clear remote state and exit.
        # systemd would restart and fallback to local
        update_data(feature, { REMOTE_STATE: "none" })
        debug_msg("{}: Exiting to fallback as remote is *not* starting".
                format(feature))
    else:
        debug_msg("END -- transitioning to docker wait")
        docker_action("wait", docker_id)


def main():
    parser=argparse.ArgumentParser(description="container commands for start/stop/wait/kill/id")
    parser.add_argument("action", choices=["start", "stop", "wait", "kill", "id"])
    parser.add_argument("name")

    args = parser.parse_args()

    init()

    if args.action == "start":
        container_start(args.name)

    elif args.action == "stop":
        container_stop(args.name)

    elif args.action == "kill":
        container_kill(args.name)

    elif args.action == "wait":
        container_wait(args.name)

    elif args.action == "id":
        id = container_id(args.name)
        print(id)

    else:
        print("Unknown action {} for name {}".format(action, name))


if __name__ == "__main__":
    main()

