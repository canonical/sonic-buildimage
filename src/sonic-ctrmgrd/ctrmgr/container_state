#!/usr/bin/python -u

import sys
import syslog
import inspect
import datetime
import time
import argparse
import subprocess
# from swsscommon import swsscommon
from swsssdk import ConfigDBConnector

# DB field names
SET_OWNER = "set_owner"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "container_id"
REMOTE_STATE = "remote_state"
VERSION = "container_version"
SYSTEM_STATE = "system_state"

KUBE_LABEL_TABLE = "KUBE_LABELS"
KUBE_LABEL_SET_KEY = "SET"
KUBE_LABEL_UNSET_KEY = "UNSET"

state_db = None
set_owner = "local"
state_data = {
        CURRENT_OWNER: "none",
        UPD_TIMESTAMP: "",
        DOCKER_ID: "",
        REMOTE_STATE: "none",
        VERSION: "0.0.0",
        SYSTEM_STATE: ""
        }


def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)


def _get_version_key(feature, version):
    return "{}_{}_enabled".format(feature, version)


"""
Commented until swsscommon is available
def read_data(feature):
    global state_db, set_owner, state_data

    db = swsscommon.DBConnector("CONFIG_DB", 0)
    tbl = swsscommon.Table(db, 'FEATURE')
    data = dict(tbl.get(feature)[1])

    if (SET_OWNER in data):
        set_owner = data[SET_OWNER]

    state_db = swsscommon.DBConnector("STATE_DB", 0)
    tbl = swsscommon.Table(state_db, 'FEATURE')
    state_data.update(dict(tbl.get(feature)[1]))


def read_field(feature, field, default):
    tbl = swsscommon.Table(state_db, 'FEATURE')
    data = dict(tbl.get(feature)[1])
    return data[field] if field in data else default


def check_unset_labels(feature, version):
     check if this feature is in unset list or not 
    tbl = swsscommon.Table(state_db, KUBE_LABEL_TABLE)
    labels = dict(tbl.get(KUBE_LABEL_UNSET_KEY)[1])
    return _get_version_key(feature, version) in labels


def drop_label(feature, version):
    Set/drop label as required
        Update is done in state-db.
        ctrmgrd sets it with kube API server as required
    
    tbl = swsscommon.Table(state_db, KUBE_LABEL_TABLE)
    name = _get_version_key(feature, version)
    tbl.set(KUBE_LABEL_UNSET_KEY, [ (name, "")])
    tbl.hdel(KUBE_LABEL_SET_KEY, name)
        

def update_data(feature, data):
    debug_msg("{}: {{ {}: {} }}".format(feature, field, val))
    tbl = swsscommon.Table(state_db, "FEATURE")
    tbl.set(feature, list(data.items()))
"""

def read_data(feature):
    global state_db, set_owner, state_data

    db = ConfigDBConnector()
    db.connect(wait_for_init=True, retry_on=True)
    tbl = db.get_table('FEATURE')

    if ((feature in tbl) and (SET_OWNER in tbl[feature])):
        set_owner = tbl[feature][SET_OWNER]

    state_db = ConfigDBConnector()
    state_db.db_connect("STATE_DB", wait_for_init=False, retry_on=True)
    tbl = state_db.get_table('FEATURE')
    if feature in tbl:
        state_data.update(tbl[feature])


def read_field(feature, field, default):
    tbl = state_db.get_table('FEATURE')
    if (feature in tbl) and (field in tbl[feature]):
        return tbl[feature][field]
    else:
        return default

def check_unset_labels(feature, version):
    tbl = state_db.get_table(KUBE_LABEL_TABLE)
    if KUBE_LABEL_UNSET_KEY in tbl:
        labels = tbl[KUBE_LABEL_UNSET_KEY]
    else:
        labels = {}
    return _get_version_key(feature, version) in labels


def drop_label(feature, version):
    """ Set/drop label as required
        Update is done in state-db.
        ctrmgrd sets it with kube API server as required
    """
    name = _get_version_key(feature, version)
    state_db.mod_entry(KUBE_LABEL_TABLE, KUBE_LABEL_UNSET_KEY, { name: "" })


def update_data(feature, data):
    debug_msg("{}: {}".format(feature, str(data)))
    state_db.mod_entry("FEATURE", feature, data) 

    
def get_docker_id():
    cmd = 'cat /proc/self/cgroup | grep -e ":memory:" | rev | cut -f1 -d\'/\' | rev'
    proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE)
    output = proc.communicate()[0].decode("utf-8")
    return output.strip()[:12]


def instance_lower(feature, version):
    if state_data[CURRENT_OWNER] == "none":
        # No one running to compare version
        return

    ct_version = state_data[VERSION]
    ct = ct_version.split('.')
    nxt = version.split('.') if version else "0.0.0".split('.')
    ret = False
    for i in range(3):
        if nxt[i] < ct[i]:
            ret = True
            break
        elif nxt[i] > ct[i]:
            break

    debug_msg("compare version: new:{} current:{} res={}".format(
        version, ct_version, ret))
    return ret


def is_active(feature):
    if state_data[SYSTEM_STATE] == "up":
        return True
    else:
        syslog.syslog(syslog.LOG_ERR, "Found inactive for {}".format(feature))
        return False


def update_state(args, is_up):
    data = {
            CURRENT_OWNER: args.owner if is_up else "none",
            DOCKER_ID: get_docker_id() if is_up else "",
            UPD_TIMESTAMP: str(datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            }
    if is_up:
        data[VERSION] = args.version

        if (args.owner == "local"):
            # Disable deployment of this version as available locally
            drop_label(args.feature, args.version)
        else:
            data[REMOTE_STATE] = "running"

    elif state_data[CURRENT_OWNER] != "local":
        state = state_data[REMOTE_STATE]
        if state != "pending":
            if state != "running":
                syslog.syslog(syslog.LOG_ERR,
                        "{} kube down state: {} != running", args.feature, state)
            else:
                data[REMOTE_STATE] = "stopped"

    debug_msg("{} up= {} data:{}".format(args.feature, is_up, str(data)))
    update_data(args.feature,  data)
    state_data.update(data)


def do_exit(feat, m):
    syslog.syslog(syslog.LOG_ERR, "Exiting .... feat:{} docker_id:{} msg:{}".format(
        feat, get_docker_id(), m))
    sys.exit(-1)

def container_up(args):
    debug_msg("BEGIN")
    read_data(args.feature)

    debug_msg("args={} set_owner={} state_data={}".format(
        args, set_owner, state_data))

    if args.owner == "local":
        update_state(args, True)
    else:
        if (set_owner == "local"):
            do_exit(args.feature, "bail out as set_owner is local")

        if not is_active(args.feature):
            do_exit(args.feature, "bail out as system state not active")

        if check_unset_labels(args.feature, args.version):
            do_exit("This version is marked disabled. Exiting ...")

        if instance_lower(args.feature, args.version):
            # Remove label <feature_name>_<version>_enabled
            # Else kubelet will continue to re-deploy every 5 mins, until
            # master removes the lable to un-deploy.
            #
            drop_label(args.feature, args.version)
            do_exit(args.feature, "bail out as current deploy id is lower")

        update_data(args.feature, { VERSION: args.version })

        mode = state_data[REMOTE_STATE]
        if mode in ("none", "running", "stopped"):
            update_data(args.feature, { REMOTE_STATE: "pending" })
            mode = "pending"
        else:
            debug_msg("{}: Skip remote_state({}) update".format(args.feature, mode))

        
        i = 0
        while (mode != "ready"):
            if i == 0:
                debug_msg("{}: remote_state={}. Waiting to go ready".format(args.feature, mode))
                i = 1
            elif i == 9:
                i = 0
            else:
                i += 1

            time.sleep(2)
            mode = read_field(args.feature, REMOTE_STATE, "none")

        update_state(args, True)

    debug_msg("END")


def container_down(args):
    debug_msg("BEGIN")
    read_data(args.feature)

    debug_msg("args={} set_owner={} state_data={}".format(
        args, set_owner, state_data))

    ct_docker_id = state_data[DOCKER_ID]
    caller_docker_id = get_docker_id()
    if caller_docker_id != ct_docker_id:
        syslog.syslog(syslog.LOG_ERR, "{} down mismatch docker-id. caller_docker_id={} current:{}".
                format(args.feature, caller_docker_id, ct_docker_id))
    else:
        update_state(args, False)
    debug_msg("END")



# e.g. container_state <feature> up/down local/kube <docker id>
def main():
    parser = argparse.ArgumentParser(description="state up/down <feature> kube/local [<docker id> <instance id>]")
    subparsers = parser.add_subparsers(title='actions')

    parser_up = subparsers.add_parser('up')
    parser_up.add_argument("-f", "--feature", required=True)
    parser_up.add_argument("-o", "--owner", choices=["local", "kube"], required=True)
    parser_up.add_argument("-v", "--version", default="")
    parser_up.set_defaults(func=container_up)
    
    parser_down = subparsers.add_parser('down')
    parser_down.add_argument("-f", "--feature", required=True)
    parser_down.set_defaults(func=container_down)

    args = parser.parse_args()
    args.func(args)


if __name__ == "__main__":
    main()

