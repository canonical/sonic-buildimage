#!/usr/bin/python3 -u

import syslog
import subprocess
import argparse
import inspect
import time
import os
import json
from swsscommon import swsscommon

remote_features = ("snmp", "telemetry", "pmon", "lldp", "radv", "dhcp_relay")

state_db = None

# DB field names
FEATURE_TABLE = "FEATURE"
SET_OWNER = "set_owner"
NO_FALLBACK = "no_fallback_to_local"

CURRENT_OWNER = "current_owner"
UPD_TIMESTAMP = "update_time"
DOCKER_ID = "container_id"
REMOTE_STATE = "remote_state"
VERSION = "version"
SYSTEM_STATE = "system_state"

KUBE_LABEL_TABLE = "KUBE_LABELS"
KUBE_LABEL_SET_KEY = "SET"
KUBE_LABEL_UNSET_KEY = "UNSET"

# Get seconds to wait for remote docker to start.
# If not, revert to local
#
SONIC_KUBE_CONFIG = "/etc/sonic/kube.config.json"
SONIC_KUBE_CONFIG_PEND_SECS = "Revert_to_local_on_wait_seconds"
DEFAULT_PEND_SECS = ( 5 * 60 )
WAIT_POLL_SECS = 2

def debug_msg(m):
    msg = "{}: {}".format(inspect.stack()[1][3], m)
    # print(msg)
    syslog.syslog(syslog.LOG_DEBUG, msg)


def init():
    """ Get DB connections """
    global state_db, cfg_db

    cfg_db = swsscommon.DBConnector("CONFIG_DB", 0)
    state_db = swsscommon.DBConnector("STATE_DB", 0)


def get_config_data(fld, dflt):
    """ Read entry from kube config file """
    if os.path.exists(SONIC_KUBE_CONFIG):
         with open(SONIC_KUBE_CONFIG, "r") as s:
            d = json.load(s)
            if fld in d:
                return d[fld]
    return dflt


def read_data(is_config, feature, fields, defaults):
    """ Read data from DB for desired fields using given defaults"""
    ret = []

    db = cfg_db if is_config else state_db

    tbl = swsscommon.Table(db, FEATURE_TABLE)

    data = dict(tbl.get(feature)[1])
    i = 0
    for field in fields:
        val = data.get(field, defaults[i])
        i += 1
        ret += [val]

    debug_msg("config:{} feature:{} fields:{} val:{}".format(
        is_config, feature, str(fields), str(ret)))

    return tuple(ret)


def read_config(feature):
    """ Read requried feature config """
    set_owner, no_fallback  = read_data(True, feature, 
            (SET_OWNER, NO_FALLBACK), ("local", False))

    return (set_owner, not no_fallback)


def read_state(feature):
    """ Read requried feature state """

    return read_data(False, feature,
            (CURRENT_OWNER, REMOTE_STATE, DOCKER_ID), ("none", "none", ""))


def docker_action(action, feature):
    """ Execute docker action """
    cmd = "docker {} {}".format(action, feature)
    proc = subprocess.Popen(cmd, shell=True)
    proc.wait()
    debug_msg("docker cmd: {}".format(cmd))
    return proc.returncode


def set_label(feature, create):
    """ Set/drop label as required
        Update is done in state-db.
        ctrmgrd sets it with kube API server as required
    """
    tbl = swsscommon.Table(state_db, KUBE_LABEL_TABLE)
    fld = "{}_enabled".format(feature)
    if create:
        tbl.set(KUBE_LABEL_SET_KEY, [ (fld, "true")])
        tbl.hdel(KUBE_LABEL_UNSET_KEY, fld)
    else:
        tbl.set(KUBE_LABEL_UNSET_KEY, [ (fld, "")])
        tbl.hdel(KUBE_LABEL_SET_KEY, fld)
        

def update_data(feature, data):
    debug_msg("feature:{} data:{}".format(feature, str(data)))
    tbl = swsscommon.Table(state_db, FEATURE_TABLE)
    tbl.set(feature, list(data.items()))


def container_start(feature):
    ret = 0
    debug_msg("BEGIN")
    set_owner, fallback = read_config(feature)
    _, remote_state, _ = read_state(feature)

    debug_msg("{}: set_owner:{} fallback:{} remote_state:{}".format(
        feature, set_owner, fallback, remote_state))

    update_data(feature, {SYSTEM_STATE: "up"})

    if set_owner == "local":
        # Ensure label is not there.
        set_label(feature, False)
        if remote_state.lower() != "none":
            update_data(feature, {REMOTE_STATE: "none"})
        ret = docker_action("start", feature)

    else:
        if fallback and (remote_state == "none"):
            # Start local as fallback enabled & no transition occuring.
            ret = docker_action("start", feature)
        set_label(feature, True)

    debug_msg("END")
    return ret


def container_stop(feature):
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (remote_state != "pending") or (set_owner == "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if not docker_id:
        docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("stop", docker_id)

    current_owner, remote_state, docker_id = read_state(feature)
    if ((current_owner != "none") or docker_id):
        # container did not clear data upon termination; Possibly killed
        # This could also happen when kubelet forcefully terminate
        # Forceful termination is possible when master connection is reset.
        #
        debug_msg("Force resetting feature:{} status to none".format(feature))
        update_data(feature, {
            CURRENT_OWNER: "none",
            REMOTE_STATE: "none",
            DOCKER_ID: ""})

    debug_msg("END")


def container_kill(feature):
    debug_msg("BEGIN")
    set_owner, _ = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    remove_label = (set_owner != "local") or (current_owner != "local")

    debug_msg("{}: set_owner:{} current_owner:{} remote_state:{} docker_id:{}".format(
        feature, set_owner, current_owner, remote_state, docker_id))

    update_data(feature, {SYSTEM_STATE: "down"})

    if not docker_id:
        docker_id = feature

    if remove_label:
        set_label(feature, False)

    if docker_id:
        docker_action("kill", docker_id)

    proc = subprocess.Popen("container_state.py down -f {}".format(feature))
    proc.wait()

    debug_msg("END")


def container_wait(feature):
    debug_msg("BEGIN")

    set_owner, fallback = read_config(feature)
    current_owner, remote_state, docker_id = read_state(feature)
    pend_wait_secs = 0

    if not docker_id:
        if (set_owner == "local") or (current_owner == "local"):
            docker_id = feature
        elif fallback:
            pend_wait_secs = get_config_data(
                    SONIC_KUBE_CONFIG_PEND_SECS, DEFAULT_PEND_SECS)

    debug_msg("{}: set_owner:{} ct_owner:{} state:{} id:{} pend={}".format(
        feature, set_owner, current_owner, remote_state, docker_id,
        pend_wait_secs))

    while not docker_id:
        if fallback:
            pend_wait_secs = pend_wait_secs - WAIT_POLL_SECS
            if pend_wait_secs < 0:
                break

        time.sleep(WAIT_POLL_SECS)

        current_owner, remote_state, docker_id = read_state(feature)

        debug_msg("wait_loop: {} = {} {} {}".format(feature, current_owner, remote_state, docker_id))

        if (remote_state == "pending"):
            update_data(feature, {REMOTE_STATE: "ready"})

    if not docker_id:
        # Clear remote state and exit.
        # systemd would restart and fallback to local
        update_data(feature, { REMOTE_STATE: "none" })
        debug_msg("{}: Exiting to fallback as remote is *not* starting".
                format(feature))
    else:
        debug_msg("END -- transitioning to docker wait")
        docker_action("wait", docker_id)


def container_id(feature):
    current_owner, _, docker_id = read_state(feature)
    if ((not docker_id) and (
            (set_owner == "local") or (current_owner == "local"))):
        docker_id = feature
    print(docker_id)


def main():
    parser=argparse.ArgumentParser(description="container commands for start/stop/wait/kill/id")
    parser.add_argument("action", choices=["start", "stop", "wait", "kill", "id"])
    parser.add_argument("name")

    args = parser.parse_args()

    init()

    if args.name not in remote_features:
        docker_action(args.action, args.name)

    elif args.action == "start":
        container_start(args.name)

    elif args.action == "stop":
        container_stop(args.name)

    elif args.action == "kill":
        container_kill(args.name)

    elif args.action == "wait":
        container_wait(args.name)

    elif args.action == "id":
        container_id(args.name)

    else:
        print("Unknown action {} for name {}".format(action, name))


if __name__ == "__main__":
    main()

