From 4378beb41efa256eb2b492c0046ad071dbf17076 Mon Sep 17 00:00:00 2001
From: Tianrong Zhang <trzhang@microsoft.com>
Date: Wed, 25 Nov 2020 15:40:54 -0800
Subject: [PATCH] Support-for-dual-tor-scenario

---
 relay/Makefile.am |   1 +
 relay/dhcrelay.c  | 248 ++++++++++++++++++++++++++++++++++++++++------
 2 files changed, 217 insertions(+), 32 deletions(-)

diff --git a/relay/Makefile.am b/relay/Makefile.am
index 2ba5979..bb1c21d 100644
--- a/relay/Makefile.am
+++ b/relay/Makefile.am
@@ -1,4 +1,5 @@
 AM_CPPFLAGS = -DLOCALSTATEDIR='"@localstatedir@"'
+AM_LDFLAGS = -pthread
 
 sbin_PROGRAMS = dhcrelay
 dhcrelay_SOURCES = dhcrelay.c
diff --git a/relay/dhcrelay.c b/relay/dhcrelay.c
index e158efe..f410a86 100644
--- a/relay/dhcrelay.c
+++ b/relay/dhcrelay.c
@@ -32,6 +32,7 @@
 #include <sys/time.h>
 #include <sys/ioctl.h>
 #include <isc/file.h>
+#include <pthread.h>
 
 TIME default_lease_time = 43200; /* 12 hours... */
 TIME max_lease_time = 86400; /* 24 hours... */
@@ -56,6 +57,7 @@ int bogus_agent_drops = 0;	/* Packets dropped because agent option
 				   specified. */
 int bogus_giaddr_drops = 0;	/* Packets sent to us to relay back to a
 				   client, but with a bogus giaddr. */
+int bogus_yiaddr_drops = 0;
 int client_packets_relayed = 0;	/* Packets relayed from client to server. */
 int server_packet_errors = 0;	/* Errors sending packets to servers. */
 int server_packets_relayed = 0;	/* Packets relayed from server to client. */
@@ -83,6 +85,16 @@ int max_hop_count = 10;		/* Maximum hop count */
 int no_daemon = 0;
 int dfd[2] = { -1, -1 };
 
+int enable_support_for_dual_tor = 0;
+struct in_addr loopback_addr;
+int enable_receive_pkt_from_loopback = 0;
+int sockfd_loopback;
+
+struct downstream_intf_list {
+	struct downstream_intf_list *next;
+	struct interface_info *interface;
+} *downstream_intfs = NULL;
+
 #ifdef DHCPv6
 	/* Force use of DHCPv6 interface-id option. */
 isc_boolean_t use_if_id = ISC_FALSE;
@@ -156,6 +168,9 @@ static int load_interface_alias_map(const char *port_alias_map_file_path);
 static int get_interface_alias_by_name(const char *if_name, char *if_alias_out);
 static void free_interface_alias_map(void);
 
+static void *receive_pkt_from_loopback(void *);
+static void free_downstream_intfs(void);
+
 static const char copyright[] =
 "Copyright 2004-2018 Internet Systems Consortium.";
 static const char arr[] = "All rights reserved.";
@@ -189,6 +204,7 @@ char *progname;
 "                     [-iu interface0 [ ... -iu interfaceN]\n" \
 "                     [-id interface0 [ ... -id interfaceN]\n" \
 "                     [-U interface]\n" \
+"                     [-dt <loopback_addr>]\n"\
 "                     server0 [ ... serverN]\n\n" \
 "       %s -6   [-d] [-q] [-I] [-c <hops>]\n" \
 "                     [-p <port> | -rp <relay-port>]\n" \
@@ -210,6 +226,7 @@ char *progname;
 "                     [-iu interface0 [ ... -iu interfaceN]\n" \
 "                     [-id interface0 [ ... -id interfaceN]\n" \
 "                     [-U interface]\n" \
+"                     [-dt <loopback_addr>]\n"\
 "                     server0 [ ... serverN]\n\n" \
 "       %s -6   [-d] [-q] [-I] [-c <hops>] [-p <port>]\n" \
 "                     [-pf <pid-file>] [--no-pid]\n" \
@@ -231,6 +248,7 @@ char *progname;
 "                [-iu interface0 [ ... -iu interfaceN]\n" \
 "                [-id interface0 [ ... -id interfaceN]\n" \
 "                [-U interface]\n" \
+"                [-dt <loopback_addr>]\n"\
 "                server0 [ ... serverN]\n\n" DHCRELAY_OPTION82_USAGE \
 "       %s {--version|--help|-h}"
 #else
@@ -242,6 +260,7 @@ char *progname;
 "                [-iu interface0 [ ... -iu interfaceN]\n" \
 "                [-id interface0 [ ... -id interfaceN]\n" \
 "                [-U interface]\n" \
+"                [-dt <loopback_addr>]\n"\
 "                server0 [ ... serverN]\n\n" DHCRELAY_OPTION82_USAGE \
 "       %s {--version|--help|-h}"
 #endif
@@ -306,6 +325,7 @@ main(int argc, char **argv) {
 	int quiet = 0;
 	int fd;
 	int i;
+	pthread_t thread_id;
 #ifdef RELAY_PORT
 	int port_defined = 0;
 #endif
@@ -639,7 +659,28 @@ main(int argc, char **argv) {
 				usage(use_noarg, argv[i-1]);
 			if (load_interface_alias_map(argv[i]) != 0)
 				log_fatal("Failed to load interface name-alias map.");
- 		} else if (argv[i][0] == '-') {
+		} else if (!strcmp(argv[i], "-dt")) {
+#ifdef DHCPv6
+			if (local_family_set && (local_family == AF_INET6)) {
+				usage(use_v4command, argv[i]);
+			}
+			local_family_set = 1;
+			local_family = AF_INET;
+#endif
+			if (++i == argc)
+				usage(use_noarg, argv[i-1]);
+
+			add_agent_options = 1;
+			add_rfc3527_suboption = 1;
+
+			if (!inet_aton(argv[i], &loopback_addr)) {
+				log_error("%s: invalid ipv4 loopback addr", argv[i]);
+				usage(use_v4command, argv[i-1]);
+			}
+
+			enable_support_for_dual_tor = 1;
+			enable_receive_pkt_from_loopback = 1;
+		} else if (argv[i][0] == '-') {
 			usage("Unknown command: %s", argv[i]);
  		} else {
 			struct hostent *he;
@@ -747,7 +788,6 @@ main(int argc, char **argv) {
 			log_fatal("No servers specified.");
 		}
 
-
 		/* Set up the server sockaddrs. */
 		for (sp = servers; sp; sp = sp->next) {
 			sp->to.sin_port = local_port;
@@ -857,11 +897,25 @@ main(int argc, char **argv) {
 	signal(SIGTERM, dhcp_signal_handler);  /* kill */
 #endif
 
+	/* start the thread of receiving packets destined to loopback */
+	if (enable_support_for_dual_tor) {
+		if (pthread_create(&thread_id, NULL, &receive_pkt_from_loopback, NULL))
+			log_fatal("Failed to create a thread to receive packets destined to loopback");
+	}
+
 	/* Start dispatching packets and timeouts... */
 	dispatch();
 
+	if (enable_support_for_dual_tor) {
+		enable_receive_pkt_from_loopback = 0;
+		write(sockfd_loopback, "stop", 4);
+		pthread_join(thread_id, NULL);
+	}
+
 	/* In fact dispatch() never returns. */
 	free_interface_alias_map();
+	free_downstream_intfs();
+
 	return (0);
 }
 
@@ -885,25 +939,50 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 		return;
 	}
 
-	/* Find the interface that corresponds to the giaddr
-	   in the packet. */
-	if (packet->giaddr.s_addr) {
-		for (out = interfaces; out; out = out->next) {
-			int i;
+	if (enable_support_for_dual_tor) {
+		if (packet->yiaddr.s_addr) {
+			out = NULL;
 
-			for (i = 0 ; i < out->address_count ; i++ ) {
-				if (out->addresses[i].s_addr ==
-				    packet->giaddr.s_addr) {
-					i = -1;
+			for (struct downstream_intf_list *cdi = downstream_intfs; cdi; cdi = cdi->next) {
+				int i = 0;
+				out = cdi->interface;
+
+				for (i = 0 ; i < out->address_count ; i++ ) {
+					if ((out->addresses[i].s_addr & out->netmasks[i].s_addr) == (packet->yiaddr.s_addr & out->netmasks[i].s_addr)) {
+						i = -1;
+						break;
+					}
+				}
+
+				if (i == -1) {
 					break;
+				} else {
+					out = NULL;
 				}
 			}
-
-			if (i == -1)
-				break;
+		} else {
+			out = NULL;
 		}
 	} else {
-		out = NULL;
+		/* Find the interface that corresponds to the giaddr in the packet. */
+		if (packet->giaddr.s_addr) {
+			for (out = interfaces; out; out = out->next) {
+				int i;
+
+				for (i = 0 ; i < out->address_count ; i++ ) {
+					if (out->addresses[i].s_addr ==
+						packet->giaddr.s_addr) {
+						i = -1;
+						break;
+					}
+				}
+
+				if (i == -1)
+					break;
+			}
+		} else {
+			out = NULL;
+		}
 	}
 
 	/* If it's a bootreply, forward it to the client. */
@@ -913,6 +992,10 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 			return;
 		}
 
+		/* This bootreply does not belong to the current vlan. */
+		if (enable_support_for_dual_tor && !out)
+			return;
+
 		if (!(packet->flags & htons(BOOTP_BROADCAST)) &&
 			can_unicast_without_arp(out)) {
 			to.sin_addr = packet->yiaddr;
@@ -945,9 +1028,13 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 			return;
 
 		if (!out) {
-			log_error("Packet to bogus giaddr %s.\n",
-			      inet_ntoa(packet->giaddr));
-			++bogus_giaddr_drops;
+			if (!enable_support_for_dual_tor) {
+				log_error("Packet to bogus giaddr %s.\n", inet_ntoa(packet->giaddr));
+				++bogus_giaddr_drops;
+			} else {
+				log_error("Packet to bogus yiaddr %s.\n", inet_ntoa(packet->yiaddr));
+				++bogus_yiaddr_drops;
+			}
 			return;
 		}
 
@@ -987,8 +1074,14 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 	   forward the response to the correct net.    If it's already
 	   set, the response will be sent directly to the relay agent
 	   that set giaddr, so we won't see it. */
-	if (!packet->giaddr.s_addr)
-		packet->giaddr = ip->addresses[0];
+	if (!packet->giaddr.s_addr) {
+		if (enable_support_for_dual_tor) {
+			packet->giaddr = loopback_addr;
+		} else {
+			packet->giaddr = ip->addresses[0];
+		}
+	}
+
 	if (packet->hops < max_hop_count)
 		packet->hops = packet->hops + 1;
 	else
@@ -1231,7 +1324,7 @@ find_interface_by_agent_option(struct dhcp_packet *packet,
 	int i = 0;
 	u_int8_t *circuit_id = 0;
 	unsigned circuit_id_len = 0;
-	struct interface_info *ip;
+	struct interface_info *ip = NULL;
 
 	while (i < len) {
 		/* If the next agent option overflows the end of the
@@ -1262,14 +1355,20 @@ find_interface_by_agent_option(struct dhcp_packet *packet,
 		return (-1);
 	}
 
-	/* Scan the interface list looking for an interface whose
-	   name matches the one specified in circuit_id. */
-
-	for (ip = interfaces; ip; ip = ip->next) {
-		if (ip->circuit_id &&
-		    ip->circuit_id_len == circuit_id_len &&
-		    !memcmp(ip->circuit_id, circuit_id, circuit_id_len))
-			break;
+	if (enable_support_for_dual_tor) {
+		/* If circuit _id does not match, leave ip as NULL. */
+		if ((*out)->circuit_id && (*out)->circuit_id_len == circuit_id_len &&
+			!memcmp((*out)->circuit_id, circuit_id, circuit_id_len))
+			ip = *out;
+	} else {
+		/* Scan the interface list looking for an interface whose
+		   name matches the one specified in circuit_id. */
+		for (ip = interfaces; ip; ip = ip->next) {
+			if (ip->circuit_id &&
+				ip->circuit_id_len == circuit_id_len &&
+				!memcmp(ip->circuit_id, circuit_id, circuit_id_len))
+				break;
+		}
 	}
 
 	/* If we got a match, use it. */
@@ -1668,9 +1767,13 @@ add_relay_agent_options(struct interface_info *ip, struct dhcp_packet *packet,
 			*sp++ = 4u;
 			memcpy(sp, &giaddr.s_addr, 4);
 			sp += 4;
-			packet->giaddr = uplink->addresses[0];
-			log_debug ("Adding link selection suboption"
-				   " with addr: %s", inet_ntoa(giaddr));
+			log_debug ("Adding link selection suboption with addr: %s", inet_ntoa(giaddr));
+
+			if (enable_support_for_dual_tor) {
+				packet->giaddr = loopback_addr;
+			} else {
+				packet->giaddr = uplink->addresses[0];
+			}
 		}
 
 #ifdef RELAY_PORT
@@ -2398,6 +2501,7 @@ void request_v4_interface(const char* name, int flags) {
         struct interface_info *tmp = NULL;
         int len = strlen(name);
         isc_result_t status;
+        struct downstream_intf_list *ci = NULL;
 
         if (len >= sizeof(tmp->name)) {
                 log_fatal("%s: interface name too long (is %d)", name, len);
@@ -2413,6 +2517,15 @@ void request_v4_interface(const char* name, int flags) {
 		  (flags & INTERFACE_UPSTREAM ? 'Y' : 'N'),
 		  (flags & INTERFACE_DOWNSTREAM ? 'Y' : 'N'));
 
+	if (flags & INTERFACE_DOWNSTREAM) {
+		ci = ((struct downstream_intf_list *)dmalloc(sizeof *ci, MDL));
+		if (!ci)
+			log_fatal("no memory for downstream interface pointer.\n");
+		ci->next = downstream_intfs;
+		downstream_intfs = ci;
+		ci->interface = tmp;
+	}
+
         strncpy(tmp->name, name, len);
         interface_snorf(tmp, (INTERFACE_REQUESTED | flags));
         interface_dereference(&tmp, MDL);
@@ -2487,3 +2600,74 @@ free_interface_alias_map(void) {
 	free(g_interface_name_alias_map);
 	g_interface_name_alias_map_size = 0;
 }
+
+static void
+free_downstream_intfs(void) {
+	struct downstream_intf_list *cdi;
+	while (downstream_intfs) {
+		cdi = downstream_intfs;
+		downstream_intfs = downstream_intfs->next;
+		free(cdi);
+	}
+}
+
+static void *
+receive_pkt_from_loopback(void *arg) {
+	struct interface_info loopback_intf;
+	struct sockaddr_in address;
+	union {
+		unsigned char buffer [4095];
+		struct dhcp_packet packet;
+	} pkt_buf;
+	int result;
+	struct iaddr ifrom;
+	int flag = 1;
+	int retry = 0;
+	const int max_retry = 10;
+
+	strcpy(loopback_intf.name, "loopback_intf");
+	loopback_intf.addresses = &loopback_addr;
+	loopback_intf.address_count = 1;
+	loopback_intf.flags = 0 | INTERFACE_UPSTREAM;
+
+	if ((sockfd_loopback = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
+		log_fatal("Can't create socket for loopback");
+
+	if (setsockopt(sockfd_loopback, SOL_SOCKET, SO_REUSEADDR, (char *)&flag, sizeof(flag)) < 0)
+		log_fatal("Can't set SO_REUSEADDR on dhcp loopback socket");
+
+	memset(&address, 0, sizeof(address));
+	address.sin_family = AF_INET;
+	address.sin_addr.s_addr = loopback_addr.s_addr;
+	address.sin_port = htons(67);
+
+	if (bind(sockfd_loopback, (const struct sockaddr *)&address, sizeof(address)) < 0)
+		log_fatal("Can't bind socket for loopback");
+
+	while (enable_receive_pkt_from_loopback) {
+		result = recvfrom(sockfd_loopback, pkt_buf.buffer, sizeof(pkt_buf) , 0, NULL, NULL);
+
+		if (result < 0) {
+			log_error("Failed to receive pkt from loopback");
+			if (++retry > max_retry) {
+				log_error("Max failure reached: receive pkt from loopback");
+				enable_receive_pkt_from_loopback = 0;
+			}
+			continue;
+		}
+
+		retry = 0;
+
+		if (result < DHCP_FIXED_NON_UDP) {
+			log_error("Received short pkt from loopback");
+			continue;
+		}
+
+		/* only the first 3 parameters are used in do_relay4 */
+		do_relay4(&loopback_intf, &pkt_buf.packet, (unsigned)result, 67, ifrom, NULL);
+	}
+
+	close(sockfd_loopback);
+
+	return NULL;
+}
-- 
2.17.1

