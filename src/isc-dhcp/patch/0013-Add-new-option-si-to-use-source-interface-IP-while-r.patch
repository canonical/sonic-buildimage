From 9ff954419826238d5e3aeae9a1875c4bc3a55fff Mon Sep 17 00:00:00 2001
From: Joe LeVeque <jolevequ@microsoft.com>
Date: Wed, 4 Mar 2020 19:46:21 +0000
Subject: [PATCH] Add new option -si to use source interface IP while relaying
 packets to upstream ports

---
 common/socket.c  | 95 ++++++++++++++++++++++++++++++++++++++++++++++++
 includes/dhcpd.h |  1 +
 relay/dhcrelay.c |  8 ++++
 3 files changed, 104 insertions(+)

diff --git a/common/socket.c b/common/socket.c
index e8851b4..8e97781 100644
--- a/common/socket.c
+++ b/common/socket.c
@@ -78,6 +78,29 @@ static unsigned int global_v4_socket_references = 0;
 static int global_v4_socket = -1;
 #endif
 
+/*
+ * If set, uses "from" interface IP for packet Tx.
+ * If not set, kernel chooses appropriate src ip for tx pkts
+ */
+int use_src_intf_ip_for_tx;
+
+/*
+ * For both send_packet6() and receive_packet6() we need to allocate
+ * space for the cmsg header information.  We do this once and reuse
+ * the buffer.  We also need the control buf for send_packet() and
+ * receive_packet() when we use a single socket and IP_PKTINFO to
+ * send the packet out the correct interface.
+ */
+static void   *v4_control_buf = NULL;
+static size_t  v4_control_buf_len = 0;
+
+static void
+v4_allocate_cmsg_cbuf(void) {
+	v4_control_buf_len = CMSG_SPACE(sizeof(struct in_pktinfo));
+	v4_control_buf = dmalloc(v4_control_buf_len, MDL);
+	return;
+}
+
 /*
  * If we can't bind() to a specific interface, then we can only have
  * a single socket. This variable insures that we don't try to listen
@@ -629,6 +652,77 @@ ssize_t send_packet (interface, packet, raw, len, from, to, hto)
 	struct hardware *hto;
 {
 	int result;
+#if 1
+	struct msghdr m;
+	struct iovec v;
+	struct sockaddr_in dst;
+	struct in_pktinfo *pktinfo;
+	struct cmsghdr *cmsg;
+	unsigned int ifindex;
+
+	/*
+	 * If necessary allocate space for the control message header.
+	 * The space is common between send and receive.
+	 */
+
+	if (v4_control_buf == NULL) {
+		v4_allocate_cmsg_cbuf();
+		if (v4_control_buf == NULL) {
+			log_error("send_packet: unable to allocate cmsg header");
+			return(ENOMEM);
+		}
+	}
+	memset(v4_control_buf, 0, v4_control_buf_len);
+
+	/*
+	 * Initialize our message header structure.
+	 */
+	memset(&m, 0, sizeof(m));
+
+	/*
+	 * Set the target address we're sending to.
+	 */
+	memcpy(&dst, to, sizeof(dst));
+	m.msg_name = &dst;
+	m.msg_namelen = sizeof(dst);
+	ifindex = if_nametoindex(interface->name);
+
+	/*
+	 * Set the data buffer we're sending. (Using this wacky
+	 * "scatter-gather" stuff... we only have a single chunk
+	 * of data to send, so we declare a single vector entry.)
+	 */
+	v.iov_base = (char *)raw;
+	v.iov_len = len;
+	m.msg_iov = &v;
+	m.msg_iovlen = 1;
+
+	/*
+	 * Setting the interface is a bit more involved.
+	 *
+	 * We have to create a "control message", and set that to
+	 * define the IP packet information. We could set the
+	 * source address if we wanted, but we can safely let the
+	 * kernel decide what that should be.
+	 */
+	m.msg_control = v4_control_buf;
+	m.msg_controllen = v4_control_buf_len;
+	cmsg = CMSG_FIRSTHDR(&m);
+	INSIST(cmsg != NULL);
+	cmsg->cmsg_level = IPPROTO_IP;
+	cmsg->cmsg_type = IP_PKTINFO;
+	cmsg->cmsg_len = CMSG_LEN(sizeof(*pktinfo));
+	pktinfo = (struct in_pktinfo *)CMSG_DATA(cmsg);
+	memset(pktinfo, 0, sizeof(*pktinfo));
+	pktinfo->ipi_ifindex = ifindex;
+	if (use_src_intf_ip_for_tx)
+		pktinfo->ipi_spec_dst = from;
+
+	result = sendmsg(interface->wfdesc, &m, 0);
+	if (result < 0) {
+		log_error("send_packet: %m");
+	}
+#else
 #ifdef IGNORE_HOSTUNREACH
 	int retry = 0;
 	do {
@@ -660,6 +754,7 @@ ssize_t send_packet (interface, packet, raw, len, from, to, hto)
 			log_error ("send_packet: please consult README file%s",
 				   " regarding broadcast address.");
 	}
+#endif /* 1 */
 	return result;
 }
 
diff --git a/includes/dhcpd.h b/includes/dhcpd.h
index 89bfe82..4f7a71d 100644
--- a/includes/dhcpd.h
+++ b/includes/dhcpd.h
@@ -2611,6 +2611,7 @@ ssize_t send_fallback6(struct interface_info *, struct packet *,
 #endif
 
 #ifdef USE_SOCKET_SEND
+extern int use_src_intf_ip_for_tx;
 void if_reinitialize_send (struct interface_info *);
 void if_register_send (struct interface_info *);
 void if_deregister_send (struct interface_info *);
diff --git a/relay/dhcrelay.c b/relay/dhcrelay.c
index 8aac4b3..1316591 100644
--- a/relay/dhcrelay.c
+++ b/relay/dhcrelay.c
@@ -85,6 +85,12 @@ int max_hop_count = 10;		/* Maximum hop count */
 isc_boolean_t use_if_id = ISC_FALSE;
 #endif
 
+/*
+ * If not set, kernel chooses what the src ip is.
+ * If set, uses "from" interface IP for packet Tx.
+ */
+extern int use_src_intf_ip_for_tx = 0;
+
 	/* Maximum size of a packet with agent options added. */
 int dhcp_max_agent_option_packet_length = DHCP_MTU_MIN;
 
@@ -317,6 +323,8 @@ main(int argc, char **argv) {
 #endif
 		} else if (!strcmp(argv[i], "-d")) {
 			no_daemon = 1;
+		} else if (!strcmp(argv[i], "-si")) {
+			use_src_intf_ip_for_tx = 1;
 		} else if (!strcmp(argv[i], "-q")) {
 			quiet = 1;
 			quiet_interface_discovery = 1;
-- 
2.17.1

