From 822491fc285c65fd0d09435e14a29e53e007414c Mon Sep 17 00:00:00 2001
From: Joe LeVeque <jolevequ@microsoft.com>
Date: Sun, 5 May 2019 22:52:49 +0000
Subject: [PATCH 3/3] If destination of BOOTREQUEST is directed broadcast,
 forward on that interface. Otherwise forward on fallback or all upstream
 interfaces

---
 relay/dhcrelay.c | 96 +++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 86 insertions(+), 10 deletions(-)

diff --git a/relay/dhcrelay.c b/relay/dhcrelay.c
index 292ba4f..c4c3234 100644
--- a/relay/dhcrelay.c
+++ b/relay/dhcrelay.c
@@ -30,6 +30,7 @@
 #include <syslog.h>
 #include <signal.h>
 #include <sys/time.h>
+#include <sys/ioctl.h>
 
 TIME default_lease_time = 43200; /* 12 hours... */
 TIME max_lease_time = 86400; /* 24 hours... */
@@ -799,18 +800,93 @@ do_relay4(struct interface_info *ip, struct dhcp_packet *packet,
 	/* Otherwise, it's a BOOTREQUEST, so forward it to all the
 	   servers. */
 	for (sp = servers; sp; sp = sp->next) {
-		if (send_packet((fallback_interface
-				 ? fallback_interface : interfaces),
-				 NULL, packet, length, ip->addresses[0],
-				 &sp->to, NULL) < 0) {
-			++client_packet_errors;
+		int packet_relay_attempted = 0;
+
+		log_debug("Server IP: %s", inet_ntoa(sp->to.sin_addr));
+
+		/* If the server's IP address is the broadcast IP of one
+		   of our interfaces, we send it directly on that interface's
+		   socket, because the kernel will drop directed broadcast
+		   packets if we send on the fallback. */
+		for (out = interfaces; out; out = out->next) {
+			struct in_addr out_addr, out_netmask, out_bcast_addr;
+
+			// Only relay BOOTREQUEST on upstream interfaces
+			if (!(out->flags & INTERFACE_UPSTREAM))
+				continue;
+
+			// Calculate interface's broadcast using IP and netmask
+			if (ioctl(out->wfdesc, SIOCGIFNETMASK, out->ifp) != 0) {
+				log_info("Unable to get netmask for interface %s", out->name);
+				continue;
+			}
+
+			out_addr = out->addresses[0];
+			log_debug("Iface %s addr: %s", out->name, inet_ntoa(out_addr));
+
+			out_netmask = ((struct sockaddr_in *)&out->ifp->ifr_netmask)->sin_addr;
+			log_debug("Iface %s netmask: %s", out->name, inet_ntoa(out_netmask));
+
+			// Broadcast = ip_addr | ~netmask
+			out_bcast_addr.s_addr = out->addresses[0].s_addr | ~out_netmask.s_addr;
+			log_debug("Iface %s broadcast: %s", out->name, inet_ntoa(out_bcast_addr));
+
+			if (sp->to.sin_addr.s_addr == out_bcast_addr.s_addr) {
+				log_debug("Packet destined for broadcast IP of %s", out->name);
+				if (send_packet(out, NULL, packet,
+						length, ip->addresses[0],&sp->to, NULL) < 0) {
+					++client_packet_errors;
+				} else {
+					log_debug("Forwarded BOOTREQUEST for %s to %s on interface %s",
+					       print_hw_addr(packet->htype, packet->hlen,
+							      packet->chaddr),
+					       inet_ntoa(sp->to.sin_addr), out->name);
+
+					++client_packets_relayed;
+				}
+
+				packet_relay_attempted = 1;
+
+				break;
+			}
+
+		}
+
+		if (packet_relay_attempted)
+			continue;
+
+		/* Otherwise, if we have a fallback interface, we send the packet
+		   on it. If not, we send the packet out all interfaces.*/
+		if (fallback_interface) {
+			if (send_packet(fallback_interface, NULL, packet,
+					length, ip->addresses[0],&sp->to, NULL) < 0) {
+				++client_packet_errors;
+			} else {
+				log_debug("Forwarded BOOTREQUEST for %s to %s on fallback interface",
+				       print_hw_addr(packet->htype, packet->hlen,
+						      packet->chaddr),
+				       inet_ntoa(sp->to.sin_addr));
+
+				++client_packets_relayed;
+			}
 		} else {
-			log_debug("Forwarded BOOTREQUEST for %s to %s",
-			       print_hw_addr(packet->htype, packet->hlen,
-					      packet->chaddr),
-			       inet_ntoa(sp->to.sin_addr));
+			for (out = interfaces; out; out = out->next) {
+				// Only relay BOOTREQUEST on upstream interfaces
+				if (!(out->flags & INTERFACE_UPSTREAM))
+					continue;
+
+				if (send_packet(out, NULL, packet,
+						length, ip->addresses[0],&sp->to, NULL) < 0) {
+					++client_packet_errors;
+				} else {
+					log_debug("Forwarded BOOTREQUEST for %s to %s on interface %s",
+					       print_hw_addr(packet->htype, packet->hlen,
+							      packet->chaddr),
+					       inet_ntoa(sp->to.sin_addr), out->name);
 
-			++client_packets_relayed;
+					++client_packets_relayed;
+				}
+			}
 		}
 	}
 				 
-- 
2.17.1

