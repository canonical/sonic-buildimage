From 89e6a0d31668044419489a378f725cb8452169fc Mon Sep 17 00:00:00 2001
From: sudhanshukumar22 <sudhanshu.kumar@broadcom.com>
Date: Sat, 9 Jan 2021 04:56:24 -0800
Subject: [PATCH]  While putting the route for route  selection, it is checking
 for flag in destination. Which looks like didn't  got cleaned correctly,
 resetting the flag so that next time route calculation  can be triggered in
 the Zebra.

---
 zebra/rib.h       | 1 +
 zebra/zebra_vrf.c | 2 ++
 2 files changed, 3 insertions(+)

diff --git a/zebra/rib.h b/zebra/rib.h
index 38f802979..f70c0901f 100644
--- a/zebra/rib.h
+++ b/zebra/rib.h
@@ -174,6 +174,7 @@ struct route_entry {
  *              don't generate routes
  */
 #define MQ_SIZE 7
+#define RESET_FROM_ALL_MQ 0x3f
 struct meta_queue {
 	struct list *subq[MQ_SIZE];
 	uint32_t size; /* sum of lengths of all subqueues */
diff --git a/zebra/zebra_vrf.c b/zebra/zebra_vrf.c
index be4fb29aa..3f95e449e 100644
--- a/zebra/zebra_vrf.c
+++ b/zebra/zebra_vrf.c
@@ -223,6 +223,7 @@ static int zebra_vrf_disable(struct vrf *vrf)
 				       rnode)) {
 			dest = rib_dest_from_rnode(rnode);
 			if (dest && rib_dest_vrf(dest) == zvrf) {
+				UNSET_FLAG(dest->flags, RESET_FROM_ALL_MQ);
 				route_unlock_node(rnode);
 				list_delete_node(zrouter.mq->subq[i], lnode);
 				zrouter.mq->size--;
@@ -274,6 +275,7 @@ static int zebra_vrf_delete(struct vrf *vrf)
 				       rnode)) {
 			dest = rib_dest_from_rnode(rnode);
 			if (dest && rib_dest_vrf(dest) == zvrf) {
+				UNSET_FLAG(dest->flags, RESET_FROM_ALL_MQ);
 				route_unlock_node(rnode);
 				list_delete_node(zrouter.mq->subq[i], lnode);
 				zrouter.mq->size--;
-- 
2.12.2

