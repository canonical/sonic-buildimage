From 40064cc962db5b7537eee86dbdb984d84a2ec130 Mon Sep 17 00:00:00 2001
From: Stepan Blyschak <stepanb@nvidia.com>
Date: Thu, 20 Oct 2022 13:04:45 +0000
Subject: [PATCH 2/4] Add ability for dplane_fpm_nl to receive RTM_NEWROUTE
 netlink messages that signal route handling in the asic

Signed-off-by: Donald Sharp <sharpd@nvidia.com>
---
 doc/developer/fpm.rst |  16 ++++++
 zebra/dplane_fpm_nl.c |  95 +++++++++++++++++++++++++++++++----
 zebra/rt_netlink.c    |  31 +++++++++---
 zebra/rt_netlink.h    |   4 ++
 zebra/zebra_dplane.c  |  96 +++++++++++++++++++++++++++--------
 zebra/zebra_dplane.h  |  18 +++++++
 zebra/zebra_rib.c     | 114 ++++++++++++++++++++++++++----------------
 zebra/zebra_router.c  |  11 ++++
 zebra/zebra_router.h  |   8 +++
 zebra/zebra_vty.c     |   9 ++++
 10 files changed, 319 insertions(+), 83 deletions(-)

diff --git a/doc/developer/fpm.rst b/doc/developer/fpm.rst
index 984986913..56d33671d 100644
--- a/doc/developer/fpm.rst
+++ b/doc/developer/fpm.rst
@@ -101,3 +101,19 @@ Data
 ^^^^
 
 The netlink or protobuf message payload.
+
+
+Route Status Notification from ASIC
+^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
+
+The dplane_fpm_nl has the ability to read route netlink messages
+from the underlying fpm implementation that can tell zebra
+whether or not the route has been Offloaded/Failed or Trapped.
+The end developer must send the data up the same socket that has
+been created to listen for FPM messages from Zebra.  The data sent
+must have a Frame Header with Version set to 1, Message Type set to 1
+and an appropriate message Length.  The message data must contain
+a RTM_NEWROUTE netlink message that sends the prefix and nexthops
+associated with the route.  Finally rtm_flags must contain
+RTM_F_OFFLOAD, RTM_F_TRAP and or RTM_F_OFFLOAD_FAILED to signify
+what has happened to the route in the ASIC.
diff --git a/zebra/dplane_fpm_nl.c b/zebra/dplane_fpm_nl.c
index 3b02128c9..912d08e6b 100644
--- a/zebra/dplane_fpm_nl.c
+++ b/zebra/dplane_fpm_nl.c
@@ -51,6 +51,7 @@
 #include "zebra/kernel_netlink.h"
 #include "zebra/rt_netlink.h"
 #include "zebra/debug.h"
+#include "fpm/fpm.h"
 
 #define SOUTHBOUND_DEFAULT_ADDR INADDR_LOOPBACK
 #define SOUTHBOUND_DEFAULT_PORT 2620
@@ -461,18 +462,15 @@ static void fpm_reconnect(struct fpm_nl_ctx *fnc)
 static int fpm_read(struct thread *t)
 {
 	struct fpm_nl_ctx *fnc = THREAD_ARG(t);
+	fpm_msg_hdr_t fpm;
 	ssize_t rv;
+	char buf[8192];
+	struct nlmsghdr *hdr;
+	struct zebra_dplane_ctx *ctx;
 
 	/* Let's ignore the input at the moment. */
 	rv = stream_read_try(fnc->ibuf, fnc->socket,
 			     STREAM_WRITEABLE(fnc->ibuf));
-	/* We've got an interruption. */
-	if (rv == -2) {
-		/* Schedule next read. */
-		thread_add_read(fnc->fthread->master, fpm_read, fnc,
-				fnc->socket, &fnc->t_read);
-		return 0;
-	}
 	if (rv == 0) {
 		atomic_fetch_add_explicit(&fnc->counters.connection_closes, 1,
 					  memory_order_relaxed);
@@ -491,15 +489,92 @@ static int fpm_read(struct thread *t)
 		FPM_RECONNECT(fnc);
 		return 0;
 	}
-	stream_reset(fnc->ibuf);
+
+	/* Schedule the next read */
+	thread_add_read(fnc->fthread->master, fpm_read, fnc, fnc->socket,
+			&fnc->t_read);
+
+	/* We've got an interruption. */
+	if (rv == -2)
+		return 0;
 
 	/* Account all bytes read. */
 	atomic_fetch_add_explicit(&fnc->counters.bytes_read, rv,
 				  memory_order_relaxed);
 
-	thread_add_read(fnc->fthread->master, fpm_read, fnc, fnc->socket,
-			&fnc->t_read);
+	while (rv) {
+		if (rv < (ssize_t)FPM_MSG_HDR_LEN) {
+			stream_reset(fnc->ibuf);
+			zlog_warn(
+				"%s: Received %zd bytes but cannot even read fpm header, ignoring",
+				__func__, rv);
+
+			FPM_RECONNECT(fnc);
+			return 0;
+		}
+
+		fpm.version = stream_getc(fnc->ibuf);
+		fpm.msg_type = stream_getc(fnc->ibuf);
+		fpm.msg_len = stream_getw(fnc->ibuf);
+
+		if (fpm.version != FPM_PROTO_VERSION &&
+		    fpm.msg_type != FPM_MSG_TYPE_NETLINK) {
+			stream_reset(fnc->ibuf);
+			zlog_warn(
+				"%s: Received version/msg_type %u/%u, expected 1/1",
+				__func__, fpm.version, fpm.msg_type);
 
+			FPM_RECONNECT(fnc);
+			return 0;
+		}
+
+		if (fpm.msg_len != rv) {
+			stream_reset(fnc->ibuf);
+			zlog_warn(
+				"%s: Received message length %u but read only got %zd, ignoring message",
+				__func__, fpm.msg_len, rv);
+
+			FPM_RECONNECT(fnc);
+			return 0;
+		}
+
+		/*
+		 * Place the data from the stream into a buffer
+		 */
+		hdr = (struct nlmsghdr *)buf;
+		if (sizeof(buf) < fpm.msg_len) {
+			stream_reset(fnc->ibuf);
+			zlog_warn(
+				"%s: Received unexpected large message data: %u",
+				__func__, fpm.msg_len);
+			FPM_RECONNECT(fnc);
+			return 0;
+		}
+
+		stream_get(buf, fnc->ibuf, fpm.msg_len - FPM_MSG_HDR_LEN);
+		rv -= fpm.msg_len;
+
+		switch (hdr->nlmsg_type) {
+		case RTM_NEWROUTE:
+			ctx = dplane_ctx_alloc();
+			dplane_ctx_set_op(ctx, DPLANE_OP_ROUTE_NOTIFY);
+			if (netlink_route_change_read_unicast_internal(
+				    hdr, 0, false, ctx) != 1) {
+				dplane_ctx_fini(&ctx);
+				stream_pulldown(fnc->ibuf);
+				return 0;
+			}
+			break;
+		default:
+			if (IS_ZEBRA_DEBUG_FPM)
+				zlog_debug(
+					"%s: Received message type %u which is not currently handled",
+					__func__, hdr->nlmsg_type);
+			break;
+		}
+	}
+
+	stream_reset(fnc->ibuf);
 	return 0;
 }
 
diff --git a/zebra/rt_netlink.c b/zebra/rt_netlink.c
index 0a9fdb909..4dd73fe90 100644
--- a/zebra/rt_netlink.c
+++ b/zebra/rt_netlink.c
@@ -691,8 +691,9 @@ static uint8_t parse_multipath_nexthops_unicast(ns_id_t ns_id,
 }
 
 /* Looking up routing table by netlink interface. */
-static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
-					     int startup)
+int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
+					       ns_id_t ns_id, int startup,
+					       struct zebra_dplane_ctx *ctx)
 {
 	int len;
 	struct rtmsg *rtm;
@@ -764,9 +765,8 @@ static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
 
 	selfroute = is_selfroute(rtm->rtm_protocol);
 
-	if (!startup && selfroute
-	    && h->nlmsg_type == RTM_NEWROUTE
-	    && !zrouter.asic_offloaded) {
+	if (!startup && selfroute && h->nlmsg_type == RTM_NEWROUTE &&
+	    !zrouter.asic_offloaded && !ctx) {
 		if (IS_ZEBRA_DEBUG_KERNEL)
 			zlog_debug("Route type: %d Received that we think we have originated, ignoring",
 				   rtm->rtm_protocol);
@@ -996,12 +996,20 @@ static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
 			}
 
 			if (nhe_id || ng)
-				rib_add_multipath(afi, SAFI_UNICAST, &p,
-						  &src_p, re, ng);
+				dplane_rib_add_multipath(afi, SAFI_UNICAST, &p,
+							 &src_p, re, ng,
+							 startup, ctx);
 			else
 				XFREE(MTYPE_RE, re);
 		}
 	} else {
+		if (ctx) {
+			zlog_err(
+				"%s: %pFX RTM_DELROUTE received but received a context as well",
+				__func__, &p);
+			return 0;
+		}
+
 		if (nhe_id) {
 			rib_delete(afi, SAFI_UNICAST, vrf_id, proto, 0, flags,
 				   &p, &src_p, NULL, nhe_id, table, metric,
@@ -1026,7 +1034,14 @@ static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
 		}
 	}
 
-	return 0;
+	return 1;
+}
+
+static int netlink_route_change_read_unicast(struct nlmsghdr *h, ns_id_t ns_id,
+					     int startup)
+{
+	return netlink_route_change_read_unicast_internal(h, ns_id, startup,
+							  NULL);
 }
 
 static struct mcast_route_data *mroute = NULL;
diff --git a/zebra/rt_netlink.h b/zebra/rt_netlink.h
index 93c06e555..da044c2c4 100644
--- a/zebra/rt_netlink.h
+++ b/zebra/rt_netlink.h
@@ -122,6 +122,10 @@ netlink_put_lsp_update_msg(struct nl_batch *bth, struct zebra_dplane_ctx *ctx);
 extern enum netlink_msg_status
 netlink_put_pw_update_msg(struct nl_batch *bth, struct zebra_dplane_ctx *ctx);
 
+int netlink_route_change_read_unicast_internal(struct nlmsghdr *h,
+					       ns_id_t ns_id, int startup,
+					       struct zebra_dplane_ctx *ctx);
+
 #ifdef NETLINK_DEBUG
 const char *nlmsg_type2str(uint16_t type);
 const char *af_type2str(int type);
diff --git a/zebra/zebra_dplane.c b/zebra/zebra_dplane.c
index 656ebcf3b..336056abb 100644
--- a/zebra/zebra_dplane.c
+++ b/zebra/zebra_dplane.c
@@ -132,6 +132,8 @@ struct dplane_route_info {
 	uint32_t zd_mtu;
 	uint32_t zd_nexthop_mtu;
 
+	uint32_t zd_flags;
+
 	/* Nexthop hash entry info */
 	struct dplane_nexthop_info nhe;
 
@@ -1323,6 +1325,20 @@ uint16_t dplane_ctx_get_old_instance(const struct zebra_dplane_ctx *ctx)
 	return ctx->u.rinfo.zd_old_instance;
 }
 
+uint32_t dplane_ctx_get_flags(const struct zebra_dplane_ctx *ctx)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	return ctx->u.rinfo.zd_flags;
+}
+
+void dplane_ctx_set_flags(struct zebra_dplane_ctx *ctx, uint32_t flags)
+{
+	DPLANE_CTX_VALID(ctx);
+
+	ctx->u.rinfo.zd_flags = flags;
+}
+
 uint32_t dplane_ctx_get_metric(const struct zebra_dplane_ctx *ctx)
 {
 	DPLANE_CTX_VALID(ctx);
@@ -2318,25 +2334,16 @@ static int dplane_ctx_ns_init(struct zebra_dplane_ctx *ctx,
 	return AOK;
 }
 
-/*
- * Initialize a context block for a route update from zebra data structs.
- */
-int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
-			  struct route_node *rn, struct route_entry *re)
+int dplane_ctx_route_init_basic(struct zebra_dplane_ctx *ctx,
+				enum dplane_op_e op, struct route_entry *re,
+				const struct prefix *p,
+				const struct prefix_ipv6 *src_p, afi_t afi,
+				safi_t safi)
 {
 	int ret = EINVAL;
-	const struct route_table *table = NULL;
-	const struct rib_table_info *info;
-	const struct prefix *p, *src_p;
-	struct zebra_ns *zns;
-	struct zebra_vrf *zvrf;
-	struct nexthop *nexthop;
-	struct zebra_l3vni *zl3vni;
-	const struct interface *ifp;
-	struct dplane_intf_extra *if_extra;
 
-	if (!ctx || !rn || !re)
-		goto done;
+	if (!ctx || !re)
+		return ret;
 
 	TAILQ_INIT(&ctx->u.rinfo.intf_extra_q);
 
@@ -2346,9 +2353,6 @@ int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 	ctx->u.rinfo.zd_type = re->type;
 	ctx->u.rinfo.zd_old_type = re->type;
 
-	/* Prefixes: dest, and optional source */
-	srcdest_rnode_prefixes(rn, &p, &src_p);
-
 	prefix_copy(&(ctx->u.rinfo.zd_dest), p);
 
 	if (src_p)
@@ -2358,6 +2362,7 @@ int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 
 	ctx->zd_table_id = re->table;
 
+	ctx->u.rinfo.zd_flags = re->flags;
 	ctx->u.rinfo.zd_metric = re->metric;
 	ctx->u.rinfo.zd_old_metric = re->metric;
 	ctx->zd_vrf_id = re->vrf_id;
@@ -2368,11 +2373,46 @@ int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 	ctx->u.rinfo.zd_old_tag = re->tag;
 	ctx->u.rinfo.zd_distance = re->distance;
 
+	ctx->u.rinfo.zd_afi = afi;
+	ctx->u.rinfo.zd_safi = safi;
+
+	return AOK;
+}
+
+/*
+ * Initialize a context block for a route update from zebra data structs.
+ */
+int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
+			  struct route_node *rn, struct route_entry *re)
+{
+	int ret = EINVAL;
+	const struct route_table *table = NULL;
+	const struct rib_table_info *info;
+	const struct prefix *p;
+	const struct prefix_ipv6 *src_p;
+	struct zebra_ns *zns;
+	struct zebra_vrf *zvrf;
+	struct nexthop *nexthop;
+	struct zebra_l3vni *zl3vni;
+	const struct interface *ifp;
+	struct dplane_intf_extra *if_extra;
+
+	if (!ctx || !rn || !re)
+		return ret;
+
+	/*
+	 * Let's grab the data from the route_node
+	 * so that we can call a helper function
+	 */
+
+	/* Prefixes: dest, and optional source */
+	srcdest_rnode_prefixes(rn, &p, (const struct prefix **)&src_p);
 	table = srcdest_rnode_table(rn);
 	info = table->info;
 
-	ctx->u.rinfo.zd_afi = info->afi;
-	ctx->u.rinfo.zd_safi = info->safi;
+	if (dplane_ctx_route_init_basic(ctx, op, re, p, src_p, info->afi,
+					info->safi) != AOK)
+		return ret;
 
 	/* Copy nexthops; recursive info is included too */
 	copy_nexthops(&(ctx->u.rinfo.zd_ng.nexthop),
@@ -5281,6 +5321,20 @@ kernel_dplane_process_ipset_entry(struct zebra_dplane_provider *prov,
 	dplane_provider_enqueue_out_ctx(prov, ctx);
 }
 
+void dplane_rib_add_multipath(afi_t afi, safi_t safi, struct prefix *p,
+			      struct prefix_ipv6 *src_p, struct route_entry *re,
+			      struct nexthop_group *ng, int startup,
+			      struct zebra_dplane_ctx *ctx)
+{
+	if (!ctx)
+		rib_add_multipath(afi, safi, p, src_p, re, ng);
+	else {
+		dplane_ctx_route_init_basic(ctx, dplane_ctx_get_op(ctx), re, p,
+					    src_p, afi, safi);
+		dplane_provider_enqueue_to_zebra(ctx);
+	}
+}
+
 /*
  * Kernel provider callback
  */
diff --git a/zebra/zebra_dplane.h b/zebra/zebra_dplane.h
index 1d5518138..c3fe3ba40 100644
--- a/zebra/zebra_dplane.h
+++ b/zebra/zebra_dplane.h
@@ -343,6 +343,8 @@ route_tag_t dplane_ctx_get_old_tag(const struct zebra_dplane_ctx *ctx);
 uint16_t dplane_ctx_get_instance(const struct zebra_dplane_ctx *ctx);
 void dplane_ctx_set_instance(struct zebra_dplane_ctx *ctx, uint16_t instance);
 uint16_t dplane_ctx_get_old_instance(const struct zebra_dplane_ctx *ctx);
+uint32_t dplane_ctx_get_flags(const struct zebra_dplane_ctx *ctx);
+void dplane_ctx_set_flags(struct zebra_dplane_ctx *ctx, uint32_t flags);
 uint32_t dplane_ctx_get_metric(const struct zebra_dplane_ctx *ctx);
 uint32_t dplane_ctx_get_old_metric(const struct zebra_dplane_ctx *ctx);
 uint32_t dplane_ctx_get_mtu(const struct zebra_dplane_ctx *ctx);
@@ -772,6 +774,12 @@ dplane_pbr_ipset_entry_delete(struct zebra_pbr_ipset_entry *ipset);
 int dplane_ctx_route_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 			  struct route_node *rn, struct route_entry *re);
 
+int dplane_ctx_route_init_basic(struct zebra_dplane_ctx *ctx,
+				enum dplane_op_e op, struct route_entry *re,
+				const struct prefix *p,
+				const struct prefix_ipv6 *src_p, afi_t afi,
+				safi_t safi);
+
 /* Encode next hop information into data plane context. */
 int dplane_ctx_nexthop_init(struct zebra_dplane_ctx *ctx, enum dplane_op_e op,
 			    struct nhg_hash_entry *nhe);
@@ -930,6 +938,16 @@ void zebra_dplane_pre_finish(void);
 void zebra_dplane_finish(void);
 void zebra_dplane_shutdown(void);
 
+/*
+ * decision point for sending a routing update through the old
+ * straight to zebra master pthread or through the dplane to
+ * the master pthread for handling
+ */
+void dplane_rib_add_multipath(afi_t afi, safi_t safi, struct prefix *p,
+			      struct prefix_ipv6 *src_p, struct route_entry *re,
+			      struct nexthop_group *ng, int startup,
+			      struct zebra_dplane_ctx *ctx);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/zebra/zebra_rib.c b/zebra/zebra_rib.c
index cf1baf077..50f19adcc 100644
--- a/zebra/zebra_rib.c
+++ b/zebra/zebra_rib.c
@@ -1403,8 +1403,7 @@ static bool rib_route_match_ctx(const struct route_entry *re,
 	}
 
 done:
-
-	return (result);
+	return result;
 }
 
 static void zebra_rib_fixup_system(struct route_node *rn)
@@ -2139,8 +2138,7 @@ static void rib_process_dplane_notify(struct zebra_dplane_ctx *ctx)
 	}
 
 	/* Ensure we clear the QUEUED flag */
-	if (!zrouter.asic_offloaded)
-		UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
+	UNSET_FLAG(re->status, ROUTE_ENTRY_QUEUED);
 
 	/* Is this a notification that ... matters? We mostly care about
 	 * the route that is currently selected for installation; we may also
@@ -2183,6 +2181,19 @@ static void rib_process_dplane_notify(struct zebra_dplane_ctx *ctx)
 						dplane_ctx_get_type(ctx)));
 		}
 		goto done;
+	} else {
+		uint32_t flags = dplane_ctx_get_flags(ctx);
+
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_OFFLOADED)) {
+			UNSET_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED);
+			SET_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED);
+		}
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_OFFLOAD_FAILED)) {
+			UNSET_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED);
+			SET_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED);
+		}
+		if (CHECK_FLAG(flags, ZEBRA_FLAG_TRAPPED))
+			SET_FLAG(re->flags, ZEBRA_FLAG_TRAPPED);
 	}
 
 	/* We'll want to determine whether the installation status of the
@@ -2216,55 +2227,70 @@ static void rib_process_dplane_notify(struct zebra_dplane_ctx *ctx)
 	/* Various fib transitions: changed nexthops; from installed to
 	 * not-installed; or not-installed to installed.
 	 */
-	if (start_count > 0 && end_count > 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN applied nexthop changes from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+	if (zrouter.asic_notification_nexthop_control) {
+		if (start_count > 0 && end_count > 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN applied nexthop changes from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re,
-					  DPLANE_OP_ROUTE_UPDATE, ctx);
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_UPDATE, ctx);
 
-	} else if (start_count == 0 && end_count > 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN installed transition from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+		} else if (start_count == 0 && end_count > 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN installed transition from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* We expect this to be the selected route, so we want
-		 * to tell others about this transition.
-		 */
-		SET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
+			/* We expect this to be the selected route, so we want
+			 * to tell others about this transition.
+			 */
+			SET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re, DPLANE_OP_ROUTE_UPDATE, ctx);
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_UPDATE, ctx);
 
-		/* Redistribute, lsp, and nht update */
-		redistribute_update(rn, re, NULL);
+			/* Redistribute, lsp, and nht update */
+			redistribute_update(rn, re, NULL);
 
-	} else if (start_count > 0 && end_count == 0) {
-		if (debug_p)
-			zlog_debug(
-				"%s(%u:%u):%pRN un-installed transition from dplane notification",
-				VRF_LOGNAME(vrf), dplane_ctx_get_vrf(ctx),
-				dplane_ctx_get_table(ctx), rn);
+		} else if (start_count > 0 && end_count == 0) {
+			if (debug_p)
+				zlog_debug(
+					"%s(%u:%u):%pRN un-installed transition from dplane notification",
+					VRF_LOGNAME(vrf),
+					dplane_ctx_get_vrf(ctx),
+					dplane_ctx_get_table(ctx), rn);
 
-		/* Transition from _something_ installed to _nothing_
-		 * installed.
-		 */
-		/* We expect this to be the selected route, so we want
-		 * to tell others about this transistion.
-		 */
-		UNSET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
+			/* Transition from _something_ installed to _nothing_
+			 * installed.
+			 */
+			/* We expect this to be the selected route, so we want
+			 * to tell others about this transistion.
+			 */
+			UNSET_FLAG(re->status, ROUTE_ENTRY_INSTALLED);
 
-		/* Changed nexthops - update kernel/others */
-		dplane_route_notif_update(rn, re, DPLANE_OP_ROUTE_DELETE, ctx);
+			/* Changed nexthops - update kernel/others */
+			dplane_route_notif_update(rn, re,
+						  DPLANE_OP_ROUTE_DELETE, ctx);
 
-		/* Redistribute, lsp, and nht update */
-		redistribute_delete(rn, re, NULL);
+			/* Redistribute, lsp, and nht update */
+			redistribute_delete(rn, re, NULL);
+		}
+	}
+
+	if (!zebra_router_notify_on_ack()) {
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOADED))
+			zsend_route_notify_owner_ctx(ctx, ZAPI_ROUTE_INSTALLED);
+		if (CHECK_FLAG(re->flags, ZEBRA_FLAG_OFFLOAD_FAILED))
+			zsend_route_notify_owner_ctx(ctx,
+						     ZAPI_ROUTE_FAIL_INSTALL);
 	}
 
 	/* Make any changes visible for lsp and nexthop-tracking processing */
diff --git a/zebra/zebra_router.c b/zebra/zebra_router.c
index 92a3b9424..d47517bbb 100644
--- a/zebra/zebra_router.c
+++ b/zebra/zebra_router.c
@@ -304,6 +304,17 @@ void zebra_router_init(bool asic_offload, bool notify_on_ack)
 	zrouter.asic_offloaded = asic_offload;
 	zrouter.notify_on_ack = notify_on_ack;
 
+	/*
+	 * If you start using asic_notification_nexthop_control
+	 * come talk to the FRR community about what you are doing
+	 * We would like to know.
+	 */
+#if CONFDATE > 20251231
+	CPP_NOTICE(
+		"Remove zrouter.asic_notification_nexthop_control as that it's not being maintained or used");
+#endif
+	zrouter.asic_notification_nexthop_control = false;
+
 #ifdef HAVE_SCRIPTING
 	zebra_script_init();
 #endif
diff --git a/zebra/zebra_router.h b/zebra/zebra_router.h
index c0eab9cd6..583bd0038 100644
--- a/zebra/zebra_router.h
+++ b/zebra/zebra_router.h
@@ -209,6 +209,14 @@ struct zebra_router {
 	 */
 	bool asic_offloaded;
 	bool notify_on_ack;
+
+	/*
+	 * If the asic is notifying us about successful nexthop
+	 * allocation/control.  Some developers have made their
+	 * asic take control of how many nexthops/ecmp they can
+	 * have and will report what is successfull or not
+	 */
+	bool asic_notification_nexthop_control;
 };
 
 #define GRACEFUL_RESTART_TIME 60
diff --git a/zebra/zebra_vty.c b/zebra/zebra_vty.c
index 0a3d676a9..a7eb09df0 100644
--- a/zebra/zebra_vty.c
+++ b/zebra/zebra_vty.c
@@ -3972,6 +3972,15 @@ DEFUN (show_zebra,
 	if (zrouter.asic_offloaded)
 		vty_out(vty, "Asic Offload is being used\n");
 
+	/*
+	 * Do not display this unless someone is actually using it
+	 *
+	 * Why this distinction?  I think this is effectively dead code
+	 * and should not be exposed.  Maybe someone proves me wrong.
+	 */
+	if (zrouter.asic_notification_nexthop_control)
+		vty_out(vty, "ASIC offload and nexthop control is being used");
+
 	vty_out(vty,
 		"                            Route      Route      Neighbor   LSP        LSP\n");
 	vty_out(vty,
-- 
2.30.2

