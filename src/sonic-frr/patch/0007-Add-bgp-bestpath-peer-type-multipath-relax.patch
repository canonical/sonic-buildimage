From a70c630a504e041da1c2441337b2d47e8fdd3d30 Mon Sep 17 00:00:00 2001
From: Joanne Mikkelson <jmmikkel@arista.com>
Date: Mon, 29 Jun 2020 13:31:49 -0700
Subject: [PATCH] Add "bgp bestpath peer-type multipath-relax"

This new BGP configuration is akin to "bgp bestpath aspath multipath-relax".
When applied, paths learned from different peer types will be eligible to be
considered for multipath (ECMP). Paths from all of eBGP, iBGP, and
confederation peers may be included in a multipath group if they are otherwise
equal cost.

This change preserves the existing bestpath behavior of step 10's result being
returned, not the result from steps 8 and 9, in the case where both 8+9 and 10
determine a winner.

In addition, when such a multipath group is created, it is not desirable for
iBGP nexthops to be discarded from the FIB because they are not directly
connected. When publishing a nexthop group to zebra, the
ZEBRA_FLAG_ALLOW_RECURSION flag is normally not set when the best path is
eBGP; when "bgp bestpath aspath multipath-relax" is configured, the flag
will now be set if any paths are from iBGP peers. This leaves all-eBGP
multipath groups still requiring nexthops over connected routes.
---
 bgpd/bgp_route.c | 77 ++++++++++++++++++++++++++++++++++--------------
 bgpd/bgp_vty.c   | 42 ++++++++++++++++++++++++++
 bgpd/bgpd.c      |  5 ++++
 bgpd/bgpd.h      |  1 +
 4 files changed, 103 insertions(+), 22 deletions(-)

diff --git a/bgpd/bgp_route.c b/bgpd/bgp_route.c
index b05e93306..db25a7bbe 100644
--- a/bgpd/bgp_route.c
+++ b/bgpd/bgp_route.c
@@ -462,6 +462,8 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 	int internal_as_route;
 	int confed_as_route;
 	int ret = 0;
+	int igp_metric_ret = 0;
+	int peer_sort_ret = -1;
 	char new_buf[PATH_ADDPATH_STR_BUFFER];
 	char exist_buf[PATH_ADDPATH_STR_BUFFER];
 	uint32_t new_mm_seq;
@@ -792,7 +794,9 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 			zlog_debug(
 				"%s: %s wins over %s due to eBGP peer > iBGP peer",
 				pfx_buf, new_buf, exist_buf);
-		return 1;
+		if (!bgp_flag_check(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX))
+			return 1;
+		peer_sort_ret = 1;
 	}
 
 	if (exist_sort == BGP_PEER_EBGP
@@ -802,7 +806,9 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 			zlog_debug(
 				"%s: %s loses to %s due to iBGP peer < eBGP peer",
 				pfx_buf, new_buf, exist_buf);
-		return 0;
+		if (!bgp_flag_check(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX))
+			return 0;
+		peer_sort_ret = 0;
 	}
 
 	/* 8. IGP metric check. */
@@ -814,19 +820,19 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 		existm = exist->extra->igpmetric;
 
 	if (newm < existm) {
-		if (debug)
+		if (debug && peer_sort_ret < 0)
 			zlog_debug(
 				"%s: %s wins over %s due to IGP metric %d < %d",
 				pfx_buf, new_buf, exist_buf, newm, existm);
-		ret = 1;
+		igp_metric_ret = 1;
 	}
 
 	if (newm > existm) {
-		if (debug)
+		if (debug && peer_sort_ret < 0)
 			zlog_debug(
 				"%s: %s loses to %s due to IGP metric %d > %d",
 				pfx_buf, new_buf, exist_buf, newm, existm);
-		ret = 0;
+		igp_metric_ret = 0;
 	}
 
 	/* 9. Same IGP metric. Compare the cluster list length as
@@ -844,21 +850,21 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 			existm = BGP_CLUSTER_LIST_LENGTH(exist->attr);
 
 			if (newm < existm) {
-				if (debug)
+				if (debug && peer_sort_ret < 0)
 					zlog_debug(
 						"%s: %s wins over %s due to CLUSTER_LIST length %d < %d",
 						pfx_buf, new_buf, exist_buf,
 						newm, existm);
-				ret = 1;
+				igp_metric_ret = 1;
 			}
 
 			if (newm > existm) {
-				if (debug)
+				if (debug && peer_sort_ret < 0)
 					zlog_debug(
 						"%s: %s loses to %s due to CLUSTER_LIST length %d > %d",
 						pfx_buf, new_buf, exist_buf,
 						newm, existm);
-				ret = 0;
+				igp_metric_ret = 0;
 			}
 		}
 	}
@@ -872,7 +878,10 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 				zlog_debug(
 					"%s: %s wins over %s due to confed-external peer > confed-internal peer",
 					pfx_buf, new_buf, exist_buf);
-			return 1;
+			if (!bgp_flag_check(bgp,
+					    BGP_FLAG_PEERTYPE_MULTIPATH_RELAX))
+				return 1;
+			peer_sort_ret = 1;
 		}
 
 		if (exist_sort == BGP_PEER_CONFED
@@ -882,7 +891,10 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 				zlog_debug(
 					"%s: %s loses to %s due to confed-internal peer < confed-external peer",
 					pfx_buf, new_buf, exist_buf);
-			return 0;
+			if (!bgp_flag_check(bgp,
+					    BGP_FLAG_PEERTYPE_MULTIPATH_RELAX))
+				return 0;
+			peer_sort_ret = 0;
 		}
 	}
 
@@ -943,20 +955,41 @@ static int bgp_path_info_cmp(struct bgp *bgp, struct bgp_path_info *new,
 		 * TODO: If unequal cost ibgp multipath is enabled we can
 		 * mark the paths as equal here instead of returning
 		 */
-		if (debug) {
-			if (ret == 1)
-				zlog_debug(
-					"%s: %s wins over %s after IGP metric comparison",
-					pfx_buf, new_buf, exist_buf);
-			else
-				zlog_debug(
-					"%s: %s loses to %s after IGP metric comparison",
-					pfx_buf, new_buf, exist_buf);
+
+		/* Prior to the addition of BGP_FLAG_PEERTYPE_MULTIPATH_RELAX,
+		 * if either step 7 or 10 (peer type checks) yielded a winner,
+		 * that result was returned immediately. Returning from step 10
+		 * ignored the return value computed in steps 8 and 9 (IGP
+		 * metric checks). In order to preserve that behavior, if
+		 * peer_sort_ret is set, return that rather than igp_metric_ret.
+		 */
+		ret = peer_sort_ret;
+		if (peer_sort_ret < 0) {
+			ret = igp_metric_ret;
+			if (debug) {
+				if (ret == 1)
+					zlog_debug(
+						"%s: %s wins over %s after IGP metric comparison",
+						pfx_buf, new_buf, exist_buf);
+				else
+					zlog_debug(
+						"%s: %s loses to %s after IGP metric comparison",
+						pfx_buf, new_buf, exist_buf);
+			}
+			*reason = bgp_path_selection_igp_metric;
 		}
-		*reason = bgp_path_selection_igp_metric;
 		return ret;
 	}
 
+	/*
+	 * At this point, the decision whether to set *paths_eq = 1 has been
+	 * completed. If we deferred returning because of bestpath peer-type
+	 * relax configuration, return now.
+	 */
+	if (peer_sort_ret >= 0) {
+		return peer_sort_ret;
+	}
+
 	/* 12. If both paths are external, prefer the path that was received
 	   first (the oldest one).  This step minimizes route-flap, since a
 	   newer path won't displace an older one, even if it was the
diff --git a/bgpd/bgp_vty.c b/bgpd/bgp_vty.c
index bb9da327d..f59e423cd 100644
--- a/bgpd/bgp_vty.c
+++ b/bgpd/bgp_vty.c
@@ -2361,6 +2361,38 @@ DEFUN (no_bgp_bestpath_aspath_multipath_relax,
 	return CMD_SUCCESS;
 }
 
+/* "bgp bestpath peer-type multipath-relax" configuration. */
+DEFUN (bgp_bestpath_peer_type_multipath_relax,
+       bgp_bestpath_peer_type_multipath_relax_cmd,
+       "bgp bestpath peer-type multipath-relax",
+       BGP_STR
+       "Change the default bestpath selection\n"
+       "Peer type\n"
+       "Allow load sharing across routes learned from different peer types\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+	bgp_flag_set(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX);
+	bgp_recalculate_all_bestpaths(bgp);
+
+	return CMD_SUCCESS;
+}
+
+DEFUN (no_bgp_bestpath_peer_type_multipath_relax,
+       no_bgp_bestpath_peer_type_multipath_relax_cmd,
+       "no bgp bestpath peer-type multipath-relax",
+       NO_STR
+       BGP_STR
+       "Change the default bestpath selection\n"
+       "Peer type\n"
+       "Allow load sharing across routes learned from different peer types\n")
+{
+	VTY_DECLVAR_CONTEXT(bgp, bgp);
+	bgp_flag_unset(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX);
+	bgp_recalculate_all_bestpaths(bgp);
+
+	return CMD_SUCCESS;
+}
+
 /* "bgp log-neighbor-changes" configuration.  */
 DEFUN (bgp_log_neighbor_changes,
        bgp_log_neighbor_changes_cmd,
@@ -7893,6 +7925,11 @@ static void bgp_show_bestpath_json(struct bgp *bgp, json_object *json)
 	} else
 		json_object_string_add(bestpath, "multiPathRelax", "false");
 
+	if (bgp_flag_check(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX))
+		json_object_string_add(bestpath, "peerTypeRelax", "true");
+	else
+		json_object_string_add(bestpath, "peerTypeRelax", "false");
+
 	if (bgp_flag_check(bgp, BGP_FLAG_COMPARE_ROUTER_ID))
 		json_object_string_add(bestpath, "compareRouterId", "true");
 	if (bgp_flag_check(bgp, BGP_FLAG_MED_CONFED)
@@ -13206,6 +13243,11 @@ void bgp_vty_init(void)
 	install_element(BGP_NODE, &bgp_bestpath_aspath_multipath_relax_cmd);
 	install_element(BGP_NODE, &no_bgp_bestpath_aspath_multipath_relax_cmd);
 
+	/* "bgp bestpath peer-type multipath-relax" commands */
+	install_element(BGP_NODE, &bgp_bestpath_peer_type_multipath_relax_cmd);
+	install_element(BGP_NODE,
+			&no_bgp_bestpath_peer_type_multipath_relax_cmd);
+
 	/* "bgp log-neighbor-changes" commands */
 	install_element(BGP_NODE, &bgp_log_neighbor_changes_cmd);
 	install_element(BGP_NODE, &no_bgp_log_neighbor_changes_cmd);
diff --git a/bgpd/bgp_zebra.c b/bgpd/bgp_zebra.c
index e561832e2..ba5734033 100644
--- a/bgpd/bgp_zebra.c
+++ b/bgpd/bgp_zebra.c
@@ -1199,6 +1199,7 @@ void bgp_zebra_announce(struct bgp_node *rn, struct prefix *p,
 	int nh_family;
 	unsigned int valid_nh_count = 0;
 	int has_valid_label = 0;
+	bool allow_recursion = false;
 	uint8_t distance;
 	struct peer *peer;
 	struct bgp_path_info *mpinfo;
@@ -1272,7 +1273,7 @@ void bgp_zebra_announce(struct bgp_node *rn, struct prefix *p,
 	    || CHECK_FLAG(peer->flags, PEER_FLAG_DISABLE_CONNECTED_CHECK)
 	    || bgp_flag_check(bgp, BGP_FLAG_DISABLE_NH_CONNECTED_CHK))
 
-		SET_FLAG(api.flags, ZEBRA_FLAG_ALLOW_RECURSION);
+		allow_recursion = true;
 
 	/* Metric is currently based on the best-path only */
 	metric = info->attr->med;
@@ -1379,6 +1380,16 @@ void bgp_zebra_announce(struct bgp_node *rn, struct prefix *p,
 		if (!nh_updated)
 			continue;
 
+		/* Allow recursion if it is a multipath group with both
+		   eBGP and iBGP paths. */
+		if (!allow_recursion
+		    && bgp_flag_check(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX)
+		    && (mpinfo->peer->sort == BGP_PEER_IBGP
+			|| mpinfo->peer->sort == BGP_PEER_CONFED)) {
+
+			allow_recursion = true;
+		}
+
 		if (mpinfo->extra
 		    && bgp_is_valid_label(&mpinfo->extra->label[0])
 		    && !CHECK_FLAG(api.flags, ZEBRA_FLAG_EVPN_ROUTE)) {
@@ -1394,6 +1405,9 @@ void bgp_zebra_announce(struct bgp_node *rn, struct prefix *p,
 	}
 
 
+	if (allow_recursion)
+		SET_FLAG(api.flags, ZEBRA_FLAG_ALLOW_RECURSION);
+
 	/* if this is a evpn route we don't have to include the label */
 	if (has_valid_label && !(CHECK_FLAG(api.flags, ZEBRA_FLAG_EVPN_ROUTE)))
 		SET_FLAG(api.message, ZAPI_MESSAGE_LABEL);
diff --git a/bgpd/bgpd.c b/bgpd/bgpd.c
index 19f0f136b..af54c7106 100644
--- a/bgpd/bgpd.c
+++ b/bgpd/bgpd.c
@@ -7762,6 +7762,11 @@ int bgp_config_write(struct vty *vty)
 			vty_out(vty, "\n");
 		}
 
+		if (bgp_flag_check(bgp, BGP_FLAG_PEERTYPE_MULTIPATH_RELAX)) {
+			vty_out(vty,
+				" bgp bestpath peer-type multipath-relax\n");
+		}
+
 		/* BGP network import check. */
 		if (!!bgp_flag_check(bgp, BGP_FLAG_IMPORT_CHECK)
 		    != DFLT_BGP_IMPORT_CHECK)
diff --git a/bgpd/bgpd.h b/bgpd/bgpd.h
index 6baa0b79d..bcedfdd68 100644
--- a/bgpd/bgpd.h
+++ b/bgpd/bgpd.h
@@ -364,6 +364,7 @@ struct bgp {
 #define BGP_FLAG_GR_PRESERVE_FWD          (1 << 20)
 #define BGP_FLAG_GRACEFUL_SHUTDOWN        (1 << 21)
 #define BGP_FLAG_DELETE_IN_PROGRESS       (1 << 22)
+#define BGP_FLAG_PEERTYPE_MULTIPATH_RELAX (1 << 23)
 
 	/* BGP Per AF flags */
 	uint16_t af_flags[AFI_MAX][SAFI_MAX];
-- 
2.28.0

