#!/usr/bin/env python

import signal
import json
import syslog
import psutil
import time
import ipaddress
from dhcp_cfggen import DhcpServCfg
from collections import deque
from dhcp_server_utils import LEASE_FILE_PATH, DHCP_SERVER_IPV4_LEASE, DHCP_SERVER_IP_PORTS_FILE, \
    INIT_CONFIG_FILE
from dhcp_server_utils import DhcpDbConnector
from functools import partial

KEA_DHCP4_CONFIG = "/etc/kea/kea-dhcp4.conf"
KEA_DHCP4_PROC_NAME = "kea-dhcp4"


class DhcpServd(object):
    def __init__(self, dhcp_cfg, db_connector):
        self.dhcp_cfg = dhcp_cfg
        self.db_connector = db_connector

    def notify_kea_dhcp4_proc(self):
        """
        Send SIGHUP signal to kea-dhcp4 process
        """
        for proc in psutil.process_iter():
            if KEA_DHCP4_PROC_NAME in proc.name():
                proc.send_signal(signal.SIGHUP)
                break

    def generate_kea_dhcp4_config(self, from_db=True, config_file_path=""):
        """
        Generate kea-dhcp4 config file and dump it to config folder
        Args:
            from_db: boolean, if set to True, generate config from running config_db
            config_file_path: str, if from_db is False, generate config from config_db file
        """
        kea_dhcp4_config = self.dhcp_cfg.generate_kea_dhcp4_config(from_db, config_file_path)
        if kea_dhcp4_config is None:
            syslog.syslog(syslog.LOG_ERR, "Cannot get kea-dhcp4 configure")
            return
        try:
            with open(KEA_DHCP4_CONFIG, "w") as write_file:
                json.dump(kea_dhcp4_config, write_file, indent=4, ensure_ascii=False)
                # After refresh kea-config, we need to SIGHUP kea-dhcp4 process to read new config
                self.notify_kea_dhcp4_proc()
        except FileNotFoundError:
            syslog.syslog(syslog.LOG_ERR, "Cannot write to: {}".format(INIT_CONFIG_FILE))

    def update_lease_handler(self, signum, frame):
        """
        Hanlder function to update lease table in STATE_DB
        """
        # Read lease file generated by kea-dhcp4
        try:
            with open(LEASE_FILE_PATH, "r", encoding="utf-8") as fb:
                dq = deque(fb)
        except FileNotFoundError:
            syslog.syslog(syslog.LOG_ERR, "Cannot find file {}".format(LEASE_FILE_PATH))
            return

        # Read network - dhcp interface map file
        try:
            with open(DHCP_SERVER_IP_PORTS_FILE, "r", encoding="utf8")as fp:
                json_data = json.load(fp)
                net_intf_map = {}
                for key, value in json_data.items():
                    net_intf_map[ipaddress.ip_network(key, False)] = value
                nets = set(net_intf_map.keys())
        except FileNotFoundError:
            syslog.syslog(syslog.LOG_ERR, "Cannot find file {}".format(DHCP_SERVER_IP_PORTS_FILE))
            return

        new_lease = {}
        # Get newest lease information of each client
        while dq:
            last_row = dq.pop()
            splits = last_row.split(",")
            # Skip header
            if splits[0] == "address":
                break
            ip_str = splits[0]
            mac_address = splits[1]
            valid_lifetime = splits[3]
            lease_end = splits[4]

            for net in nets:
                if ipaddress.ip_address(ip_str) in net:
                    new_key = "{}|{}".format(net_intf_map[net], mac_address)
                    if new_key in new_lease:
                        continue
                    new_lease[new_key] = {
                        "lease_start": str(int(lease_end) - int(valid_lifetime)),
                        "lease_end": lease_end,
                        "ip": ip_str
                    }
                    break

        new_lease_key = set(new_lease.keys())
        # Store old lease key
        old_lease_table = self.db_connector.get_state_db_table(DHCP_SERVER_IPV4_LEASE)
        old_lease_key = set(old_lease_table.getKeys())

        # Update/Add new lease
        # 1.1 If start time equal to end time, means lease has been released
        #     1.1.1 If current lease table has this old lease, delete it
        #     1.1.2 Else skip
        # 1.2 Else, means lease valid, save it.
        for key, value in new_lease.items():
            if value["lease_start"] == value["lease_end"]:
                if key in old_lease_key:
                    self.db_connector.state_db.delete("{}|{}".format(DHCP_SERVER_IPV4_LEASE, key))
                continue
            new_key = "{}|{}".format(DHCP_SERVER_IPV4_LEASE, key)
            for k, v in new_lease[key].items():
                self.db_connector.state_db.hset(new_key, k, v)

        # Delete old lease not in new lease set
        for key in old_lease_key:
            if key not in new_lease_key:
                # Delete entry
                self.db_connector.state_db.delete(key)

    def register_sighup_signal_hanlder(self):
        """
        Register hanlder function to exec while receive SIGHUP signal.
        """
        signal.signal(signal.SIGUSR1, self.update_lease_handler)


def main():
    dhcp_cfg = DhcpServCfg()
    dhcp_db_connector = DhcpDbConnector()
    dhcpservd = DhcpServd(dhcp_cfg, dhcp_db_connector)
    dhcpservd.generate_kea_dhcp4_config()

    # Once receive SIGUSR1 signal, update lease table in state_db
    dhcpservd.register_sighup_signal_hanlder()

    # TODO Add config db subcribe to re-generate kea-dhcp4 config after config_db change.

    while True:
        time.sleep(5)


if __name__ == "__main__":
    main()
