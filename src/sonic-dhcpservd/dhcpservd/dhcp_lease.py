import ipaddress
import json
import signal
import syslog
from abc import abstractmethod
from collections import deque

DHCP_SERVER_IPV4_LEASE = "DHCP_SERVER_IPV4_LEASE"
KEA_LEASE_FILE_PATH = "/tmp/kea-lease.csv"
DHCP_SERVER_IP_PORTS_FILE = "/tmp/dhcp_server_ip_ports.json"


class LeaseManager(object):
    def __init__(self, db_connector, kea_lease_file=KEA_LEASE_FILE_PATH):
        self.lease_handlers = [KeaDhcp4LeaseHandler(db_connector, kea_lease_file)]

    def start(self):
        """
        Register lease hanlder
        """
        for handler in self.lease_handlers:
            handler.register()


class LeaseHanlder(object):
    def __init__(self, db_connector):
        self.db_connector = db_connector

    @abstractmethod
    def _read(self):
        raise NotImplementedError

    @abstractmethod
    def register(self):
        raise NotImplementedError

    def update_lease(self, signum, frame):
        """
        Update lease table in state_db
        Args:
            new_lease: lease information obj, sample:
                {
                    "Vlan1000|aa:bb:cc:cc:cc:cc": {
                        "lease_start": "1694000905",
                        "lease_end": "1694000909",
                        "ip": "192.168.0.5"
                    }
                }
        """
        new_lease = self._read()
        new_lease_key = set(new_lease.keys())
        # Store old lease key
        old_lease_table = self.db_connector.get_state_db_table(DHCP_SERVER_IPV4_LEASE)
        old_lease_key = set(old_lease_table.getKeys())

        # Update/Add new lease
        # 1.1 If start time equal to end time, means lease has been released
        #     1.1.1 If current lease table has this old lease, delete it
        #     1.1.2 Else skip
        # 1.2 Else, means lease valid, save it.
        for key, value in new_lease.items():
            if value["lease_start"] == value["lease_end"]:
                if key in old_lease_key:
                    self.db_connector.state_db.delete("{}|{}".format(DHCP_SERVER_IPV4_LEASE, key))
                continue
            new_key = "{}|{}".format(DHCP_SERVER_IPV4_LEASE, key)
            for k, v in new_lease[key].items():
                self.db_connector.state_db.hset(new_key, k, v)

        # Delete old lease not in new lease set
        for key in old_lease_key:
            if key not in new_lease_key:
                # Delete entry
                self.db_connector.state_db.delete(key)


class KeaDhcp4LeaseHandler(LeaseHanlder):
    def __init__(self, db_connector, lease_file=KEA_LEASE_FILE_PATH):
        self.db_connector = db_connector
        self.lease_file = lease_file

    def _read(self):
        """
        Read lease file to get newest lease information
        Returns:
            lease information obj, sample:
                {
                    "Vlan1000|aa:bb:cc:cc:cc:cc": {
                        "lease_start": "1694000905",
                        "lease_end": "1694000909",
                        "ip": "192.168.0.5"
                    }
                }
        """
        # Read lease file generated by kea-dhcp4
        try:
            with open(self.lease_file, "r", encoding="utf-8") as fb:
                dq = deque(fb)
        except FileNotFoundError:
            syslog.syslog(syslog.LOG_ERR, "Cannot find lease file: {}".format(self.lease_file))
            return

        # Read network - dhcp interface map file, this file is generated by dhcp_cfggen while generate config
        with open(DHCP_SERVER_IP_PORTS_FILE, "r", encoding="utf8")as fp:
            json_data = json.load(fp)
            net_intf_map = {}
            for key, value in json_data.items():
                net_intf_map[ipaddress.ip_network(key, False)] = value
            nets = set(net_intf_map.keys())

        new_lease = {}
        # Get newest lease information of each client
        while dq:
            last_row = dq.pop()
            splits = last_row.split(",")
            # Skip header
            if splits[0] == "address":
                break
            ip_str = splits[0]
            mac_address = splits[1]
            valid_lifetime = splits[3]
            lease_end = splits[4]

            for net in nets:
                if ipaddress.ip_address(ip_str) in net:
                    new_key = "{}|{}".format(net_intf_map[net], mac_address)
                    if new_key in new_lease:
                        continue
                    new_lease[new_key] = {
                        "lease_start": str(int(lease_end) - int(valid_lifetime)),
                        "lease_end": lease_end,
                        "ip": ip_str
                    }
                    break
        return new_lease

    def register(self):
        signal.signal(signal.SIGUSR1, self.update_lease)
