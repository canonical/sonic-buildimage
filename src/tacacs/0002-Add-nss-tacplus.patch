From c845bcd8dedb5ac643bf9457af5eed73120e4d7c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?=E5=85=AD=E6=9B=B2?= <chenchen.qcc@alibaba-inc.com>
Date: Thu, 6 Jul 2017 05:38:24 -0700
Subject: [PATCH] Add nss-tacplus

---
 Makefile.am                             |  37 ++
 configure.ac                            |   1 +
 debian/control                          |   6 +
 debian/libnss-tacplus.install           |   2 +
 debian/libnss-tacplus.lintian-overrides |   8 +
 debian/libnss-tacplus.postinst          |  32 ++
 debian/libnss-tacplus.symbols           |   2 +
 debian/rules                            |   2 +
 nss_tacplus.c                           | 598 ++++++++++++++++++++++++++++++++
 tacplus_nss.conf                        |   1 +
 10 files changed, 689 insertions(+)
 create mode 100644 debian/libnss-tacplus.install
 create mode 100644 debian/libnss-tacplus.lintian-overrides
 create mode 100644 debian/libnss-tacplus.postinst
 create mode 100644 debian/libnss-tacplus.symbols
 create mode 100644 nss_tacplus.c
 create mode 100644 tacplus_nss.conf

diff --git a/Makefile.am b/Makefile.am
index 7e09e98..0fd489d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -64,6 +64,18 @@ pam_tacplus_la_CFLAGS = $(AM_CFLAGS) -I $(top_srcdir)/libtac/include -I $(top_sr
 pam_tacplus_la_LDFLAGS = -module -avoid-version
 pam_tacplus_la_LIBADD = libtac.la
 
+libnssdir = /lib/$(DEB_HOST_MULTIARCH)
+libnss_LTLIBRARIES = libnss_tacplus.la
+
+libnss_tacplus_la_SOURCES = \
+nss_tacplus.c
+
+libnss_tacplus_la_CFLAGS = $(AM_CFLAGS)
+# Version 2.0 because that's the NSS module version, and they must match
+libnss_tacplus_la_LDFLAGS = -module -version-info 2:0:0 -shared
+libnss_tacplus_la_LIBADD = -ltac
+
+
 EXTRA_DIST = pam_tacplus.spec libtac.pc.in
 if DOC
 dist_doc_DATA = sample.pam README.md AUTHORS ChangeLog
@@ -82,3 +94,28 @@ coverity:
 	tar cvzf build.tar.gz cov-int/
 
 .PHONY: coverity
+
+MULTI_OS_DIRECTORY=$(shell $(CC) $(CFLAGS) -print-multiarch)
+# This and the install rules using it are copied from libnss-ldap-264
+LIBC_VERS = $(shell ls /lib/$(MULTI_OS_DIRECTORY)/libc-*.so | sed -e '1s|.*libc-\(.*\)\.so|\1|')
+NSS_TACPLUS_LIBC_VERSIONED = libnss_tacplus-$(LIBC_VERS).so
+
+NSS_VERS = $(shell ls /lib/$(MULTI_OS_DIRECTORY)/libnss_files.so.? | sed -e '1s|.*libnss_files\.so\.\(.*\)|\1|')
+NSS_TACPLUS_NSS_VERSIONED = libnss_tacplus.so.$(NSS_VERS)
+
+# strip all but the NSS entry point, to avoid symbol pollution
+# nobody will link against this plugin, so no need for .la
+# for NSS, we don't need to install the libnss_tacplus.so.2.0.0
+# and don't want libnss_tacplus.so either since the library is a plugin.
+# libtool installs both automatically, so we remove them.
+# Copying debian and installing main copy as file with libc version,
+# and the .so.2 version as a symlink to the libc versioned file
+install-data-hook:
+	rm -f $(DESTDIR)$(libnssdir)/libnss_tacplus.la
+	rm -f $(DESTDIR)$(libnssdir)/libnss_tacplus.so $(DESTDIR)$(libnssdir)/libnss_tacplus.so.2.0.0
+	$(mkinstalldirs) $(DESTDIR)$(libnssdir) $(DESTDIR)$(sysconfdir)
+	cd .libs && $(INSTALL_PROGRAM) libnss_tacplus.so $(DESTDIR)$(libnssdir)/$(NSS_TACPLUS_LIBC_VERSIONED)
+	$(STRIP) --keep-symbol=_nss_tacplus_getpwnam_r $(DESTDIR)$(libnssdir)/$(NSS_TACPLUS_LIBC_VERSIONED)
+	cd $(DESTDIR)$(libnssdir); ln -sf $(NSS_TACPLUS_LIBC_VERSIONED) $(NSS_TACPLUS_NSS_VERSIONED)
+	${INSTALL} -m 644 tacplus_nss.conf $(DESTDIR)$(sysconfdir)
+
diff --git a/configure.ac b/configure.ac
index e34c769..bd683a8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -49,6 +49,7 @@ dnl Checks for header files.
 AC_HEADER_STDC
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h netdb.h netinet/in.h stdlib.h string.h strings.h sys/socket.h sys/time.h ])
 AC_CHECK_HEADERS([syslog.h unistd.h openssl/md5.h openssl/rand.h linux/random.h sys/random.h])
+AC_CHECK_HEADERS([nss.h])
 AC_CHECK_HEADER(security/pam_appl.h, [], [AC_MSG_ERROR([PAM libraries missing. Install with "yum install pam-devel" or "apt-get install libpam-dev".])] )
 AM_CONDITIONAL(MY_MD5, [test "$ac_cv_header_openssl_md5_h" = "no" ])
 AM_CONDITIONAL(TACC, [test "$ac_cv_lib_crypto_RAND_pseudo_bytes" = "yes"])
diff --git a/debian/control b/debian/control
index 2e851b1..1e0b25d 100644
--- a/debian/control
+++ b/debian/control
@@ -34,3 +34,9 @@ Depends: ${misc:Depends}, libtac2 (= ${binary:Version}), libc6-dev|libc-dev
 Description: Development files for TACACS+ protocol library 
  Contains C header files and development files for libtac, a TACACS+ protocol
  implementation.
+
+Package: libnss-tacplus
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}, libtac2 (= ${binary:Version})
+Description: NSS module for TACACS+ authentication without local passwd entry
+    Performs getpwname lookups via NSS for users logged in via tacacs authentication.
diff --git a/debian/libnss-tacplus.install b/debian/libnss-tacplus.install
new file mode 100644
index 0000000..9e88b1b
--- /dev/null
+++ b/debian/libnss-tacplus.install
@@ -0,0 +1,2 @@
+lib/*/*.so*
+etc/tacplus_nss.conf
diff --git a/debian/libnss-tacplus.lintian-overrides b/debian/libnss-tacplus.lintian-overrides
new file mode 100644
index 0000000..4ac1cba
--- /dev/null
+++ b/debian/libnss-tacplus.lintian-overrides
@@ -0,0 +1,8 @@
+libnss-tacplus binary package-name-doesnt-match-sonames libnss-tacplus2
+libnss-tacplus package-name-doesnt-match-sonames libnss-tacplus2
+libnss-tacplus source native-package-with-dash-version
+libnss-tacplus source diff-contains-git-control-dir .git
+libnss-tacplus source unsupported-source-format 3.0 (git)
+libnss-tacplus source changelog-should-mention-nmu
+libnss-tacplus source source-nmu-has-incorrect-version-number 1.0.1-1
+libnss-tacplus new-package-should-close-itp-bu
diff --git a/debian/libnss-tacplus.postinst b/debian/libnss-tacplus.postinst
new file mode 100644
index 0000000..8b3a74e
--- /dev/null
+++ b/debian/libnss-tacplus.postinst
@@ -0,0 +1,32 @@
+#!/bin/sh
+# postinst script for libnss-tacplus
+#
+# see: dh_installdeb(1)
+
+set -e
+
+case "$1" in
+    configure)
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# Add tacplus to /etc/nsswitch.conf, since it's necessary
+# for this package, and won't break anything else.  Do nothing
+# if tacplus is already present in the passwd line
+if [ -e "/etc/nsswitch.conf" ]; then
+    sed -i -e '/tacplus/b' \
+        -e '/^passwd/s/compat/& tacplus/' /etc/nsswitch.conf
+fi
+
+
+#DEBHELPER#
+
+exit 0
diff --git a/debian/libnss-tacplus.symbols b/debian/libnss-tacplus.symbols
new file mode 100644
index 0000000..f476e7d
--- /dev/null
+++ b/debian/libnss-tacplus.symbols
@@ -0,0 +1,2 @@
+libnss_tacplus.so.2 libnss-tacplus #MINVER#
+ _nss_tacplus_getpwnam_r@Base 1.0.1
diff --git a/debian/rules b/debian/rules
index 0fa1f54..c0251b8 100755
--- a/debian/rules
+++ b/debian/rules
@@ -22,5 +22,7 @@ override_dh_auto_configure:
 override_dh_install:
 	mkdir -p debian/libpam-tacplus/usr/share/pam-configs
 	cp debian/tacplus debian/libpam-tacplus/usr/share/pam-configs/
+	# mkdir -p debian/libnss-tacplus/etc
+	# cp debian/tmp/etc/tacplus_nss.conf debian/libnss-tacplus/etc/
 	dh_install
 
diff --git a/nss_tacplus.c b/nss_tacplus.c
new file mode 100644
index 0000000..3438db9
--- /dev/null
+++ b/nss_tacplus.c
@@ -0,0 +1,598 @@
+/*
+ * Copyright (C) 2014, 2015, 2016 Cumulus Networks, Inc.  All rights reserved.
+ * Author: Dave Olson <olson@cumulusnetworks.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program - see the file COPYING.
+ */
+
+/*
+ * This plugin implements getpwnam_r for NSS over TACACS+
+ * and implements getpwuid_r for UIDs if and only if a mapped
+ * TACACS+ user is currently logged in (libtacplus_map)
+ * This means that if you do, e.g.: ls -ld ~tacacs15, you will
+ * sometimes get a mapped username, and other times get tacacs15,
+ * depending on whether a mapped user is logged in or not.
+ */
+
+#include <string.h>
+#include <syslog.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <pwd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <netdb.h>
+#include <nss.h>
+
+#include <libtac/include/libtac.h>
+
+static const char *nssname = "nss_tacplus"; /* for syslogs */
+static const char *config_file = "/etc/tacplus_nss.conf";
+
+/*
+ * pwbuf is used to reduce number of arguments passed around; the strings in
+ * the passwd struct need to point into this buffer.
+ */
+struct pwbuf {
+    char *name;
+    char *buf;
+    struct passwd *pw;
+    int *errnop;
+    size_t buflen;
+};
+
+typedef struct {
+    struct addrinfo *addr;
+    char *key;
+    int timeout;
+} tacplus_server_t;
+
+enum tac_user {
+     TAC_USER_SU = 0,
+     TAC_USER    = 1,
+     TAC_USER_NUM
+};
+
+/* set from configuration file parsing */
+static tacplus_server_t tac_srv[TAC_PLUS_MAXSERVERS];
+static int tac_srv_no;
+static struct addrinfo *source_addr = NULL;
+static struct passwd tac_pw[TAC_USER_NUM];
+const char *tac_pw_name[TAC_USER_NUM] = {"remote_user_su", "remote_user"};
+
+static char tac_service[] = "shell";
+static char tac_protocol[] = "ssh";
+static int debug=1;
+static int conf_parsed = 0;
+
+static int parse_tac_pw()
+{
+    FILE *fp;
+    struct passwd *pw;
+    int index, count = 0;
+
+    fp = fopen("/etc/passwd", "r");
+    if(NULL == fp)
+    {
+        syslog(LOG_ERR, "%s: /etc/passwd fopen failed", nssname);
+        return NSS_STATUS_UNAVAIL;
+    }
+
+    while(0 != (pw = fgetpwent(fp)))
+    {
+        for(index = TAC_USER_SU; index < TAC_USER_NUM; ++index)
+        {
+            if(!strcmp(pw->pw_name, tac_pw_name[index]))
+            {
+                tac_pw[index].pw_name   = strdup(pw->pw_name);
+                tac_pw[index].pw_passwd = strdup(pw->pw_passwd);
+                tac_pw[index].pw_gecos  = strdup(pw->pw_gecos);
+                tac_pw[index].pw_dir    = strdup(pw->pw_dir);
+                tac_pw[index].pw_shell  = strdup(pw->pw_shell);
+                tac_pw[index].pw_uid    = pw->pw_uid;
+                tac_pw[index].pw_gid    = pw->pw_gid;
+                ++count;
+                if(debug)
+                    syslog(LOG_DEBUG, "%s: tac_pw name %s", nssname,
+                                tac_pw[index].pw_name);
+            }
+        }
+    }
+    fclose(fp);
+
+    if(count < TAC_USER_NUM)
+    {
+        syslog(LOG_ERR, "%s: tacacs user passwd parsed %d < %d", nssname,
+            count, TAC_USER_NUM);
+    }
+
+    return 0;
+}
+
+static int parse_tac_server(char *srv_buf)
+{
+    char *token;
+    char delim[] = " ,\t\n\r\f";
+
+    token = strsep(&srv_buf, delim);
+    while(NULL != token)
+    {
+        if('\0' != token)
+        {
+            if(!strncmp(token, "server=", 7))
+            {
+                struct addrinfo hints, *server;
+                int rv;
+                char *srv, *port;
+
+                memset(&hints, 0, sizeof hints);
+                hints.ai_family = AF_UNSPEC;
+                hints.ai_socktype = SOCK_STREAM;
+                
+                srv = token + 7;
+                port = strchr(srv, ':');
+                if(NULL != port)
+                {
+                    *port = '\0';
+                    port++;
+                }
+
+                if((rv = getaddrinfo(srv, (port == NULL) ? "49" : port, &hints,
+                    &server)) == 0)
+                {
+                    if(NULL != server)
+                    {
+                        if(NULL != tac_srv[tac_srv_no].addr)
+                            freeaddrinfo(tac_srv[tac_srv_no].addr);
+                        if(NULL != tac_srv[tac_srv_no].key)
+                            free(tac_srv[tac_srv_no].key);
+                        memset(tac_srv + tac_srv_no, 0, sizeof(tacplus_server_t));
+
+                        tac_srv[tac_srv_no].addr = server;
+                    }
+                    else
+                    {
+                        syslog(LOG_ERR, "%s: server NULL", nssname);
+                    }
+                }
+                else
+                {
+                    syslog(LOG_ERR, "%s: invalid server: %s (getaddrinfo: %s)",
+                        nssname, srv, gai_strerror(rv));
+                    return -1;
+                }
+            }
+            else if(!strncmp(token, "secret=", 7))
+            {
+                tac_srv[tac_srv_no].key = strdup(token + 7);
+            }
+            else if(!strncmp(token, "timeout=", 8))
+            {
+                tac_srv[tac_srv_no].timeout = (int)strtoul(token + 8, NULL, 0);
+                if(tac_srv[tac_srv_no].timeout < 0)
+                    tac_srv[tac_srv_no].timeout = 0;
+                /* Limit timeout to make sure upper application not wait
+                 * for a long time*/
+                if(tac_srv[tac_srv_no].timeout > 3)
+                    tac_srv[tac_srv_no].timeout = 3;
+            }
+        }
+        token = strsep(&srv_buf, delim);
+    }
+
+    return 0;
+}
+
+static int parse_config(const char *file)
+{
+    FILE *fp;
+    char buf[512] = {0};
+
+    if(conf_parsed < 1)
+    {
+        if(0 == parse_tac_pw())
+            conf_parsed = 1;
+        else
+            return NSS_STATUS_UNAVAIL;
+    }
+
+    fp = fopen(file, "r");
+    if(NULL == fp)
+    {
+        syslog(LOG_ERR, "%s: %s fopen failed", nssname, file);
+        return NSS_STATUS_UNAVAIL;
+    }
+
+    tac_srv_no = 0;
+    while(fgets(buf, sizeof(buf), fp))
+    {
+        if('#' == *buf || isspace(*buf))
+            continue;
+
+        if(!strncmp(buf, "debug=", 6))
+        {
+            debug = strtoul(buf + 6, NULL, 0);
+        }
+        else if(!strncmp(buf, "src_ip=", 7))
+        {
+            struct addrinfo hints;
+            char *ip = buf + 7;
+
+            memset(&hints, 0, sizeof hints);
+            hints.ai_family = AF_UNSPEC;
+            hints.ai_socktype = SOCK_STREAM;
+
+            if(source_addr)
+                freeaddrinfo(source_addr);
+
+            if(0 != getaddrinfo(ip, NULL, &hints, &source_addr))
+                syslog(LOG_ERR, "%s: error setting the source ip information",
+                    nssname);
+        }
+        else if(!strncmp(buf, "server=", 7))
+        {
+            if(TAC_PLUS_MAXSERVERS > tac_srv_no)
+            {
+                if(0 == parse_tac_server(buf))
+                    ++tac_srv_no;
+            }
+            else
+                syslog(LOG_ERR, "%s: tac server num is more than %d",
+                    nssname, TAC_PLUS_MAXSERVERS);
+        }
+    }
+    fclose(fp);
+
+    if(debug)
+    {
+        int n;
+
+        for(n = 0; n < tac_srv_no; ++n)
+        {
+            syslog(LOG_DEBUG, "%s: server[%d] { addr=%s, key=%s, timeout=%d }",
+                        nssname, n, tac_ntop(tac_srv[n].addr->ai_addr),
+                        tac_srv[n].key, tac_srv[n].timeout);
+        }
+
+        syslog(LOG_DEBUG, "%s: src_ip=%s", nssname, NULL == source_addr
+                    ? "NULL" : tac_ntop(source_addr->ai_addr));
+    }
+
+    return 0;
+}
+
+
+/*
+ * copy a passwd structure and it's strings, using the provided buffer
+ * for the strings.
+ * if usename is non-NULL, use that, rather than pw_name in srcpw, so we can
+ * preserve the original requested name (this is part of the tacacs remapping).
+ * For strings, if pointer is null, use an empty string.
+ * Returns 0 if everything fit, otherwise 1.
+ */
+static int
+pwcopy(char *buf, size_t len, struct passwd *srcpw, struct passwd *destpw,
+       const char *usename)
+{
+    size_t needlen;
+    int cnt;
+
+    if(!usename)
+        usename = srcpw->pw_name;
+
+    needlen = usename ? strlen(usename) + 1 : 1 +
+        srcpw->pw_dir ? strlen(srcpw->pw_dir) + 1 : 1 +
+        srcpw->pw_gecos ? strlen(srcpw->pw_gecos) + 1 : 1 +
+        srcpw->pw_shell ? strlen(srcpw->pw_shell) + 1 : 1 +
+        srcpw->pw_passwd ? strlen(srcpw->pw_passwd) + 1 : 1;
+    if(needlen > len) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s provided password buffer too small (%ld<%ld)",
+                nssname, (long)len, (long)needlen);
+        return 1;
+    }
+
+    destpw->pw_uid = srcpw->pw_uid;
+    destpw->pw_gid = srcpw->pw_gid;
+
+    cnt = snprintf(buf, len, "%s", usename ? usename : "");
+    destpw->pw_name = buf;
+    cnt++; /* allow for null byte also */
+    buf += cnt;
+    len -= cnt;
+    /* set pw_passwd "a" for pam_account success */
+    cnt = snprintf(buf, len, "%s", "a");
+    destpw->pw_passwd = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_shell ? srcpw->pw_shell : "");
+    destpw->pw_shell = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_gecos ? srcpw->pw_gecos : "");
+    destpw->pw_gecos = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_dir ? srcpw->pw_dir : "");
+    destpw->pw_dir = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+
+    return 0;
+}
+
+/*
+ * we got the user back.  Go through the attributes, find their privilege
+ * level, map to the local user, fill in the data, etc.
+ * Returns 0 on success, 1 on errors.
+ */
+static int
+got_tacacs_user(struct tac_attrib *attr, struct pwbuf *pb)
+{
+    unsigned long priv_level = 0;
+    int ret;
+
+    while(attr != NULL)  {
+        /* we are looking for the privilege attribute, can be in several forms,
+         * typically priv-lvl= or priv_lvl= */
+        if(strncasecmp(attr->attr, "priv", 4) == 0) {
+            char *ok, *val;
+
+            for(val=attr->attr; *val && *val != '*' && *val != '='; val++)
+                ;
+            if(!*val)
+                continue;
+            val++;
+
+            priv_level = strtoul(val, &ok, 0);
+
+            /* if this fails, we leave priv_level at 0, which is
+             * least privileged, so that's OK, but at least report it
+             */
+            if(debug)
+                syslog(LOG_DEBUG, "%s: privilege for %s, (%lu)",
+                    nssname, pb->name, priv_level);
+        }
+        attr = attr->next;
+    }
+
+    if(priv_level == 15)
+        /* remote_user_su has sudo and docker privilege. If it return login
+         * username, user only get gid, can't get group info in /etc/group.
+         * remote_user_su can use all command, and not need to command
+         * authorization by default, so not return login name is ok.
+         * remote_user only has docker privilege, its gid is created as
+         * docker group id.
+         * */
+        ret = pwcopy(pb->buf, pb->buflen, tac_pw + TAC_USER_SU, pb->pw, NULL);
+    else
+        ret = pwcopy(pb->buf, pb->buflen, tac_pw + TAC_USER, pb->pw, pb->name);
+
+    if(debug)
+        syslog(LOG_DEBUG, "%s: pw_name=%s, pw_passwd=%s, pw_shell=%s, dir=%s",
+                nssname, pb->pw->pw_name, pb->pw->pw_passwd, pb->pw->pw_shell,
+                pb->pw->pw_dir);
+
+    if(ret)
+       *pb->errnop = ERANGE;
+
+    return ret;
+}
+
+/*
+ * Attempt to connect to the requested tacacs server.
+ * Returns fd for connection, or -1 on failure
+ */
+
+static int
+connect_tacacs(struct tac_attrib **attr, int srvr)
+{
+    int fd;
+
+    if(!*tac_service) /* reported at config file processing */
+        return -1;
+
+    fd = tac_connect_single(tac_srv[srvr].addr, tac_srv[srvr].key, source_addr,
+                            tac_srv[srvr].timeout);
+    if(fd >= 0) {
+        *attr = NULL; /* so tac_add_attr() allocates memory */
+        tac_add_attrib(attr, "service", tac_service);
+        if(tac_protocol[0])
+            tac_add_attrib(attr, "protocol", tac_protocol);
+        /* empty cmd is required, at least for linux tac_plus */
+        tac_add_attrib(attr, "cmd", "");
+    }
+    return fd;
+}
+
+
+/*
+ * lookup the user on a TACACS server.  Returns 0 on successful lookup, else 1
+ *
+ * Make a new connection each time, because libtac is single threaded and
+ * doesn't support multiple connects at the same time due to use of globals,
+ * and doesn't have support for persistent connections.   That's fixable, but
+ * not worth the effort at this point.
+ * Step through all servers until success or end of list, because different
+ * servers can have different databases.
+ */
+static int
+lookup_tacacs_user(struct pwbuf *pb)
+{
+    struct areply arep;
+    int ret = 1, done = 0;
+    struct tac_attrib *attr;
+    int tac_fd, srvr;
+
+    for(srvr=0; srvr < tac_srv_no && !done; srvr++) {
+        arep.msg = NULL;
+        arep.attr = NULL;
+        arep.status = TAC_PLUS_AUTHOR_STATUS_ERROR; /* if author_send fails */
+        tac_fd = connect_tacacs(&attr, srvr);
+        if (tac_fd < 0) {
+            if(debug)
+                syslog(LOG_WARNING, "%s: failed to connect TACACS+ server %s,"
+                    " ret=%d: %m", nssname, tac_srv[srvr].addr ?
+                    tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", tac_fd);
+            continue;
+        }
+        ret = tac_author_send(tac_fd, pb->name, "", "", attr);
+        if(ret < 0) {
+            if(debug)
+                syslog(LOG_WARNING, "%s: TACACS+ server %s send failed (%d) for"
+                    " user %s: %m", nssname, tac_srv[srvr].addr ?
+                    tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", ret,
+                    pb->name);
+        }
+        else  {
+            errno = 0;
+            ret = tac_author_read(tac_fd, &arep);
+            if (ret == LIBTAC_STATUS_PROTOCOL_ERR)
+                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed with"
+                    " protocol error (incorrect shared secret?) user %s",
+                    nssname, tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name);
+            else if (ret < 0) /*  ret == 1 OK transaction, use arep.status */
+                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed (%d) for"
+                    " user %s: %m", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), ret, pb->name);
+        }
+
+        tac_free_attrib(&attr);
+        close(tac_fd);
+        if(ret < 0)
+            continue;
+
+        if(arep.status == AUTHOR_STATUS_PASS_ADD ||
+           arep.status == AUTHOR_STATUS_PASS_REPL) {
+            ret = got_tacacs_user(arep.attr, pb);
+            if(debug)
+                syslog(LOG_DEBUG, "%s: TACACS+ server %s successful for user %s."
+                    " local lookup %s", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
+                    ret == 0?"OK":"no match");
+            done = 1; /* break out of loop after arep cleanup */
+        }
+        else {
+            ret = 1; /*  in case last server */
+            if(debug)
+                syslog(LOG_DEBUG, "%s: TACACS+ server %s replies user %s"
+                    " invalid (%d)", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
+                    arep.status);
+        }
+        if(arep.msg)
+            free(arep.msg);
+        if(arep.attr) /* free returned attributes */
+            tac_free_attrib(&arep.attr);
+    }
+
+    return ret;
+}
+
+static bool is_valid_name (const char *name)
+{
+	/*
+	 * User/group names must match [a-z_][a-z0-9_-]*[$]
+	 */
+	if (('\0' == *name) ||
+	    !((('a' <= *name) && ('z' >= *name)) || ('_' == *name))) {
+		return false;
+	}
+
+	while ('\0' != *++name) {
+		if (!(( ('a' <= *name) && ('z' >= *name) ) ||
+		      ( ('0' <= *name) && ('9' >= *name) ) ||
+		      ('_' == *name) ||
+		      ('-' == *name) ||
+		      ( ('$' == *name) && ('\0' == *(name + 1)) )
+		     )) {
+			return false;
+		}
+	}
+
+	return true;
+}
+
+static bool is_valid_user_name (const char *name)
+{
+	/*
+	 * User names are limited by whatever utmp can
+	 * handle.
+	 */
+	if (strlen (name) > 32) {
+		return false;
+	}
+
+	return is_valid_name (name);
+}
+
+/*
+ * This is an NSS entry point.
+ * We implement getpwnam(), because we remap from the tacacs login
+ * to the local tacacs0 ... tacacs15 users for all other info, and so
+ * the normal order of "passwd tacplus" (possibly with ldap or anything
+ * else prior to tacplus) will mean we only get used when there isn't
+ * a local user to be found.
+ *
+ * We try the lookup to the tacacs server first.  If we can't make a
+ * connection to the server for some reason, we also try looking up
+ * the account name via the mapping file, primarily to handle cases
+ * where we aren't running with privileges to read the tacacs configuration
+ * (since it has the secret key).
+ */
+enum nss_status _nss_tacplus_getpwnam_r(const char *name, struct passwd *pw,
+    char *buffer, size_t buflen, int *errnop)
+{
+    enum nss_status status = NSS_STATUS_NOTFOUND;
+    int result;
+    struct pwbuf pbuf;
+
+    /* When filename completion is used with the tab key in bash, getpwnam
+       is invoked. And the parameter "name" is '*'. In order not to connect to
+       TACACS+ server frequently, check user name whether is valid. */
+    if(!is_valid_user_name(name))
+        return NSS_STATUS_NOTFOUND;
+
+    result = parse_config(config_file);
+
+    if(result) { /* no config file, no servers, etc. */
+        /*  this is a debug because privileges may not allow access */
+        if(debug)
+            syslog(LOG_DEBUG, "%s: bad config or server line for nss_tacplus",
+                nssname);
+    }
+    else {
+        /* marshal the args for the lower level functions */
+        pbuf.name = (char *)name;
+        pbuf.pw = pw;
+        pbuf.buf = buffer;
+        pbuf.buflen = buflen;
+        pbuf.errnop = errnop;
+
+        if(0 == lookup_tacacs_user(&pbuf))
+            status = NSS_STATUS_SUCCESS;
+    }
+
+    if(debug)
+        syslog(LOG_DEBUG, "%s: name=%s, pw_name=%s, pw_passwd=%s, pw_shell=%s",
+                    nssname, name, pw->pw_name, pw->pw_passwd, pw->pw_shell);
+
+    return status;
+}
+
diff --git a/tacplus_nss.conf b/tacplus_nss.conf
new file mode 100644
index 0000000..e22794c
--- /dev/null
+++ b/tacplus_nss.conf
@@ -0,0 +1 @@
+debug=1
-- 
2.7.4

