From 07976a2a70e6faed026560b36e155689a9cf2d12 Mon Sep 17 00:00:00 2001
From: liuh <liuh@microsoft.com>
Date: Fri, 8 Dec 2023 15:03:06 +0800
Subject: [PATCH] Connect all TACACS server in parallel

---
 nss_tacplus.c | 248 +++++++++++++++++++++++++++++++++++---------------
 1 file changed, 175 insertions(+), 73 deletions(-)

diff --git a/nss_tacplus.c b/nss_tacplus.c
index d954f03..f531e8c 100644
--- a/nss_tacplus.c
+++ b/nss_tacplus.c
@@ -34,6 +34,7 @@
 #include <netdb.h>
 #include <nss.h>
 #include <limits.h>
+#include <pthread.h>
 #include <unistd.h>
 #include <sys/wait.h>
 
@@ -91,6 +92,19 @@ static char vrfname[64];
 static bool debug = false;
 static bool many_to_one = false;
 
+/* variables for parallel TACACS connection */
+static bool tacacs_auth_success = false;
+static int finish_server_count = 0;
+static unsigned long server_priv_level = 0;
+
+typedef struct
+{
+    const char *name;
+    int srvr;
+    char *remote_addr;
+    const char* current_tty;
+} tacacs_thread_args_t;
+
 static int parse_tac_server(char *srv_buf)
 {
     char *token;
@@ -696,15 +710,14 @@ static int lookup_user_pw(struct pwbuf *pb, int level)
 }
 
 /*
- * we got the user back.  Go through the attributes, find their privilege
- * level, map to the local user, fill in the data, etc.
- * Returns 0 on success, 1 on errors.
+ * we got the user back.  Go through the attributes,
+ * find their privilege level.
+ * Returns privilege level.
  */
-static int
-got_tacacs_user(struct tac_attrib *attr, struct pwbuf *pb)
+static unsigned long
+got_tacacs_priv_level(struct tac_attrib *attr, const char* name)
 {
     unsigned long priv_level = 0;
-    int ret;
 
     while(attr != NULL)  {
         /* we are looking for the privilege attribute, can be in several forms,
@@ -725,12 +738,22 @@ got_tacacs_user(struct tac_attrib *attr, struct pwbuf *pb)
              */
             if(debug)
                 syslog(LOG_DEBUG, "%s: privilege for %s, (%lu)",
-                    nssname, pb->name, priv_level);
+                    nssname, name, priv_level);
         }
         attr = attr->next;
     }
 
-    ret = lookup_user_pw(pb, priv_level);
+    return priv_level;
+}
+
+/*
+ * we got the privilege level, map to the local user, fill in the data, etc.
+ * Returns 0 on success, 1 on errors.
+ */
+static int
+got_tacacs_user(struct pwbuf *pb, unsigned long priv_level)
+{
+    int ret = lookup_user_pw(pb, priv_level);
     if(!ret && debug)
         syslog(LOG_DEBUG, "%s: pw_name=%s, pw_passwd=%s, pw_shell=%s, dir=%s",
                 nssname, pb->pw->pw_name, pb->pw->pw_passwd, pb->pw->pw_shell,
@@ -836,13 +859,126 @@ int get_remote_address(char* dst, socklen_t size)
  * Step through all servers until success or end of list, because different
  * servers can have different databases.
  */
-static int
-lookup_tacacs_user(struct pwbuf *pb)
+static void *
+lookup_tacacs_user_thread(void* args)
 {
+    // pthread_create require thread method only have 1 void* parameter.
+    const char *name = ((tacacs_thread_args_t*)args)->name;
+    int srvr = ((tacacs_thread_args_t*)args)->srvr;
+    char *remote_addr = ((tacacs_thread_args_t*)args)->remote_addr;
+    const char* current_tty = ((tacacs_thread_args_t*)args)->current_tty;
+    free(args);
+
     struct areply arep;
-    int ret = 1, done = 0;
+    int ret = 1;
     struct tac_attrib *attr;
-    int tac_fd, srvr;
+    int tac_fd;
+
+    arep.msg = NULL;
+    arep.attr = NULL;
+    arep.status = TAC_PLUS_AUTHOR_STATUS_ERROR; /* if author_send fails */
+    tac_fd = connect_tacacs(&attr, srvr);
+    if (tac_fd < 0) {
+        if(debug)
+            syslog(LOG_WARNING, "%s: failed to connect TACACS+ server %s,"
+                " ret=%d: %m", nssname, tac_srv[srvr].addr ?
+                tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", tac_fd);
+        
+        // current TACACS connection thread finish
+        goto exit_tacacs_thread;
+    }
+
+    if (tacacs_auth_success) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s: TACACS connect thread %d stop because other TACACS server connection finished", nssname, srvr);
+
+        goto exit_tacacs_thread;
+    }
+
+    ret = tac_author_send(tac_fd, name, current_tty != NULL ? (char *)current_tty : "", remote_addr, attr);
+    if(ret < 0) {
+        if(debug)
+            syslog(LOG_WARNING, "%s: TACACS+ server %s send failed (%d) for"
+                " user %s: %m", nssname, tac_srv[srvr].addr ?
+                tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown",
+                ret, name);
+        goto exit_tacacs_thread;
+    }
+
+    if (tacacs_auth_success) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s: TACACS connect thread %d stop because other TACACS server connection finished", nssname, srvr);
+
+        goto exit_tacacs_thread;
+    }
+
+    errno = 0;
+    ret = tac_author_read(tac_fd, &arep);
+    tac_free_attrib(&attr);
+    if (ret == LIBTAC_STATUS_PROTOCOL_ERR) {
+        syslog(LOG_WARNING, "%s: TACACS+ server %s read failed with"
+            " protocol error (incorrect shared secret?) user %s",
+            nssname, tac_ntop(tac_srv[srvr].addr->ai_addr), name);
+    }
+    else if (ret < 0) { /*  ret == 1 OK transaction, use arep.status */
+        syslog(LOG_WARNING, "%s: TACACS+ server %s read failed (%d) for"
+            " user %s: %m", nssname,
+            tac_ntop(tac_srv[srvr].addr->ai_addr), ret, name);
+        goto exit_tacacs_thread;
+    }
+
+    if (tacacs_auth_success) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s: TACACS connect thread %d stop because other TACACS server connection finished", nssname, srvr);
+
+        goto exit_tacacs_thread;
+    }
+
+    if(arep.status == AUTHOR_STATUS_PASS_ADD ||
+        arep.status == AUTHOR_STATUS_PASS_REPL) {
+        server_priv_level = got_tacacs_priv_level(arep.attr, name);
+        if(debug)
+            syslog(LOG_DEBUG, "%s: TACACS+ server %s successful for user %s."
+                " local lookup %s", nssname,
+                tac_ntop(tac_srv[srvr].addr->ai_addr), name,
+                ret == 0?"OK":"no match");
+        tacacs_auth_success = true; /* set flag to notify other TACACS connection thread stop */
+    }
+    else if(debug){
+        syslog(LOG_DEBUG, "%s: TACACS+ server %s successful for user %s."
+            " invalid (%d)", nssname,
+            tac_ntop(tac_srv[srvr].addr->ai_addr), name,
+            arep.status);
+    }
+
+exit_tacacs_thread:
+    if (tac_fd >= 0)
+        close(tac_fd);
+    if(arep.msg)
+        free(arep.msg);
+    if(arep.attr) /* free returned attributes */
+        tac_free_attrib(&arep.attr);
+
+    finish_server_count += 1;
+
+    pthread_exit(NULL);
+}
+
+/*
+ * lookup the user on a TACACS server.  Returns 0 on successful lookup, else 1
+ *
+ * Make a new connection each time, because libtac is single threaded and
+ * doesn't support multiple connects at the same time due to use of globals,
+ * and doesn't have support for persistent connections.   That's fixable, but
+ * not worth the effort at this point.
+ * Step through all servers until success or end of list, because different
+ * servers can have different databases.
+ */
+static int
+lookup_tacacs_user(struct pwbuf *pb)
+{
+    int ret = 1;
+    int srvr;
     char remote_addr[INET6_ADDRSTRLEN];
     const char* current_tty = getenv("SSH_TTY");
 
@@ -851,69 +987,35 @@ lookup_tacacs_user(struct pwbuf *pb)
         syslog(LOG_DEBUG, "%s: can't get remote address from environment variable, result=%d", nssname, result);
     }
 
-    for(srvr=0; srvr < tac_srv_no && !done; srvr++) {
-        arep.msg = NULL;
-        arep.attr = NULL;
-        arep.status = TAC_PLUS_AUTHOR_STATUS_ERROR; /* if author_send fails */
-        tac_fd = connect_tacacs(&attr, srvr);
-        if (tac_fd < 0) {
-            syslog(LOG_ERR, "%s: failed to connect TACACS+ server %s,"
-                " ret=%d: %m", nssname, tac_srv[srvr].addr ?
-                tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", tac_fd);
-            continue;
-        }
-        ret = tac_author_send(tac_fd, pb->name, current_tty != NULL ? (char *)current_tty : "", remote_addr, attr);
-        if(ret < 0) {
-            if(debug)
-                syslog(LOG_WARNING, "%s: TACACS+ server %s send failed (%d) for"
-                    " user %s: %m", nssname, tac_srv[srvr].addr ?
-                    tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", ret,
-                    pb->name);
-        }
-        else  {
-            errno = 0;
-            ret = tac_author_read(tac_fd, &arep);
-            if (ret == LIBTAC_STATUS_PROTOCOL_ERR)
-                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed with"
-                    " protocol error (incorrect shared secret?) user %s",
-                    nssname, tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name);
-            else if (ret < 0) /*  ret == 1 OK transaction, use arep.status */
-                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed (%d) for"
-                    " user %s: %m", nssname,
-                    tac_ntop(tac_srv[srvr].addr->ai_addr), ret, pb->name);
-        }
-
-        tac_free_attrib(&attr);
-        close(tac_fd);
-        if(ret < 0)
-            continue;
+    // connect to all TACACS server in parallel
+    // after any server authorized and set tacacs_auth_success to true, other connection will stop.
+    for(srvr=0; srvr < tac_srv_no; srvr++) {
+        pthread_t thread;
+        tacacs_thread_args_t* args = malloc(sizeof(tacacs_thread_args_t));
+        args->name = pb->name;
+        args->srvr = srvr;
+        args->remote_addr = remote_addr;
+        args->current_tty = current_tty;
+        pthread_create(&thread, NULL, lookup_tacacs_user_thread, args);
+    }
 
-        if(arep.status == AUTHOR_STATUS_PASS_ADD ||
-           arep.status == AUTHOR_STATUS_PASS_REPL) {
-            ret = got_tacacs_user(arep.attr, pb);
-            if(debug)
-                syslog(LOG_DEBUG, "%s: TACACS+ server %s successful for user %s."
-                    " local lookup %s", nssname,
-                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
-                    ret == 0?"OK":"no match");
-            done = 1; /* break out of loop after arep cleanup */
-        }
-        else {
-            ret = 1; /*  in case last server */
-            if(debug)
-                syslog(LOG_DEBUG, "%s: TACACS+ server %s replies user %s"
-                    " invalid (%d)", nssname,
-                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
-                    arep.status);
+    // wait until one TACACS thread succeeded or all TACACS thread failed.
+    while (!tacacs_auth_success && (finish_server_count < tac_srv_no)) {
+        usleep(1000);
+    }
 
-                    if (arep.status == TAC_PLUS_AUTHOR_STATUS_FAIL) {
-                        done = 1; /* break out of loop after server reject user */
-                    }
-        }
-        if(arep.msg)
-            free(arep.msg);
-        if(arep.attr) /* free returned attributes */
-            tac_free_attrib(&arep.attr);
+    if (tacacs_auth_success) {
+        ret = got_tacacs_user(pb, server_priv_level);
+        if(debug)
+            syslog(LOG_DEBUG, "%s: TACACS+ successful for user %s."
+                " local lookup %s", nssname, pb->name,
+                ret == 0?"OK":"no match");
+    }
+    else if (finish_server_count == tac_srv_no) {
+        ret = 1; /*  All tacacs server connect failed */
+        if(debug)
+            syslog(LOG_DEBUG, "%s: all TACACS+ server replies user %s"
+                " invalid", nssname, pb->name);
     }
 
     return ret;
-- 
2.39.0.windows.2

