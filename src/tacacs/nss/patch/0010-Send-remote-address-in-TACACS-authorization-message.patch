From aa99eb2c0c7ccb4e434524cba6fa1bcc85d4256b Mon Sep 17 00:00:00 2001
From: liuh-80 <liuh@microsoft.com>
Date: Wed, 28 Sep 2022 17:12:18 +0800
Subject: [PATCH] Send remote address in TACACS+ authorization message.

---
 nss_tacplus.c | 55 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 54 insertions(+), 1 deletion(-)

diff --git a/nss_tacplus.c b/nss_tacplus.c
index 2de00a6..8cd1770 100644
--- a/nss_tacplus.c
+++ b/nss_tacplus.c
@@ -33,6 +33,7 @@
 #include <ctype.h>
 #include <netdb.h>
 #include <nss.h>
+#include <limits.h>
 
 #include <libtac/libtac.h>
 
@@ -717,6 +718,52 @@ connect_tacacs(struct tac_attrib **attr, int srvr)
     return fd;
 }
 
+/*
+ * Get current SSH session remote address from environment variable
+ */
+int get_remote_address(char* dst, socklen_t size)
+{
+    memset(dst, 0, size);
+    char format[32];
+    snprintf(format, sizeof(format), "%%%ds", (int)(size-1));
+
+    // SSHD will create environment variable SSH_CONNECTION after user session created.
+    const char* ssh_connection = getenv("SSH_CONNECTION");
+    if (ssh_connection != NULL) {
+        // The first part of $SSH_CONNECTION is client IP address
+        sscanf(ssh_connection, format, dst);
+        if (debug) {
+            syslog(LOG_DEBUG, "%s: remote address=%s, SSH_CONNECTION=%s", nssname, ssh_connection, dst);
+        }
+        return 0;
+    }
+
+    if (debug) {
+        syslog(LOG_DEBUG, "%s: can't get environment variable SSH_CONNECTION, errno=%d", nssname, errno);
+    }
+
+    // Before user session created, SSHD will create environment variable SSH_REMOTE_IP.
+    const char* ssh_remote_ip = getenv("SSH_REMOTE_IP");
+    if (ssh_remote_ip != NULL) {
+        int remote_ip_length = strlen(ssh_remote_ip);
+        if (remote_ip_length >= size) {
+            // dst buffer does not have enough space.
+            return 1;
+        }
+
+        strncpy(dst, ssh_remote_ip, size);
+        if (debug) {
+            syslog(LOG_DEBUG, "%s: remote address=%s", nssname, dst);
+        }
+        return 0;
+    }
+
+    if (debug) {
+        syslog(LOG_DEBUG, "%s: can't get environment variable SSH_REMOTE_IP, errno=%d", nssname, errno);
+    }
+
+    return 2;
+}
 
 /*
  * lookup the user on a TACACS server.  Returns 0 on successful lookup, else 1
@@ -735,6 +781,13 @@ lookup_tacacs_user(struct pwbuf *pb)
     int ret = 1, done = 0;
     struct tac_attrib *attr;
     int tac_fd, srvr;
+    char remote_addr[INET6_ADDRSTRLEN];
+    const char* current_tty = getenv("SSH_TTY");
+
+    int result = get_remote_address(remote_addr, sizeof(remote_addr));
+    if (result && debug) {
+        syslog(LOG_DEBUG, "%s: can't get remote address from environment variable, result=%d", nssname, result);
+    }
 
     for(srvr=0; srvr < tac_srv_no && !done; srvr++) {
         arep.msg = NULL;
@@ -748,7 +801,7 @@ lookup_tacacs_user(struct pwbuf *pb)
                     tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", tac_fd);
             continue;
         }
-        ret = tac_author_send(tac_fd, pb->name, "", "", attr);
+        ret = tac_author_send(tac_fd, pb->name, current_tty != NULL ? (char *)current_tty : "", remote_addr, attr);
         if(ret < 0) {
             if(debug)
                 syslog(LOG_WARNING, "%s: TACACS+ server %s send failed (%d) for"
-- 
2.37.1.windows.1

