From af404e6b4e2eddf529aad5f20ba6e0ee816ffdbf Mon Sep 17 00:00:00 2001
From: Liuqu <chenchen.qcc@alibaba-inc.com>
Date: Thu, 5 Oct 2017 21:27:06 -0700
Subject: [PATCH 2/2] Add nss tacplus plugin

---
 Makefile.am                             |  36 ++
 configure.ac                            |   1 +
 debian/control                          |   8 +-
 debian/libnss-tacplus.install           |   2 +
 debian/libnss-tacplus.lintian-overrides |   8 +
 debian/libnss-tacplus.postinst          |  32 ++
 debian/libnss-tacplus.symbols           |   2 +
 debian/rules                            |   2 +
 nss_tacplus.c                           | 821 ++++++++++++++++++++++++++++++++
 tacplus_nss.conf                        |  45 ++
 10 files changed, 956 insertions(+), 1 deletion(-)
 create mode 100644 debian/libnss-tacplus.install
 create mode 100644 debian/libnss-tacplus.lintian-overrides
 create mode 100644 debian/libnss-tacplus.postinst
 create mode 100644 debian/libnss-tacplus.symbols
 create mode 100644 nss_tacplus.c
 create mode 100644 tacplus_nss.conf

diff --git a/Makefile.am b/Makefile.am
index 7e09e98..ac3e1f9 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -64,6 +64,18 @@ pam_tacplus_la_CFLAGS = $(AM_CFLAGS) -I $(top_srcdir)/libtac/include -I $(top_sr
 pam_tacplus_la_LDFLAGS = -module -avoid-version
 pam_tacplus_la_LIBADD = libtac.la
 
+libnssdir = /lib/$(DEB_HOST_MULTIARCH)
+libnss_LTLIBRARIES = libnss_tacplus.la
+
+libnss_tacplus_la_SOURCES = \
+nss_tacplus.c
+
+libnss_tacplus_la_CFLAGS = $(AM_CFLAGS)
+# Version 2.0 because that's the NSS module version, and they must match
+libnss_tacplus_la_LDFLAGS = -module -version-info 2:0:0 -shared
+libnss_tacplus_la_LIBADD = -ltac
+
+
 EXTRA_DIST = pam_tacplus.spec libtac.pc.in
 if DOC
 dist_doc_DATA = sample.pam README.md AUTHORS ChangeLog
@@ -82,3 +94,27 @@ coverity:
 	tar cvzf build.tar.gz cov-int/
 
 .PHONY: coverity
+
+MULTI_OS_DIRECTORY=$(shell $(CC) $(CFLAGS) -print-multiarch)
+# This and the install rules using it are copied from libnss-ldap-264
+LIBC_VERS = $(shell ls /lib/$(MULTI_OS_DIRECTORY)/libc-*.so | sed -e '1s|.*libc-\(.*\)\.so|\1|')
+NSS_TACPLUS_LIBC_VERSIONED = libnss_tacplus-$(LIBC_VERS).so
+
+NSS_VERS = $(shell ls /lib/$(MULTI_OS_DIRECTORY)/libnss_files.so.? | sed -e '1s|.*libnss_files\.so\.\(.*\)|\1|')
+NSS_TACPLUS_NSS_VERSIONED = libnss_tacplus.so.$(NSS_VERS)
+
+# strip all but the NSS entry point, to avoid symbol pollution
+# nobody will link against this plugin, so no need for .la
+# for NSS, we don't need to install the libnss_tacplus.so.2.0.0
+# and don't want libnss_tacplus.so either since the library is a plugin.
+# libtool installs both automatically, so we remove them.
+# Copying debian and installing main copy as file with libc version,
+# and the .so.2 version as a symlink to the libc versioned file
+install-data-hook:
+	rm -f $(DESTDIR)$(libnssdir)/libnss_tacplus.la
+	rm -f $(DESTDIR)$(libnssdir)/libnss_tacplus.so $(DESTDIR)$(libnssdir)/libnss_tacplus.so.2.0.0
+	$(mkinstalldirs) $(DESTDIR)$(libnssdir) $(DESTDIR)$(sysconfdir)
+	cd .libs && $(INSTALL_PROGRAM) libnss_tacplus.so $(DESTDIR)$(libnssdir)/$(NSS_TACPLUS_LIBC_VERSIONED)
+	$(STRIP) --keep-symbol=_nss_tacplus_getpwnam_r $(DESTDIR)$(libnssdir)/$(NSS_TACPLUS_LIBC_VERSIONED)
+	cd $(DESTDIR)$(libnssdir); ln -sf $(NSS_TACPLUS_LIBC_VERSIONED) $(NSS_TACPLUS_NSS_VERSIONED)
+	${INSTALL} -m 644 tacplus_nss.conf $(DESTDIR)$(sysconfdir)
diff --git a/configure.ac b/configure.ac
index e34c769..bd683a8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -49,6 +49,7 @@ dnl Checks for header files.
 AC_HEADER_STDC
 AC_CHECK_HEADERS([arpa/inet.h fcntl.h netdb.h netinet/in.h stdlib.h string.h strings.h sys/socket.h sys/time.h ])
 AC_CHECK_HEADERS([syslog.h unistd.h openssl/md5.h openssl/rand.h linux/random.h sys/random.h])
+AC_CHECK_HEADERS([nss.h])
 AC_CHECK_HEADER(security/pam_appl.h, [], [AC_MSG_ERROR([PAM libraries missing. Install with "yum install pam-devel" or "apt-get install libpam-dev".])] )
 AM_CONDITIONAL(MY_MD5, [test "$ac_cv_header_openssl_md5_h" = "no" ])
 AM_CONDITIONAL(TACC, [test "$ac_cv_lib_crypto_RAND_pseudo_bytes" = "yes"])
diff --git a/debian/control b/debian/control
index 2e851b1..7e914e3 100644
--- a/debian/control
+++ b/debian/control
@@ -2,7 +2,7 @@ Source: libpam-tacplus
 Section: admin
 Priority: extra
 Maintainer: Jeroen Nijhof <jeroen@jeroennijhof.nl>
-Build-Depends: debhelper (>= 9), libpam-dev, dh-autoreconf, autoconf-archive
+Build-Depends: debhelper (>= 9), libpam-dev, dh-autoreconf
 Standards-Version: 3.9.5
 Homepage: https://github.com/jeroennijhof/pam_tacplus
 
@@ -34,3 +34,9 @@ Depends: ${misc:Depends}, libtac2 (= ${binary:Version}), libc6-dev|libc-dev
 Description: Development files for TACACS+ protocol library 
  Contains C header files and development files for libtac, a TACACS+ protocol
  implementation.
+
+Package: libnss-tacplus
+Architecture: any
+Depends: ${shlibs:Depends}, ${misc:Depends}, libtac2 (= ${binary:Version})
+Description: NSS module for TACACS+ authentication without local passwd entry
+    Performs getpwname lookups via NSS for users logged in via tacacs authentication.
diff --git a/debian/libnss-tacplus.install b/debian/libnss-tacplus.install
new file mode 100644
index 0000000..9e88b1b
--- /dev/null
+++ b/debian/libnss-tacplus.install
@@ -0,0 +1,2 @@
+lib/*/*.so*
+etc/tacplus_nss.conf
diff --git a/debian/libnss-tacplus.lintian-overrides b/debian/libnss-tacplus.lintian-overrides
new file mode 100644
index 0000000..4ac1cba
--- /dev/null
+++ b/debian/libnss-tacplus.lintian-overrides
@@ -0,0 +1,8 @@
+libnss-tacplus binary package-name-doesnt-match-sonames libnss-tacplus2
+libnss-tacplus package-name-doesnt-match-sonames libnss-tacplus2
+libnss-tacplus source native-package-with-dash-version
+libnss-tacplus source diff-contains-git-control-dir .git
+libnss-tacplus source unsupported-source-format 3.0 (git)
+libnss-tacplus source changelog-should-mention-nmu
+libnss-tacplus source source-nmu-has-incorrect-version-number 1.0.1-1
+libnss-tacplus new-package-should-close-itp-bu
diff --git a/debian/libnss-tacplus.postinst b/debian/libnss-tacplus.postinst
new file mode 100644
index 0000000..b19206e
--- /dev/null
+++ b/debian/libnss-tacplus.postinst
@@ -0,0 +1,32 @@
+#!/bin/sh
+# postinst script for libnss-tacplus
+#
+# see: dh_installdeb(1)
+
+set -e
+
+case "$1" in
+    configure)
+    ;;
+
+    abort-upgrade|abort-remove|abort-deconfigure)
+    ;;
+
+    *)
+        echo "postinst called with unknown argument \`$1'" >&2
+        exit 1
+    ;;
+esac
+
+# Add tacplus to /etc/nsswitch.conf, since it's necessary
+# for this package, and won't break anything else.  Do nothing
+# if tacplus is already present in the passwd line
+#if [ -e "/etc/nsswitch.conf" ]; then
+#    sed -i -e '/tacplus/b' \
+#        -e '/^passwd/s/compat/& tacplus/' /etc/nsswitch.conf
+#fi
+# Only when tacacs enable, tacplus is inserted in nsswitch.conf
+
+#DEBHELPER#
+
+exit 0
diff --git a/debian/libnss-tacplus.symbols b/debian/libnss-tacplus.symbols
new file mode 100644
index 0000000..f476e7d
--- /dev/null
+++ b/debian/libnss-tacplus.symbols
@@ -0,0 +1,2 @@
+libnss_tacplus.so.2 libnss-tacplus #MINVER#
+ _nss_tacplus_getpwnam_r@Base 1.0.1
diff --git a/debian/rules b/debian/rules
index 0fa1f54..363343e 100755
--- a/debian/rules
+++ b/debian/rules
@@ -22,5 +22,7 @@ override_dh_auto_configure:
 override_dh_install:
 	mkdir -p debian/libpam-tacplus/usr/share/pam-configs
 	cp debian/tacplus debian/libpam-tacplus/usr/share/pam-configs/
+	mkdir -p debian/libnss-tacplus/etc
+	cp debian/tmp/etc/tacplus_nss.conf debian/libnss-tacplus/etc/
 	dh_install
 
diff --git a/nss_tacplus.c b/nss_tacplus.c
new file mode 100644
index 0000000..48b7062
--- /dev/null
+++ b/nss_tacplus.c
@@ -0,0 +1,821 @@
+/*
+ * Copyright (C) 2014, 2015, 2016 Cumulus Networks, Inc.
+ * Copyright (C) 2017 Chenchen Qi
+ * All rights reserved.
+ * Author: Dave Olson <olson@cumulusnetworks.com>
+ *         Chenchen Qi <chenchen.qcc@alibaba-inc.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program - see the file COPYING.
+ */
+
+/*
+ * This plugin implements getpwnam_r for NSS over TACACS+.
+ */
+
+#include <string.h>
+#include <syslog.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <pwd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <ctype.h>
+#include <netdb.h>
+#include <nss.h>
+
+#include <libtac/include/libtac.h>
+
+#define MIN_TACACS_USER_PRIV (1)
+#define MAX_TACACS_USER_PRIV (15)
+
+static const char *nssname = "nss_tacplus"; /* for syslogs */
+static const char *config_file = "/etc/tacplus_nss.conf";
+static const char *user_conf = "/etc/tacplus_user";
+static const char *user_conf_tmp = "/etc/tacplus_user_tmp";
+
+/*
+ * pwbuf is used to reduce number of arguments passed around; the strings in
+ * the passwd struct need to point into this buffer.
+ */
+struct pwbuf {
+    char *name;
+    char *buf;
+    struct passwd *pw;
+    int *errnop;
+    size_t buflen;
+};
+
+typedef struct {
+    struct addrinfo *addr;
+    char *key;
+    int timeout;
+}tacplus_server_t;
+
+typedef struct {
+    char *info;
+    int gid;
+    char *secondary_grp;
+    char *shell;
+}useradd_info_t;
+
+/* set from configuration file parsing */
+static tacplus_server_t tac_srv[TAC_PLUS_MAXSERVERS];
+static int tac_srv_no;
+/* useradd_grp_list[0] is not used, it is convenient for use privilege
+ * value as array index directly */
+static useradd_info_t useradd_grp_list[MAX_TACACS_USER_PRIV + 1];
+
+static char *tac_service = "shell";
+static char *tac_protocol = "ssh";
+static bool debug = false;
+static bool many_to_one = false;
+
+static int parse_tac_server(char *srv_buf)
+{
+    char *token;
+    char delim[] = " ,\t\n\r\f";
+
+    token = strsep(&srv_buf, delim);
+    while(token) {
+        if('\0' != token) {
+            if(!strncmp(token, "server=", 7)) {
+                struct addrinfo hints, *server;
+                int rv;
+                char *srv, *port;
+
+                memset(&hints, 0, sizeof hints);
+                hints.ai_family = AF_UNSPEC;
+                hints.ai_socktype = SOCK_STREAM;
+
+                srv = token + 7;
+                port = strchr(srv, ':');
+                if(port) {
+                    *port = '\0';
+                    port++;
+                }
+
+                if((rv = getaddrinfo(srv, (port == NULL) ? "49" : port, &hints,
+                    &server)) == 0) {
+                    if(server) {
+                        if(tac_srv[tac_srv_no].addr)
+                            freeaddrinfo(tac_srv[tac_srv_no].addr);
+                        if(tac_srv[tac_srv_no].key)
+                            free(tac_srv[tac_srv_no].key);
+                        memset(tac_srv + tac_srv_no, 0, sizeof(tacplus_server_t));
+
+                        tac_srv[tac_srv_no].addr = server;
+                    }
+                    else {
+                        syslog(LOG_ERR, "%s: server NULL", nssname);
+                    }
+                }
+                else {
+                    syslog(LOG_ERR, "%s: invalid server: %s (getaddrinfo: %s)",
+                        nssname, srv, gai_strerror(rv));
+                    return -1;
+                }
+            }
+            else if(!strncmp(token, "secret=", 7)) {
+                if(tac_srv[tac_srv_no].key)
+                    free(tac_srv[tac_srv_no].key);
+                tac_srv[tac_srv_no].key = strdup(token + 7);
+            }
+            else if(!strncmp(token, "timeout=", 8)) {
+                tac_srv[tac_srv_no].timeout = (int)strtoul(token + 8, NULL, 0);
+                if(tac_srv[tac_srv_no].timeout < 0)
+                    tac_srv[tac_srv_no].timeout = 0;
+                /* Limit timeout to make sure upper application not wait
+                 * for a long time*/
+                if(tac_srv[tac_srv_no].timeout > 5)
+                    tac_srv[tac_srv_no].timeout = 5;
+            }
+        }
+        token = strsep(&srv_buf, delim);
+    }
+
+    return 0;
+}
+
+static int parse_user_priv(char *buf)
+{
+    char *token;
+    char delim[] = ";\n\r";
+    int priv = 0;
+    int gid = 0;
+    char *info = NULL;
+    char *group = NULL;
+    char *shell = NULL;
+
+    token = strsep(&buf, delim);
+    while(token) {
+        if('\0' != token) {
+            if(!strncmp(token, "user_priv=", 10)) {
+                priv = (int)strtoul(token + 10, NULL, 0);
+                if(priv > MAX_TACACS_USER_PRIV || priv < MIN_TACACS_USER_PRIV)
+                {
+                    priv = 0;
+                    syslog(LOG_WARNING, "%s: user_priv %d out of range",
+                        nssname, priv);
+                }
+            }
+            else if(!strncmp(token, "pw_info=", 8)) {
+                if(!info)
+                    info = strdup(token + 8);
+            }
+            else if(!strncmp(token, "gid=", 4)) {
+                gid = (int)strtoul(token + 4, NULL, 0);
+            }
+            else if(!strncmp(token, "group=", 6)) {
+                if(!group)
+                    group = strdup(token + 6);
+            }
+            else if(!strncmp(token, "shell=", 6)) {
+                if(!shell)
+                    shell = strdup(token + 6);
+            }
+        }
+        token = strsep(&buf, delim);
+    }
+
+    if(priv && gid && info && group && shell) {
+        useradd_info_t *user = &useradd_grp_list[priv];
+        if(user->info)
+            free(user->info);
+        if(user->secondary_grp)
+            free(user->secondary_grp);
+        if(user->shell)
+            free(user->shell);
+
+        user->gid = gid;
+        user->info = info;
+        user->secondary_grp = group;
+        user->shell = shell;
+        syslog(LOG_DEBUG, "%s: user_priv=%d info=%s gid=%d group=%s shell=%s",
+                nssname, priv, info, gid, group, shell);
+    }
+    else {
+        if(info)
+            free(info);
+        if(group)
+            free(group);
+        if(shell)
+            free(shell);
+    }
+
+    return 0;
+}
+
+static void init_useradd_info()
+{
+    useradd_info_t *user;
+
+    user = &useradd_grp_list[MIN_TACACS_USER_PRIV];
+    user->gid = 999;
+    user->info = strdup("remote_user");
+    user->secondary_grp = strdup("docker");
+    user->shell = strdup("/bin/bash");
+
+    user = &useradd_grp_list[MAX_TACACS_USER_PRIV];
+    user->gid = 1000;
+    user->info = strdup("remote_user_su");
+    user->secondary_grp = strdup("sudo,docker");
+    user->shell = strdup("/bin/bash");
+}
+
+static int parse_config(const char *file)
+{
+    FILE *fp;
+    char buf[512] = {0};
+
+    init_useradd_info();
+    fp = fopen(file, "r");
+    if(!fp) {
+        syslog(LOG_ERR, "%s: %s fopen failed", nssname, file);
+        return NSS_STATUS_UNAVAIL;
+    }
+
+    debug = false;
+    tac_srv_no = 0;
+    while(fgets(buf, sizeof buf, fp)) {
+        if('#' == *buf || isspace(*buf))
+            continue;
+
+        if(!strncmp(buf, "debug=on", 8)) {
+            debug = true;
+        }
+        else if(!strncmp(buf, "many_to_one=y", 13)) {
+            many_to_one = true;
+        }
+        else if(!strncmp(buf, "user_priv=", 10)) {
+            parse_user_priv(buf);
+        }
+        else if(!strncmp(buf, "server=", 7)) {
+            if(TAC_PLUS_MAXSERVERS <= tac_srv_no) {
+                syslog(LOG_ERR, "%s: tac server num is more than %d",
+                    nssname, TAC_PLUS_MAXSERVERS);
+            }
+            else if(0 == parse_tac_server(buf))
+                ++tac_srv_no;
+        }
+    }
+    fclose(fp);
+
+    if(debug) {
+        int n;
+        useradd_info_t *user;
+
+        for(n = 0; n < tac_srv_no; n++) {
+            syslog(LOG_DEBUG, "%s: server[%d] { addr=%s, key=%s, timeout=%d }",
+                        nssname, n, tac_ntop(tac_srv[n].addr->ai_addr),
+                        tac_srv[n].key, tac_srv[n].timeout);
+        }
+        syslog(LOG_DEBUG, "%s: many_to_one %s", nssname, 1 == many_to_one
+                    ? "enable" : "disable");
+        for(n = MIN_TACACS_USER_PRIV; n <= MAX_TACACS_USER_PRIV; n++) {
+            user = &useradd_grp_list[n];
+            if(user) {
+                syslog(LOG_DEBUG, "%s: user_priv[%d] { gid=%d, info=%s, group=%s, shell=%s }",
+                            nssname, n, user->gid, NULL == user->info ? "NULL" : user->info,
+                            NULL == user->secondary_grp ? "NULL" : user->secondary_grp,
+                            NULL == user->shell ? "NULL" : user->shell);
+            }
+        }
+    }
+
+    return 0;
+}
+
+/*
+ * copy a passwd structure and it's strings, using the provided buffer
+ * for the strings.
+ * if usename is non-NULL, use that, rather than pw_name in srcpw, so we can
+ * preserve the original requested name (this is part of the tacacs remapping).
+ * For strings, if pointer is null, use an empty string.
+ * Returns 0 if everything fit, otherwise 1.
+ */
+static int
+pwcopy(char *buf, size_t len, struct passwd *srcpw, struct passwd *destpw,
+       const char *usename)
+{
+    size_t needlen;
+    int cnt;
+
+    if(!usename)
+        usename = srcpw->pw_name;
+
+    needlen = usename ? strlen(usename) + 1 : 1 +
+        srcpw->pw_dir ? strlen(srcpw->pw_dir) + 1 : 1 +
+        srcpw->pw_gecos ? strlen(srcpw->pw_gecos) + 1 : 1 +
+        srcpw->pw_shell ? strlen(srcpw->pw_shell) + 1 : 1 +
+        srcpw->pw_passwd ? strlen(srcpw->pw_passwd) + 1 : 1;
+    if(needlen > len) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s provided password buffer too small (%ld<%ld)",
+                nssname, (long)len, (long)needlen);
+        return 1;
+    }
+
+    destpw->pw_uid = srcpw->pw_uid;
+    destpw->pw_gid = srcpw->pw_gid;
+
+    cnt = snprintf(buf, len, "%s", usename ? usename : "");
+    destpw->pw_name = buf;
+    cnt++; /* allow for null byte also */
+    buf += cnt;
+    len -= cnt;
+    /* If many-to-one mapping, set pw_passwd "a" for pam_account success */
+    cnt = snprintf(buf, len, "%s", 0 == many_to_one ? "x" : "a");
+    destpw->pw_passwd = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_shell ? srcpw->pw_shell : "");
+    destpw->pw_shell = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_gecos ? srcpw->pw_gecos : "");
+    destpw->pw_gecos = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+    cnt = snprintf(buf, len, "%s", srcpw->pw_dir ? srcpw->pw_dir : "");
+    destpw->pw_dir = buf;
+    cnt++;
+    buf += cnt;
+    len -= cnt;
+
+    return 0;
+}
+
+/*
+ * If useradd finished, user name should be deleted in conf.
+ */
+static int delete_conf_line(const char *name)
+{
+    FILE *fp, *fp_tmp;
+    char line[128];
+    char del_line[128];
+    int len = strlen(name);
+
+    if(len >= 126) {
+        syslog(LOG_ERR, "%s: user name %s out of range 128", nssname, name);
+        return -1;
+    }
+    else {
+        snprintf(del_line, 128, "%s\n", name);
+    }
+
+    fp = fopen(user_conf, "r");
+    if(!fp) {
+        syslog(LOG_ERR, "%s: %s fopen failed", nssname, user_conf);
+        return NSS_STATUS_UNAVAIL;
+    }
+    fp_tmp = fopen(user_conf_tmp, "w");
+    if(!fp_tmp) {
+        syslog(LOG_ERR, "%s: %s fopen failed", nssname, user_conf_tmp);
+        fclose(fp);
+        return NSS_STATUS_UNAVAIL;
+    }
+
+    while(fgets(line, sizeof line, fp)) {
+        if(strcmp(line, del_line)) {
+            fprintf(fp_tmp, "%s", line);
+        }
+    }
+    fclose(fp_tmp);
+    fclose(fp);
+
+    if(0 != remove(user_conf) || 0 != rename(user_conf_tmp, user_conf)) {
+        syslog(LOG_ERR, "%s: %s rewrite failed", nssname, user_conf);
+        return -1;
+    }
+
+    return 0;
+}
+
+/*
+ * If not found in local, look up in tacacs user conf. If user name is not in
+ * conf, it will be written in conf and created by command 'useradd'. When
+ * useradd command use getpwnam(), it will return when username found in conf.
+ */
+static int create_local_user(const char *name, int level)
+{
+    FILE *fp;
+    useradd_info_t *user;
+    char buf[512];
+    int len = 512;
+    int lvl, cnt;
+    bool found = false;
+
+    fp = fopen(user_conf, "ab+");
+    if(!fp) {
+        syslog(LOG_ERR, "%s: %s fopen failed", nssname, user_conf);
+        return -1;
+    }
+
+    while(fgets(buf, sizeof buf, fp)) {
+        if('#' == *buf || isspace(*buf))
+            continue;
+        // Delete line break
+        cnt = strlen(buf);
+        buf[cnt - 1] = '\0';
+        if(!strcmp(buf, name)) {
+            found = true;
+            break;
+        }
+    }
+
+    /*
+     * If user is found in user_conf, it means that getpwnam is called by
+     * useradd in this NSS module.
+     */
+    if(found) {
+        if(debug)
+            syslog(LOG_DEBUG, "%s: %s found in %s", nssname, name, user_conf);
+        fclose(fp);
+        return 1;
+    }
+
+    snprintf(buf, len, "%s\n", name);
+    if(EOF == fputs(buf, fp)) {
+        syslog(LOG_ERR, "%s: %s write local user failed", nssname, name);
+        fclose(fp);
+        return -1;
+    }
+    fclose(fp);
+
+    lvl = level;
+    while(lvl >= MIN_TACACS_USER_PRIV) {
+        user = &useradd_grp_list[lvl];
+        if(user->info && user->secondary_grp && user->shell) {
+            snprintf(buf, len, "useradd -G %s \"%s\" -g %d -c \"%s\" -d /home/%s -m -s %s",
+                    user->secondary_grp, name, user->gid, user->info, name, user->shell);
+            fp = popen(buf, "r");
+            if(!fp || -1 == pclose(fp)) {
+                syslog(LOG_ERR, "%s: useradd popen failed errno=%d %s",
+                        nssname, errno, strerror(errno));
+                delete_conf_line(name);
+                return -1;
+            }
+            if(debug)
+                syslog(LOG_DEBUG, "%s: create local user %s success", nssname, name);
+            delete_conf_line(name);
+            return 0;
+        }
+        lvl--;
+    }
+
+    return -1;
+}
+
+/*
+ * Lookup user in /etc/passwd, and fill up passwd info if found.
+ */
+static int lookup_pw_local(char* username, struct pwbuf *pb, bool *found)
+{
+    FILE *fp;
+    struct passwd *pw = NULL;
+    int ret = 0;
+
+    if(!username) {
+        syslog(LOG_ERR, "%s: username invalid in check passwd", nssname);
+        return -1;
+    }
+
+    fp = fopen("/etc/passwd", "r");
+    if(!fp) {
+        syslog(LOG_ERR, "%s: /etc/passwd fopen failed", nssname);
+        return -1;
+    }
+
+    while(0 != (pw = fgetpwent(fp))) {
+        if(!strcmp(pw->pw_name, username)) {
+            *found = true;
+            ret = pwcopy(pb->buf, pb->buflen, pw, pb->pw, username);
+            if(ret)
+                *pb->errnop = ERANGE;
+            break;
+        }
+    }
+    fclose(fp);
+    return ret;
+}
+
+/*
+ * Lookup local user passwd info for TACACS+ user. If not found, local user will
+ * be created by user mapping strategy.
+ */
+static int lookup_user_pw(struct pwbuf *pb, int level)
+{
+    char *username = NULL;
+    char buf[128];
+    int len = 128;
+    bool found = false;
+    int ret = 0;
+
+    if(level < MIN_TACACS_USER_PRIV || level > MAX_TACACS_USER_PRIV) {
+        syslog(LOG_ERR, "%s: TACACS+ user %s privilege %d invalid", nssname, pb->name, level);
+        return -1;
+    }
+
+    /*
+     * If many-to-one user mapping disable, create local user for each TACACS+ user
+     * The username of local user and TACACS+ user is the same. If many-to-one enable,
+     * look up the mapped local user name and passwd info.
+     */
+    if(0 == many_to_one) {
+        username = pb->name;
+    }
+    else {
+        int lvl = level;
+        useradd_info_t *user;
+
+        while(lvl >= MIN_TACACS_USER_PRIV) {
+            user = &useradd_grp_list[lvl];
+            if(user->info && user->secondary_grp && user->shell) {
+                snprintf(buf, len, "%s", user->info);
+                username = buf;
+                if(debug)
+                    syslog(LOG_DEBUG, "%s: %s mapping local user %s", nssname,
+                        pb->name, username);
+                break;
+            }
+            lvl--;
+        }
+    }
+
+    ret = lookup_pw_local(username, pb, &found);
+    if(debug)
+        syslog(LOG_DEBUG, "%s: %s passwd %s found in local", nssname, username,
+            found ? "is" : "isn't");
+    if(0 != ret || found)
+        return ret;
+
+    if(0 != create_local_user(username, level))
+        return -1;
+
+    ret = lookup_pw_local(username, pb, &found);
+    if(0 == ret && !found) {
+        syslog(LOG_ERR, "%s: %s not found in local after useradd",  nssname, pb->name);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/*
+ * we got the user back.  Go through the attributes, find their privilege
+ * level, map to the local user, fill in the data, etc.
+ * Returns 0 on success, 1 on errors.
+ */
+static int
+got_tacacs_user(struct tac_attrib *attr, struct pwbuf *pb)
+{
+    unsigned long priv_level = 0;
+    int ret;
+
+    while(attr != NULL)  {
+        /* we are looking for the privilege attribute, can be in several forms,
+         * typically priv-lvl= or priv_lvl= */
+        if(strncasecmp(attr->attr, "priv", 4) == 0) {
+            char *ok, *val;
+
+            for(val=attr->attr; *val && *val != '*' && *val != '='; val++)
+                ;
+            if(!*val)
+                continue;
+            val++;
+
+            priv_level = strtoul(val, &ok, 0);
+
+            /* if this fails, we leave priv_level at 0, which is
+             * least privileged, so that's OK, but at least report it
+             */
+            if(debug)
+                syslog(LOG_DEBUG, "%s: privilege for %s, (%lu)",
+                    nssname, pb->name, priv_level);
+        }
+        attr = attr->next;
+    }
+
+    ret = lookup_user_pw(pb, priv_level);
+    if(!ret && debug)
+        syslog(LOG_DEBUG, "%s: pw_name=%s, pw_passwd=%s, pw_shell=%s, dir=%s",
+                nssname, pb->pw->pw_name, pb->pw->pw_passwd, pb->pw->pw_shell,
+                pb->pw->pw_dir);
+
+    return ret;
+}
+
+/*
+ * Attempt to connect to the requested tacacs server.
+ * Returns fd for connection, or -1 on failure
+ */
+
+static int
+connect_tacacs(struct tac_attrib **attr, int srvr)
+{
+    int fd;
+
+    if(!*tac_service) /* reported at config file processing */
+        return -1;
+
+    fd = tac_connect_single(tac_srv[srvr].addr, tac_srv[srvr].key, NULL,
+                            tac_srv[srvr].timeout);
+    if(fd >= 0) {
+        *attr = NULL; /* so tac_add_attr() allocates memory */
+        tac_add_attrib(attr, "service", tac_service);
+        if(tac_protocol[0])
+            tac_add_attrib(attr, "protocol", tac_protocol);
+        /* empty cmd is required, at least for linux tac_plus */
+        tac_add_attrib(attr, "cmd", "");
+    }
+    return fd;
+}
+
+
+/*
+ * lookup the user on a TACACS server.  Returns 0 on successful lookup, else 1
+ *
+ * Make a new connection each time, because libtac is single threaded and
+ * doesn't support multiple connects at the same time due to use of globals,
+ * and doesn't have support for persistent connections.   That's fixable, but
+ * not worth the effort at this point.
+ * Step through all servers until success or end of list, because different
+ * servers can have different databases.
+ */
+static int
+lookup_tacacs_user(struct pwbuf *pb)
+{
+    struct areply arep;
+    int ret = 1, done = 0;
+    struct tac_attrib *attr;
+    int tac_fd, srvr;
+
+    for(srvr=0; srvr < tac_srv_no && !done; srvr++) {
+        arep.msg = NULL;
+        arep.attr = NULL;
+        arep.status = TAC_PLUS_AUTHOR_STATUS_ERROR; /* if author_send fails */
+        tac_fd = connect_tacacs(&attr, srvr);
+        if (tac_fd < 0) {
+            if(debug)
+                syslog(LOG_WARNING, "%s: failed to connect TACACS+ server %s,"
+                    " ret=%d: %m", nssname, tac_srv[srvr].addr ?
+                    tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", tac_fd);
+            continue;
+        }
+        ret = tac_author_send(tac_fd, pb->name, "", "", attr);
+        if(ret < 0) {
+            if(debug)
+                syslog(LOG_WARNING, "%s: TACACS+ server %s send failed (%d) for"
+                    " user %s: %m", nssname, tac_srv[srvr].addr ?
+                    tac_ntop(tac_srv[srvr].addr->ai_addr) : "unknown", ret,
+                    pb->name);
+        }
+        else  {
+            errno = 0;
+            ret = tac_author_read(tac_fd, &arep);
+            if (ret == LIBTAC_STATUS_PROTOCOL_ERR)
+                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed with"
+                    " protocol error (incorrect shared secret?) user %s",
+                    nssname, tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name);
+            else if (ret < 0) /*  ret == 1 OK transaction, use arep.status */
+                syslog(LOG_WARNING, "%s: TACACS+ server %s read failed (%d) for"
+                    " user %s: %m", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), ret, pb->name);
+        }
+
+        tac_free_attrib(&attr);
+        close(tac_fd);
+        if(ret < 0)
+            continue;
+
+        if(arep.status == AUTHOR_STATUS_PASS_ADD ||
+           arep.status == AUTHOR_STATUS_PASS_REPL) {
+            ret = got_tacacs_user(arep.attr, pb);
+            if(debug)
+                syslog(LOG_DEBUG, "%s: TACACS+ server %s successful for user %s."
+                    " local lookup %s", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
+                    ret == 0?"OK":"no match");
+            done = 1; /* break out of loop after arep cleanup */
+        }
+        else {
+            ret = 1; /*  in case last server */
+            if(debug)
+                syslog(LOG_DEBUG, "%s: TACACS+ server %s replies user %s"
+                    " invalid (%d)", nssname,
+                    tac_ntop(tac_srv[srvr].addr->ai_addr), pb->name,
+                    arep.status);
+        }
+        if(arep.msg)
+            free(arep.msg);
+        if(arep.attr) /* free returned attributes */
+            tac_free_attrib(&arep.attr);
+    }
+
+    return ret;
+}
+
+static bool is_valid_name (const char *name)
+{
+    /*
+    * User/group names must match [a-z_][a-z0-9_-]*[$]
+    */
+    if(('\0' == *name) ||
+        !((('a' <= *name) && ('z' >= *name)) || ('_' == *name))) {
+            return false;
+    }
+
+    while('\0' != *++name) {
+        if(!(( ('a' <= *name) && ('z' >= *name) ) ||
+            ( ('0' <= *name) && ('9' >= *name) ) ||
+            ('_' == *name) ||
+            ('-' == *name) ||
+            ( ('$' == *name) && ('\0' == *(name + 1)) )
+            )) {
+            return false;
+        }
+    }
+
+    return true;
+}
+
+static bool is_valid_user_name (const char *name)
+{
+    /*
+    * User names are limited by whatever utmp can
+    * handle.
+    */
+    if(strlen (name) > 32) {
+        return false;
+    }
+
+    return is_valid_name (name);
+}
+
+/*
+ * This is an NSS entry point.
+ * We implement getpwnam(), because we remap from the tacacs.
+ *
+ * We try the lookup to the tacacs server first.  If we can't make a
+ * connection to the server for some reason, we also try looking up
+ * the account name via the mapping file, primarily to handle cases
+ * where we aren't running with privileges to read the tacacs configuration
+ * (since it has the secret key).
+ */
+enum nss_status _nss_tacplus_getpwnam_r(const char *name, struct passwd *pw,
+    char *buffer, size_t buflen, int *errnop)
+{
+    enum nss_status status = NSS_STATUS_NOTFOUND;
+    int result;
+    struct pwbuf pbuf;
+
+    /*
+     * When filename completion is used with the tab key in bash, getpwnam
+     * is invoked. And the parameter "name" is '*'. In order not to connect to
+     * TACACS+ server frequently, check user name whether is valid.
+     */
+    if(!is_valid_user_name(name))
+        return NSS_STATUS_NOTFOUND;
+
+    result = parse_config(config_file);
+
+    if(result) {
+        syslog(LOG_ERR, "%s: bad config or server line for nss_tacplus",
+                nssname);
+    }
+    else if(0 == tac_srv_no) {
+        syslog(LOG_WARNING, "%s: no tacacs server in config for nss_tacplus",
+                nssname);
+    }
+    else {
+        /* marshal the args for the lower level functions */
+        pbuf.name = (char *)name;
+        pbuf.pw = pw;
+        pbuf.buf = buffer;
+        pbuf.buflen = buflen;
+        pbuf.errnop = errnop;
+
+        if(0 == lookup_tacacs_user(&pbuf)) {
+            status = NSS_STATUS_SUCCESS;
+            if(debug)
+                syslog(LOG_DEBUG, "%s: name=%s, pw_name=%s, pw_passwd=%s, pw_shell=%s",
+                    nssname, name, pw->pw_name, pw->pw_passwd, pw->pw_shell);
+        }
+    }
+
+    return status;
+}
diff --git a/tacplus_nss.conf b/tacplus_nss.conf
new file mode 100644
index 0000000..d9679d5
--- /dev/null
+++ b/tacplus_nss.conf
@@ -0,0 +1,45 @@
+# Configuration for libnss-tacplus
+
+# debug - If you want to open debug log, set it on
+#
+# Default: off
+# debug=on
+
+# server - set ip address, tcp port, secret string and timeout for TACACS+ servers
+# The maximum number of servers is 8. If there is no TACACS+ server, libnss-tacplus
+# will always return pwname not found.
+#
+# Default: None (no TACACS+ server)
+# server=1.1.1.1:49,secret=test,timeout=3
+
+# user_priv - set the map between TACACS+ user privilege and local user's passwd
+# If TACACS+ user validate ok, it will get passwd info from local user which is
+# specially created for TACACS+ user in libnss-tacplus. This configuration is provided
+# to create local user. There is two user privilege map by default.
+# If the TACACS+ user's privilege value is in [1, 14], the config of user_priv 1 is
+# used to create local user. If user_priv 7 is added, the TACACS+ user which privilege
+# value is in [1, 6] will get the config of user_priv 1, and the value in [7, 14] will
+# get user_priv 7.
+#
+# If the passwd info of mapped local user is modified, like gid and shell, the new TACACS+
+# user will create local user by the new config. But the old TACACS+ user which has logged
+# will not modify its mapped local user's passwd info. So it's better to keep this
+# configuration unchanged, not to modified at the running time. Or simply delete the old
+# mapped local user after modified.
+#
+# NOTE: If many_to_one enables, 'pw_info' is used for mapped local user name. So note the
+# naming rule for Linux user name when you set 'pw_info', and keep it different from other
+# 'pw_info'.
+#
+# Default:
+# user_priv=15;pw_info=remote_user_su;gid=1000;group=sudo,docker;shell=/bin/bash
+# user_priv=1;pw_info=remote_user;gid=999;group=docker;shell=/bin/bash
+
+# many_to_one - create one local user for many TACACS+ users which has the same privilege
+# The parameter 'pw_info' in 'user_priv' is used for the mapped local user name.
+# The default config is one to one mapping. It will create local user for each TACACS+ user
+# which has different username. The user mapping strategy should be set before enables
+# TACACS+, and keep constant at the running time.
+#
+# Default: many_to_one=n
+# many_to_one=y
-- 
2.7.4

