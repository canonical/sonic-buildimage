#!/usr/bin/env python3

"""
certificate_rollover_checker

This script will be leveraged to periodically check whether the certificate and private key
files of streaming telemetry were rolled over by dSMS service or not. The streaming telemetry
container will be restarted if the certificate and private key are rolled over by dSMS service
and then updated by ACMS agent running in ACMS container.
"""

import os
import signal
import sys
import syslog
import time

from swsscommon import swsscommon

CERTIFICATE_CHECKING_INTERVAL_SECS = 3600


def get_file_last_mod_time(file_path):
    """Gets the last modification time of a specific file.

    Args:
        file_path: A string represents the file path.

    Returns:
        last_mod_time: A float number in seconds represents the last moditification time of file
                       since epoch.
    """
    last_mod_time = 0.0

    try:
        last_mod_time = os.path.getmtime(file_path)
    except OSError as error:
        syslog.syslog(syslog.LOG_ERR,
                      "Could not get last modification time of the file and error message is '{}'.".format(error))
        sys.exit(1)

    return last_mod_time


def restart_streaming_telemetry():
    """Restarts the streaming telemetry container by terminating the root process.

    Args:
        None

    Returns:
        None
    """
    root_process_pid = os.getppid()
    syslog.syslog(syslog.LOG_INFO,
                  "Restarting streaming telemetry service by terminating the process with pid: '{}'".format(root_process_pid))
    os.kill(root_process_pid, signal.SIGTERM)
    sys.exit(0)


def certificate_rollover_check():
    """Checks certificate and key files and restart streaming telemetry contianer if necessary.

    Checks the last modification time of certificate and private key files of streaming telemetry
    to see whether they were already rolled over by dSMS service and updated by ACMS agent running
    in ACMS container. The streaming telemetry container will be restarted if they were rolled over.

    Args:
        None

    Returns:
        None
    """
    certificate_path = ""
    private_key_path = ""
    certificate_last_mod_time = 0
    private_key_last_mod_time = 0

    config_db = swsscommon.DBConnector("CONFIG_DB", 0)
    telemetry_table = swsscommon.Table(config_db, "TELEMETRY")
    telemetry_table_keys = telemetry_table.getKeys()
    if "certs" in telemetry_table_keys:
        certs_info = dict(telemetry_table.get("certs")[1])
        if "server_crt_acms" in certs_info and "server_key_acms" in certs_info:
            certificate_path = certs_info["server_crt_acms"]
            private_key_path = certs_info["server_key_acms"]
            syslog.syslog(syslog.LOG_INFO, "Path of certificate file is '{}'".format(certificate_path))
            syslog.syslog(syslog.LOG_INFO, "Path of key file is '{}'".format(private_key_path))
        else:
            syslog.syslog(syslog.LOG_ERR,
                          "Failed to retrieve the path of certificate and key file from 'TELEMETRY' table!")
            sys.exit(2)
    else:
        syslog.syslog(syslog.LOG_ERR,
                      "Failed to retrieve the certificate information from 'TELEMETRY' table!")
        sys.exit(3)

    while True:
        if not os.path.exists(certificate_path) or not os.path.exists(private_key_path):
            syslog.syslog(syslog.LOG_ERR,
                          "Certificate or key file did not exist on device and sleep '{}' seconds to check again {} ...".format(CERTIFICATE_CHECKING_INTERVAL_SECS))
            time.sleep(CERTIFICATE_CHECKING_INTERVAL_SECS)
        else:
            break

    certificate_last_mod_time = get_file_last_mod_time(certificate_path)
    private_key_last_mod_time = get_file_last_mod_time(private_key_path)

    while True:
        certificate_mod_time = get_file_last_mod_time(certificate_path)
        private_key_mod_time = get_file_last_mod_time(private_key_path)
        syslog.syslog(syslog.LOG_INFO,
                      "Last modification time of certificate file is: '{}'".format(time.ctime(certificate_last_mod_time)))
        syslog.syslog(syslog.LOG_INFO,
                      "Last modification time of key file is: '{}'".format(time.ctime(private_key_last_mod_time)))

        if (certificate_mod_time > certificate_last_mod_time
           or private_key_mod_time > private_key_last_mod_time):
            syslog.syslog(syslog.LOG_INFO,
                          "Last modification time of certificate file is changed to '{}': ".format(time.ctime(certificate_mod_time)))
            syslog.syslog(syslog.LOG_INFO,
                          "Last modification time of key file is changed to '{}': ".format(time.ctime(private_key_mod_time)))
            syslog.syslog(syslog.LOG_INFO,
                          "Secrets were rolled over and restarting streaming telemetry service ...")
            restart_streaming_telemetry()

        # Wait for specified seconds and then do the next round checking
        syslog.syslog(syslog.LOG_INFO,
                      "Sleeping '{}' seconds before doing the next round rollover checking ...".format(CERTIFICATE_CHECKING_INTERVAL_SECS))
        time.sleep(CERTIFICATE_CHECKING_INTERVAL_SECS)


def main():
    certificate_rollover_check()


if __name__ == "__main__":
    main()
    sys.exit(0)
