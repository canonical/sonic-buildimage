#!/usr/bin/env python3

"""
certificate_rotation_checker

This script will be leveraged to periodically check whether the certificate file 
of streaming telemetry was rotated or not. The streaming telemetry server process
will be restarted if the certificate file was rotated.
"""

import os
import subprocess
import sys
import syslog
import time

import inotify.adapters

from swsscommon import swsscommon

MAX_RETRY_TIMES = 10
CERTIFICATE_CHECKING_INTERVAL_SECS = 3600

CREDENTIALS_DIR_PATH = "/etc/sonic/credentials/"


def get_command_result(command):
    """Executes the command and returns the exiting code and resulting output.

    Args:
        command: A string contains the command to be executed.

    Returns:
        An integer indicates the exiting code.
        A string which contains the output of command.
    """
    command_stdout = ""
    command_stderr = ""

    try:
        proc_instance = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                         shell=True, universal_newlines=True)
        command_stdout, command_stderr = proc_instance.communicate()
    except (OSError, ValueError) as err:
        syslog.syslog(syslog.LOG_ERR, "Failed to execute the command '{}'. Error: '{}'"
                      .format(command, err))
        return 2, command_stderr

    return proc_instance.returncode, command_stdout.strip()


def check_telemetry_server_running():
    """Checkes whether telemetry server process is running.

    Args:
        None.

    Returns:
        None.
    """
    processes_status_cmd = "supervisorctl status"
    retry_times = 0
    is_running = False

    while retry_times <= MAX_RETRY_TIMES:
        retry_times += 1
        exit_code, command_stdout = get_command_result(processes_status_cmd)
        if exit_code != 3:
            syslog.syslog(syslog.LOG_INFO,
                          "Failed to get the processes running status in telemetry container and retry after 60 seconds ...")
            time.sleep(60)
        else:
            for line in command_stdout.splitlines():
                if "telemetry" in line and "RUNNING" in line:
                    is_running = True
                    break
            if is_running:
                syslog.syslog(syslog.LOG_INFO,
                              "Telemetry server process is running after certificate and private key were rotated!")
                break

    if not is_running:
        syslog.syslog(syslog.LOG_ERR,
                      "Telemetry server process is not running after certificate and private key were rotated and exiting ...")
        sys.exit(1)


def restart_telemetry_server():
    """Restarts the telemetry server process by Supervisord and then checks
    it is actually running.

    Args:
        None

    Returns:
        None
    """
    restart_telemetry_server_cmd = "supervisorctl restart telemetry"
    retry_times = 0

    while retry_times <= MAX_RETRY_TIMES:
        retry_times += 1
        exit_code, command_stdout = get_command_result(restart_telemetry_server_cmd)
        if exit_code != 0:
            syslog.syslog(syslog.LOG_INFO,
                          "Failed to restart telemetry server process and retry after 60 seconds ...")
            time.sleep(60)
        else:
            break

    if retry_times > MAX_RETRY_TIMES:
        syslog.syslog(syslog.LOG_ERR,
                      "Failed to restart telemetry server process after trying '{}' times and exiting ..."
                      .format(MAX_RETRY_TIMES))
        sys.exit(2)

    check_telemetry_server_running()


def check_certificate_rotated(certificate_file_name):
    """Leverages the 'inotify' module to monitor the file system events under the
    directory which stores the SONiC credentials and restarts telemetry server
    process if its certificate was rotated.


    Args:
        certificate_file_name: A string indicates the telemetry certificate file name.

    Returns:
        None.
    """
    certificate_file_rotated = False

    inotify_instance = inotify.adapters.Inotify()
    inotify_instance.add_watch(CREDENTIALS_DIR_PATH)
    for event in inotify_instance.event_gen(yield_nones=False):
        header, event_type, monitoring_path, file_name = event
        if (file_name == certificate_file_name
                and ("IN_CREATE" in event_type or "IN_MOVED_TO" in event_type)):
            certificate_file_rotated = True

        if (file_name == certificate_file_name and "IN_DELETE" in event_type):
            syslog.syslog(syslog.LOG_ERR, "Certificate file on device was deleted!")

        if certificate_file_rotated:
            certificate_file_rotated = False
            syslog.syslog(syslog.LOG_INFO,
                          "Certificate was rotated and restarting telemetry server process ...")
            restart_telemetry_server()


def certificate_rotated_checker():
    """Checks rotation of certificate file and restart streaming telemetry server if necessary.

    Leverages 'inotify' module to check whether the certificate file of streaming telemetry was
    already rotated or not. The streaming telemetry server process will be restarted if it was rotated.

    Args:
        None

    Returns:
        None
    """
    certificate_file_path = ""
    private_key_file_path = ""
    certificate_file_name = ""

    config_db = swsscommon.DBConnector("CONFIG_DB", 0)
    telemetry_table = swsscommon.Table(config_db, "TELEMETRY")
    telemetry_table_keys = telemetry_table.getKeys()
    if "certs" in telemetry_table_keys:
        certs_info = dict(telemetry_table.get("certs")[1])
        if "server_crt" in certs_info and "server_key" in certs_info:
            certificate_file_path = certs_info["server_crt"]
            private_key_file_path = certs_info["server_key"]
            syslog.syslog(syslog.LOG_INFO, "Path of certificate file is '{}'".format(certificate_file_path))
            syslog.syslog(syslog.LOG_INFO, "Path of private key file is '{}'".format(private_key_file_path))
        else:
            syslog.syslog(syslog.LOG_ERR,
                          "Failed to retrieve the path of certificate file from 'TELEMETRY' table!")
            sys.exit(3)
    else:
        syslog.syslog(syslog.LOG_ERR,
                      "Failed to retrieve the certificate information from 'TELEMETRY' table!")
        sys.exit(4)

    while True:
        if not os.path.exists(certificate_file_path) or not os.path.exists(private_key_file_path):
            syslog.syslog(syslog.LOG_ERR,
                          "Certificate or private key file did not exist on device and sleep '{}' seconds to check again ..."
                          .format(CERTIFICATE_CHECKING_INTERVAL_SECS))
            time.sleep(CERTIFICATE_CHECKING_INTERVAL_SECS)
        else:
            break

    certificate_file_name = certificate_file_path.strip().split("/")[-1]
    if not certificate_file_name:
        syslog.syslog(syslog.LOG_ERR,
                      "Failed to retrieve the file name of certificate!")
        sys.exit(5)

    check_certificate_rotated(certificate_file_name)


def main():
    certificate_rotated_checker()


if __name__ == "__main__":
    main()
    sys.exit(0)
