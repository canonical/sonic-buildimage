#!/usr/bin/env python

import sys
import subprocess
import datetime
import time
import syslog
import signal
import traceback
import os
import tempfile
import json
import yaml
from collections import defaultdict, OrderedDict
from pprint import pprint
from functools import partial

import jinja2
import netaddr
from swsscommon import swsscommon


g_run = True
g_debug = True


def run_command(command, shell=False, hide_errors=False):
    if g_debug:
        syslog.syslog(syslog.LOG_DEBUG, "execute command '%s'." % str(command))
    p = subprocess.Popen(command, shell=shell, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = p.communicate()
    if p.returncode != 0:
        if not hide_errors:
            print_tuple = p.returncode, str(command), stdout, stderr
            syslog.syslog(syslog.LOG_ERR, 'command execution returned %d. Command: "%s", stdout: "%s", stderr: "%s"' % print_tuple)

    return p.returncode, stdout, stderr


class ConfigMgr(object):
    def __init__(self):
        self.current_config = None

    def reset(self):
        self.current_config = None

    def update(self):
        self.current_config = None
        ret_code, out, err = run_command(["vtysh", "-c", "show running-config"])
        if ret_code != 0:
            syslog.syslog(syslog.LOG_CRIT, "can't update running config: rc=%d out='%s' err='%s'" % (ret_code, out, err))
            return
        self.current_config = self.to_canonical(out)

    def push(self, cmd):
        return self.write(cmd)

    def write(self, cmd):
        fd, tmp_filename = tempfile.mkstemp(dir='/tmp')
        os.close(fd)
        with open(tmp_filename, 'w') as fp:
            fp.write("%s\n" % cmd)
        command = ["vtysh", "-f",  tmp_filename]
        ret_code, out, err = run_command(command)
        os.remove(tmp_filename)
        if ret_code != 0:
            err_tuple = str(cmd), ret_code, out, err
            syslog.syslog(syslog.LOG_ERR, "ConfigMgr::push(): can't push configuration '%s', rc='%d', stdout='%s', stderr='%s'" % err_tuple)
        if ret_code == 0:
            self.current_config = None  # invalidate config
        return ret_code == 0

    @staticmethod
    def to_canonical(raw_config):
        parsed_config = []
        cur_offset = 0
        lines = raw_config.split("\n")
        cur_path = [lines[0]]
        for line in lines:
            if line.strip().startswith('!') or line.strip() == '':
                continue
            n_spaces = ConfigMgr.count_spaces(line)
            s_line = line.strip()
            assert(n_spaces == cur_offset or (n_spaces + 1) == cur_offset or (n_spaces - 1) == cur_offset)
            if n_spaces == cur_offset:
                cur_path[-1] = s_line
            elif n_spaces > cur_offset:
                cur_path.append(s_line)
            elif n_spaces < cur_offset:
                cur_path = cur_path[:-2]
                cur_path.append(s_line)
            parsed_config.append(cur_path[:])
            cur_offset = n_spaces
        return parsed_config

    @staticmethod
    def count_spaces(line):
        return len(line) - len(line.lstrip())

    @staticmethod
    def from_canonical(canonical_config):
        out = ""
        for lines in canonical_config:
            spaces = len(lines) - 1
            out += " " * spaces + lines[-1] + "\n"

        return out


class TemplateFabric(object):
    def __init__(self):
        j2_template_paths = ['/usr/share/sonic/templates']
        j2_loader = jinja2.FileSystemLoader(j2_template_paths)
        j2_env = jinja2.Environment(loader=j2_loader, trim_blocks=False)
        j2_env.filters['ipv4'] = self.is_ipv4
        j2_env.filters['ipv6'] = self.is_ipv6
        j2_env.filters['pfx_filter'] = self.pfx_filter
        for attr in ['ip', 'network', 'prefixlen', 'netmask']:
            j2_env.filters[attr] = partial(self.prefix_attr, attr)
        self.env = j2_env

    def from_file(self, filename):
        return self.env.get_template(filename)

    def from_string(self, tmpl):
        return self.env.from_string(tmpl)

    @staticmethod
    def is_ipv4(value):
        if not value:
            return False
        if isinstance(value, netaddr.IPNetwork):
            addr = value
        else:
            try:
                addr = netaddr.IPNetwork(str(value))
            except:
                return False
        return addr.version == 4

    @staticmethod
    def is_ipv6(value):
        if not value:
            return False
        if isinstance(value, netaddr.IPNetwork):
            addr = value
        else:
            try:
                addr = netaddr.IPNetwork(str(value))
            except:
                return False
        return addr.version == 6

    @staticmethod
    def prefix_attr(attr, value):
        if not value:
            return None
        else:
            try:
                prefix = netaddr.IPNetwork(str(value))
            except:
                return None
        return str(getattr(prefix, attr))

    @staticmethod
    def pfx_filter(value):
        """INTERFACE Table can have keys in one of the two formats:
           string or tuple - This filter skips the string keys and only
           take into account the tuple.
           For eg - VLAN_INTERFACE|Vlan1000 vs VLAN_INTERFACE|Vlan1000|192.168.0.1/21
        """
        table = OrderedDict()

        if not value:
            return table

        for key,val in value.items():
            if not isinstance(key, tuple):
                continue
            table[key] = val
        return table


class Directory(object):
    def __init__(self):
        self.data = defaultdict(dict)
        self.notify = defaultdict(lambda: defaultdict(list))

    @staticmethod
    def get_slot_name(db, table):
        return db + "__" + table

    def path_traverse(self, slot, path):
        if slot not in self.data:
            return False, None
        elif path == '':
            return True, self.data[slot]
        d = self.data[slot]
        for p in path.split("/"):
            if p not in d:
                return False, None
            d = d[p]
        return True, d

    def path_exist(self, db, table, path):
        slot = self.get_slot_name(db, table)
        return self.path_traverse(slot, path)[0]

    def get_path(self, db, table, path):
        slot = self.get_slot_name(db, table)
        return self.path_traverse(slot, path)[1]

    def put(self, db, table, key, value):
        slot = self.get_slot_name(db, table)
        self.data[slot][key] = value
        if slot in self.notify:
            for path in self.notify[slot].keys():
                if self.path_exist(db, table, path):
                    for handler in self.notify[slot][path]:
                        handler()

    def get(self, db, table, key):
        slot = self.get_slot_name(db, table)
        return self.data[slot][key]

    def get_slot(self, db, table):
        slot = self.get_slot_name(db, table)
        return self.data[slot]

    def remove(self, db, table, key):
        slot = self.get_slot_name(db, table)
        if slot in self.data:
            if key in self.data[slot]:
                del self.data[slot][key]
            else:
                syslog.syslog(syslog.LOG_ERR, "Directory: Can't remove key '%s' from slot '%s'. The key doesn't exist" % (key, slot))
        else:
            syslog.syslog(syslog.LOG_ERR, "Directory: Can't remove key '%s' from slot '%s'. The slot doesn't exist" % (key, slot))

    def remove_slot(self, db, table):
        slot = self.get_slot_name(db, table)
        if slot in self.data:
            del self.data[slot]
        else:
            syslog.syslog(syslog.LOG_ERR, "Directory: Can't remove slot '%s'. The slot doesn't exist" % slot)

    def available(self, db, table):
        slot = self.get_slot_name(db, table)
        return slot in self.data

    def available_deps(self, deps):
        res = True
        for db, table, path in deps:
            res = res and self.path_exist(db, table, path)
        return res

    def subscribe(self, deps, handler):
        for db, table, path in deps:
            slot = self.get_slot_name(db, table)
            self.notify[slot][path].append(handler)


class Daemon(object):
    SELECT_TIMEOUT = 1000

    def __init__(self):
        self.db_connectors = {}
        self.selector = swsscommon.Select()
        self.callbacks = defaultdict(lambda : defaultdict(list))  # db -> table -> []
        self.subscribers = set()

    def add_manager(self, db_name, table_name, callback):
        db = swsscommon.SonicDBConfig.getDbId(db_name)
        if db not in self.db_connectors:
            self.db_connectors[db] = swsscommon.DBConnector(db_name, 0)

        if table_name not in self.callbacks[db]:
            conn = self.db_connectors[db]
            subscriber = swsscommon.SubscriberStateTable(conn, table_name)
            self.subscribers.add(subscriber)
            self.selector.addSelectable(subscriber)
        self.callbacks[db][table_name].append(callback)

    def run(self):
        while g_run:
            state, _ = self.selector.select(Daemon.SELECT_TIMEOUT)
            if state == self.selector.TIMEOUT:
                continue
            elif state == self.selector.ERROR:
                raise Exception("Received error from select")

            for subscriber in self.subscribers:
                key, op, fvs = subscriber.pop()
                if not key:
                    continue
                if g_debug:
                    syslog.syslog(syslog.LOG_DEBUG, "Received message : '%s'" % str((key, op, fvs)))
                for callback in self.callbacks[subscriber.getDbConnector().getDbId()][subscriber.getTableName()]:
                    callback(key, op, dict(fvs))


class Manager(object):
    def __init__(self, common_objs, deps, database, table_name):
        self.daemon = common_objs['daemon']
        self.directory = common_objs['directory']
        self.cfg_mgr = common_objs['cfg_mgr']
        self.constants = common_objs['constants']
        self.deps = deps
        self.db_id = database
        self.table_name = table_name
        self.set_queue = []
        self.daemon.add_manager(database, table_name, self.handler)
        self.directory.subscribe(deps, self.on_deps_change)

    def handler(self, key, op, data):
        if op == swsscommon.SET_COMMAND:
            if self.directory.available_deps(self.deps):
                res = self.set_handler(key, data)
                if not res:
                    self.set_queue.append((key, data))
            else:
                self.set_queue.append((key, data))
        elif op == swsscommon.DEL_COMMAND:
            self.del_handler(key)
        else:
            syslog.syslog(syslog.LOG_ERR, 'Invalid operation "%s" for key "%s"' % (op, key))

    def on_deps_change(self):
        if not self.directory.available_deps(self.deps):
            return
        new_queue = []
        for key, data in self.set_queue:
            res = self.set_handler(key, data)
            if not res:
                new_queue.append((key, data))
        self.set_queue = new_queue

    def set_handler(self, key, data):
        syslog.syslog(syslog.LOG_ERR, "%s wasn't implemented for %s" % (self.__name__, self.__class__))

    def del_handler(self, key):
        syslog.syslog(syslog.LOG_ERR, "%s wasn't implemented for %s" % (self.__name__, self.__class__))


class BGPDataBaseMgr(Manager):
    def __init__(self, common_objs, db, table):
        super(BGPDataBaseMgr, self).__init__(
            common_objs,
            [],
            db,
            table,
        )

    def set_handler(self, key, data):
        self.directory.put(self.db_id, self.table_name, key, data)

        return True

    def del_handler(self, key):
        self.directory.remove(self.db_id, self.table_name, key)


class BGPPeerGroupMgr(object):
    def __init__(self, common_objs, base_template):
        self.cfg_mgr = common_objs['cfg_mgr']
        self.constants = common_objs['constants']
        tf = common_objs['tf']
        self.policy_template = tf.from_file(base_template + "policies.conf.j2")
        self.peergroup_template = tf.from_file(base_template + "peer-group.conf.j2")

    def update(self, name, **kwargs):
        rc_policy = self.update_policy(name, **kwargs)
        rc_pg = self.update_pg(name, **kwargs)
        return rc_policy and rc_pg

    def update_policy(self, name, **kwargs):
        try:
            policy = self.policy_template.render(**kwargs)
        except:
            syslog.syslog(syslog.LOG_ERR, "Can't render policy template name: '%s'" % name)
            return False

        return self.update_entity(policy, "Routing policy for peer '%s'" % name)

    def update_pg(self, name, **kwargs):
        try:
            pg = self.peergroup_template.render(**kwargs)
        except:
            syslog.syslog(syslog.LOG_ERR, "Can't render peer-group template: '%s'" % name)
            return False

        if kwargs['vrf'] == 'default':
            cmd = ('router bgp %s\n' % kwargs['bgp_asn']) + pg
        else:
            cmd = ('router bgp %s vrf %s\n' % (kwargs['bgp_asn'], kwargs['vrf'])) + pg

        return self.update_entity(cmd, "Peer-group for peer '%s'" % name)

    def update_entity(self, cmd, txt):
        ret_code = self.cfg_mgr.push(cmd)
        if ret_code:
            syslog.syslog(syslog.LOG_INFO, "%s was updated" % txt)
        else:
            syslog.syslog(syslog.LOG_ERR, "Can't update %s" % txt)
        return ret_code


class BGPPeerMgrBase(Manager):
    def __init__(self, common_objs, table_name, peer_type):
        self.common_objs = common_objs
        self.fabric = common_objs['tf']
        self.constants = common_objs['constants']
        self.table_name = table_name
        self.peer_type = peer_type

        base_template = "bgpd/templates/" + self.constants["bgp"]["peers"][peer_type]["template_dir"] + "/"
        self.templates = {
            "add":         self.fabric.from_file(base_template + "instance.conf.j2"),
            "delete":      self.fabric.from_string('no neighbor {{ neighbor_addr }}'),
            "shutdown":    self.fabric.from_string('neighbor {{ neighbor_addr }} shutdown'),
            "no shutdown": self.fabric.from_string('no neighbor {{ neighbor_addr }} shutdown'),
        }

        deps = [
                ("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME, "localhost/bgp_asn"),
                ("CONFIG_DB", swsscommon.CFG_LOOPBACK_INTERFACE_TABLE_NAME, "Loopback0/"),
        ]

        self.check_neig_meta = 'bgp' in self.constants \
                               and 'use_neighbors_meta' in self.constants['bgp'] \
                               and self.constants['bgp']['use_neighbors_meta']
        self.check_deployment_id = 'bgp' in self.constants \
                               and 'use_deployment_id' in self.constants['bgp'] \
                               and self.constants['bgp']['use_deployment_id']

        if self.check_neig_meta:
            deps.append(("CONFIG_DB", swsscommon.CFG_DEVICE_NEIGHBOR_METADATA_TABLE_NAME, ""))

        if self.check_deployment_id:
            deps.append(("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME, "localhost/deployment_id"))

        super(BGPPeerMgrBase, self).__init__(
            common_objs,
            deps,
            "CONFIG_DB",
            table_name,
        )

        self.peers = self.load_peers()
        self.peer_group_mgr = BGPPeerGroupMgr(self.common_objs, base_template)
        return

    def set_handler(self, key, data):
        vrf, nbr = self.split_key(key)
        if key not in self.peers:
            return self.add_peer(vrf, nbr, data)
        else:
            return self.update_peer(vrf, nbr, data)

    def add_peer(self, vrf, nbr, data):
        print_data = vrf, nbr, data
        bgp_asn = self.directory.get_slot("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME)["localhost"]["bgp_asn"]
        #
        lo0_ipv4 = self.get_lo0_ipv4()
        if lo0_ipv4 is None:
            syslog.syslog(syslog.LOG_WARNING, "Loppback0 ipv4 address is not presented yet")
            return False
        #
        kwargs = {
            'CONFIG_DB__DEVICE_METADATA': self.directory.get_slot("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME),
            'constants': self.constants,
            'bgp_asn': bgp_asn,
            'vrf': vrf,
            'neighbor_addr': nbr,
            'bgp_session': data,
            'loopback0_ipv4': lo0_ipv4,
        }
        if self.check_neig_meta:
            neigmeta = self.directory.get_slot("CONFIG_DB", swsscommon.CFG_DEVICE_NEIGHBOR_METADATA_TABLE_NAME)
            if 'name' in data and data["name"] not in neigmeta:
                return False
            kwargs['CONFIG_DB__DEVICE_NEIGHBOR_METADATA'] = neigmeta

        self.peer_group_mgr.update(data['name'], **kwargs)  # FIXME: data['name']

        try:
            cmd = self.templates["add"].render(**kwargs)
        except:
            syslog.syslog(syslog.LOG_ERR, 'Peer "(%s|%s)". Error in rendering the template for "SET" command "%s"' % print_data)
            return True
        if cmd is not None:
            ret_code = self.apply_op(cmd, vrf)
            key = (vrf, nbr)
            if ret_code:
                self.peers.add(key)
                syslog.syslog(syslog.LOG_INFO, 'Peer "(%s|%s)" added with attributes "%s"' % print_data)
            else:
                syslog.syslog(syslog.LOG_ERR, "Peer '(%s|%s)' wasn't added." % (vrf, nbr))

        return True

    def update_peer(self, vrf, nbr, data):
        # when the peer is already configured we support "shutdown/no shutdown"
        # commands for the peers only
        if "admin_status" in data:
            self.change_admin_status(vrf, nbr, data)
        else:
            syslog.syslog(syslog.LOG_ERR, "Peer '(%s|%s)': Can't update the peer. Only 'admin_status' attribute is supported" % (vrf, nbr))

        return True

    def change_admin_status(self, vrf, nbr, data):
        if data['admin_status'] == 'up':
            self.apply_admin_status(vrf, nbr, "no shutdown", "up")
        elif data['admin_status'] == 'down':
            self.apply_admin_status(vrf, nbr, "shutdown", "down")
        else:
            print_data = vrf, nbr, data['admin_status']
            syslog.syslog(syslog.LOG_ERR, "Peer '%s|%s': Can't update the peer. It has wrong attribute value attr['admin_status'] = '%s'" % print_data)

    def apply_admin_status(self, vrf, nbr, template_name, admin_state):
        print_data = vrf, nbr, admin_state
        ret_code = self.apply_op(self.templates[template_name].render(neighbor_addr=nbr), vrf)
        if ret_code:
            syslog.syslog(syslog.LOG_INFO, "Peer '%s|%s' admin state is set to '%s'" % print_data)
        else:
            syslog.syslog(syslog.LOG_ERR, "Can't set peer '%s|%s' admin state to '%s'." % print_data)

    def del_handler(self, key):
        vrf, nbr = self.split_key(key)
        if key not in self.peers:
            syslog.syslog(syslog.LOG_WARNING, 'Peer "(%s|%s)" has not been found' % (vrf, nbr))
            return
        cmd = self.templates["delete"].render(neighbor_addr=nbr)
        ret_code = self.apply_op(cmd, vrf)
        if ret_code:
            syslog.syslog(syslog.LOG_INFO, 'Peer "(%s|%s)" has been removed' % (vrf, nbr))
            self.peers.remove(key)
        else:
            syslog.syslog(syslog.LOG_ERR, "Peer '(%s|%s)' hasn't been removed" % (vrf, nbr))

    def apply_op(self, cmd, vrf):
        bgp_asn = self.directory.get_slot("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME)["localhost"]["bgp_asn"]
        if vrf == 'default':
            cmd = ('router bgp %s\n' % bgp_asn) + cmd
        else:
            cmd = ('router bgp %s vrf %s\n' % (bgp_asn, vrf)) + cmd
        return self.cfg_mgr.push(cmd)

    def get_lo0_ipv4(self):
        loopback0_ipv4 = None
        for loopback in self.directory.get_slot("CONFIG_DB", swsscommon.CFG_LOOPBACK_INTERFACE_TABLE_NAME).iterkeys():
           if loopback.startswith("Loopback0|"):
                loopback0_prefix_str = loopback.replace("Loopback0|", "")
                loopback0_ip_str = loopback0_prefix_str[:loopback0_prefix_str.find('/')]
                if TemplateFabric.is_ipv4(loopback0_ip_str):
                    loopback0_ipv4 = loopback0_ip_str
                    break

        return loopback0_ipv4

    @staticmethod
    def split_key(key):
        if '|' not in key:
            return 'default', key
        else:
            return tuple(key.split('|', 1))

    @staticmethod
    def load_peers():
        vrfs = []
        command = ["vtysh", "-c",  "show bgp vrfs json"]
        ret_code, out, err = run_command(command)
        if ret_code == 0:
            js_vrf = json.loads(out)
            vrfs = js_vrf['vrfs'].keys()
        else:
            syslog.syslog(syslog.LOG_CRIT, "Can't read bgp vrfs")
            raise Exception("Can't read bgp vrfs")
        peers = set()
        for vrf in vrfs:
            command = ["vtysh", "-c",  'show bgp vrf %s neighbors json' % str(vrf)]
            ret_code, out, err = run_command(command)
            if ret_code == 0:
                js_bgp = json.loads(out)
                for nbr in js_bgp.keys():
                    peers.add((vrf, nbr))
            else:
                syslog.syslog(syslog.LOG_CRIT, "Can't read vrf '%s' neighbors" % vrf)
                raise Exception("Can't read vrf '%s' neighbors" % vrf)

        return peers


def wait_for_bgpd():
    # wait for 20 seconds
    stop_time = datetime.datetime.now() + datetime.timedelta(seconds=20)
    syslog.syslog(syslog.LOG_INFO, "Start waiting for bgpd: %s" % str(datetime.datetime.now()))
    while datetime.datetime.now() < stop_time:
        ret_code, out, err = run_command(["vtysh", "-c", "show daemons"], hide_errors=True)
        if ret_code == 0 and "bgpd" in out and "zebra" in out:
            syslog.syslog(syslog.LOG_INFO, "bgpd and zebra connected to vtysh: %s" % str(datetime.datetime.now()))
            return
        time.sleep(0.1)  # sleep 100 ms
    raise RuntimeError("bgpd hasn't been started in 20 seconds")


def read_constants():
    with open('/etc/sonic/constants.yml') as fp:
        content = yaml.load(fp)
        if "constants" not in content:
            syslog.syslog(syslog.LOG_CRIT, "constants.yml doesn't have 'constants' key")
            raise Exception("constants.yml doesn't have 'constants' key")
        return content["constants"]


def main():
    db_managers_init = [
        ("CONFIG_DB", swsscommon.CFG_DEVICE_METADATA_TABLE_NAME),
        ("CONFIG_DB", swsscommon.CFG_DEVICE_NEIGHBOR_METADATA_TABLE_NAME),
        ("CONFIG_DB", swsscommon.CFG_LOOPBACK_INTERFACE_TABLE_NAME),
    ]

    peer_managers_init = [
        (swsscommon.CFG_BGP_NEIGHBOR_TABLE_NAME, "general"),
        ("BGP_MONITORS", "monitors"),
        ("BGP_PEER_RANGE", "dynamic"),
    ]

    wait_for_bgpd()

    daemon = Daemon()

    common_objs = {
        'daemon':    daemon,
        'directory': Directory(),
        'cfg_mgr':   ConfigMgr(),
        'tf':        TemplateFabric(),
        'constants': read_constants(),
    }

    manager_instanses = []

    for db, table in db_managers_init:
        mgr = BGPDataBaseMgr(common_objs, db, table)
        manager_instanses.append(mgr)

    for peer_table_name, peer_type in peer_managers_init:
        mgr = BGPPeerMgrBase(common_objs, peer_table_name, peer_type)
        manager_instanses.append(mgr)

    daemon.run()

    return


def signal_handler(signum, frame):
    global g_run
    g_run = False


if __name__ == '__main__':
    rc = 0
    try:
        syslog.openlog('bgpcfgd')
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)
        main()
    except KeyboardInterrupt:
        syslog.syslog(syslog.LOG_NOTICE, "Keyboard interrupt")
    except RuntimeError as e:
        syslog.syslog(syslog.LOG_CRIT, "%s" % str(e))
        rc = -2
        if g_debug:
            raise
    except Exception as e:
        syslog.syslog(syslog.LOG_CRIT, "Got an exception %s: Traceback: %s" % (str(e), traceback.format_exc()))
        rc = -1
        if g_debug:
            raise
    finally:
        syslog.closelog()
    try:
        sys.exit(rc)
    except SystemExit:
        os._exit(rc)
